Snapshot.HalogenVDomST01.bind (Step 0; Original)
  (Control.Bind.bind Effect.bindEffect)
---------------
Snapshot.HalogenVDomST01.bind (Step 1; Final)
  Effect.bindE

===============

Snapshot.HalogenVDomST01.diffWithIxE (Step 0; Original)
  (Effect.Uncurried.mkEffectFn5
    (\a1@v0 -> \a2@v1 -> \f1@v2 -> \f2@v3 -> \f3@v4 ->
      (Snapshot.HalogenVDomST01.bind
        (Snapshot.HalogenVDomST01.liftST Data.Array.ST.new)
        (\a3@v5 ->
          let l1@v6 = (Data.Array.length a1@v0);
          let l2@v7 = (Data.Array.length a2@v1);
          -- Inline l3@v8
          let l3@v8 =
            -- Inline v8
            let v8 = ((Snapshot.HalogenVDomST01.lessThan l1@v6) l2@v7);
            -- Inline v9
            let v9 = (\-> l2@v7);
            -- Inline v10
            let v10 = (\-> l1@v6);
            if ((eq v8) true) then (v9!) else (v10!);
          (Snapshot.HalogenVDomST01.discard
            (Effect.forE
              0
              l3@v8
              (\i@v9 ->
                -- Inline v10
                let v10 = ((Snapshot.HalogenVDomST01.lessThan i@v9) l1@v6);
                -- Inline v11
                let v11 =
                  (\->
                    -- Inline v11
                    let v11 = ((Snapshot.HalogenVDomST01.lessThan i@v9) l2@v7);
                    -- Inline v12
                    let v12 =
                      (\->
                        -- Inline v1@v12
                        let v1@v12 =
                          (Partial.Unsafe.unsafePartial
                            (\$__unused@v12 ->
                              Snapshot.HalogenVDomST01.unsafeIndex
                            )
                            a1@v0
                            i@v9
                          );
                        -- Inline v2@v13
                        let v2@v13 =
                          (Partial.Unsafe.unsafePartial
                            (\$__unused@v13 ->
                              Snapshot.HalogenVDomST01.unsafeIndex
                            )
                            a2@v1
                            i@v9
                          );
                        (Snapshot.HalogenVDomST01.bind
                          (Effect.Uncurried.runEffectFn3
                            f1@v2
                            i@v9
                            v1@v12
                            v2@v13
                          )
                          (\v3@v14 ->
                            (Snapshot.HalogenVDomST01.void
                              (Snapshot.HalogenVDomST01.liftST
                                ((Data.Array.ST.push v3@v14) a3@v5)
                              )
                            )
                          )
                        )
                      );
                    -- Inline v13
                    let v13 =
                      (\->
                        -- Inline v1@v13
                        let v1@v13 =
                          (Partial.Unsafe.unsafePartial
                            (\$__unused@v13 ->
                              Snapshot.HalogenVDomST01.unsafeIndex
                            )
                            a1@v0
                            i@v9
                          );
                        (((Effect.Uncurried.runEffectFn2 f2@v3) i@v9) v1@v13)
                      );
                    if ((eq v11) true) then (v12!) else (v13!)
                  );
                -- Inline v12
                let v12 =
                  (\->
                    -- Inline v12
                    let v12 = ((Snapshot.HalogenVDomST01.lessThan i@v9) l2@v7);
                    -- Inline v13
                    let v13 =
                      (\->
                        -- Inline v2@v13
                        let v2@v13 =
                          (Partial.Unsafe.unsafePartial
                            (\$__unused@v13 ->
                              Snapshot.HalogenVDomST01.unsafeIndex
                            )
                            a2@v1
                            i@v9
                          );
                        (Snapshot.HalogenVDomST01.bind
                          (((Effect.Uncurried.runEffectFn2 f3@v4) i@v9) v2@v13)
                          (\v3@v14 ->
                            (Snapshot.HalogenVDomST01.void
                              (Snapshot.HalogenVDomST01.liftST
                                ((Data.Array.ST.push v3@v14) a3@v5)
                              )
                            )
                          )
                        )
                      );
                    -- Inline v14
                    let v14 =
                      (\-> (Snapshot.HalogenVDomST01.pure Data.Unit.unit));
                    if ((eq v12) true) then (v13!) else (v14!)
                  );
                if ((eq v10) true) then (v11!) else (v12!)
              )
            )
            (\$__unused@v9 ->
              (Snapshot.HalogenVDomST01.liftST
                (Data.Array.ST.unsafeFreeze a3@v5)
              )
            )
          )
        )
      )
    )
  )
---------------
Snapshot.HalogenVDomST01.diffWithIxE (Step 1)
  (# \a1@v0 a2@v1 f1@v2 f2@v3 f3@v4 ->
    letEffect a3@v5 = Data.Array.ST.new;
    let l1@v6 = (arrayLength a1@v0);
    let l2@v7 = (arrayLength a2@v1);
    let v8 =
      -- Inline v8
      let v8 = 0;
      -- LetAssoc
      let v9 =
        let v9 = if ((lt l1@v6) l2@v7) then l2@v7 else l1@v6;
        (# effectDefer
          (-- Stop
          Effect.forE
            v8
            v9
            (\i@v10 ->
              (# effectDefer
                if ((lt i@v10) l1@v6) then
                  if ((lt i@v10) l2@v7) then
                    -- LetAssoc
                    let v11 =
                      let v11 = ((arrayIndex a1@v0) i@v10);
                      -- LetAssoc
                      let v12 =
                        let v12 = ((arrayIndex a2@v1) i@v10);
                        (# f1@v2 i@v10 v11 v12 #);
                      v12;
                    -- Inline v12
                    let v12 =
                      letEffect v3@v12 = v11;
                      -- Inline v13
                      let v13 =
                        (# effectDefer
                          (-- Stop
                          Data.Array.ST.pushAll
                            [ v3@v12 ]
                            a3@v5
                          )
                        #);
                      (# effectDefer
                        letEffect a'@v14 = v13;
                        (# effectPure <PrimUndefined> #)
                      #);
                    v12
                  else
                    let v11 = ((arrayIndex a1@v0) i@v10);
                    -- Inline v12
                    let v12 = (# f2@v3 i@v10 v11 #);
                    v12
                else if ((lt i@v10) l2@v7) then
                  -- LetAssoc
                  let v11 =
                    let v11 = ((arrayIndex a2@v1) i@v10);
                    -- Inline v12
                    let v12 = (# f3@v4 i@v10 v11 #);
                    v12;
                  -- Inline v12
                  let v12 =
                    letEffect v3@v12 = v11;
                    -- Inline v13
                    let v13 =
                      (# effectDefer
                        (-- Stop
                        Data.Array.ST.pushAll
                          [ v3@v12 ]
                          a3@v5
                        )
                      #);
                    (# effectDefer
                      letEffect a'@v14 = v13;
                      (# effectPure <PrimUndefined> #)
                    #);
                  v12
                else
                  -- Inline v11
                  let v11 = <PrimUndefined>;
                  -- Inline v12
                  let v12 = (# effectPure v11 #);
                  v12
              #)
            )
          )
        #);
      v9;
    -- Inline v9
    let v9 =
      letEffect $__unused@v9 = v8;
      (# effectPure a3@v5 #);
    v9
  #)
---------------
Snapshot.HalogenVDomST01.diffWithIxE (Step 2)
  (# \a1@v0 a2@v1 f1@v2 f2@v3 f3@v4 ->
    letEffect a3@v5 = Data.Array.ST.new;
    let l1@v6 = (arrayLength a1@v0);
    let l2@v7 = (arrayLength a2@v1);
    -- LetAssoc
    let v8 =
      let v8 = if ((lt l1@v6) l2@v7) then l2@v7 else l1@v6;
      -- Inline v9
      let v9 =
        (# effectDefer
          (-- Stop
          Effect.forE
            0
            v8
            (\i@v9 ->
              (# effectDefer
                if ((lt i@v9) l1@v6) then
                  if ((lt i@v9) l2@v7) then
                    let v10 = ((arrayIndex a1@v0) i@v9);
                    -- LetAssoc
                    let v11 =
                      let v11 = ((arrayIndex a2@v1) i@v9);
                      -- Inline v12
                      let v12 = (# f1@v2 i@v9 v10 v11 #);
                      v12;
                    letEffect v3@v12 = v11;
                    letEffect a'@v13 =
                      (-- Stop
                      Data.Array.ST.pushAll
                        [ v3@v12 ]
                        a3@v5
                      );
                    (# effectPure <PrimUndefined> #)
                  else
                    -- Inline v10
                    let v10 = ((arrayIndex a1@v0) i@v9);
                    (# f2@v3 i@v9 v10 #)
                else if ((lt i@v9) l2@v7) then
                  let v10 = ((arrayIndex a2@v1) i@v9);
                  -- Inline v11
                  let v11 = (# f3@v4 i@v9 v10 #);
                  letEffect v3@v12 = v11;
                  letEffect a'@v13 =
                    (-- Stop
                    Data.Array.ST.pushAll
                      [ v3@v12 ]
                      a3@v5
                    );
                  (# effectPure <PrimUndefined> #)
                else
                  (# effectPure <PrimUndefined> #)
              #)
            )
          )
        #);
      v9;
    letEffect $__unused@v9 = v8;
    (# effectPure a3@v5 #)
  #)
---------------
Snapshot.HalogenVDomST01.diffWithIxE (Step 3)
  (# \a1@v0 a2@v1 f1@v2 f2@v3 f3@v4 ->
    letEffect a3@v5 = Data.Array.ST.new;
    let l1@v6 = (arrayLength a1@v0);
    let l2@v7 = (arrayLength a2@v1);
    let v8 = if ((lt l1@v6) l2@v7) then l2@v7 else l1@v6;
    -- Inline v9
    let v9 =
      (# effectDefer
        (-- Stop
        Effect.forE
          0
          v8
          (\i@v9 ->
            (# effectDefer
              if ((lt i@v9) l1@v6) then
                if ((lt i@v9) l2@v7) then
                  let v10 = ((arrayIndex a1@v0) i@v9);
                  let v11 = ((arrayIndex a2@v1) i@v9);
                  -- Inline v12
                  let v12 = (# f1@v2 i@v9 v10 v11 #);
                  letEffect v3@v13 = v12;
                  letEffect a'@v14 =
                    (-- Stop
                    Data.Array.ST.pushAll
                      [ v3@v13 ]
                      a3@v5
                    );
                  (# effectPure <PrimUndefined> #)
                else
                  (# f2@v3 i@v9 ((arrayIndex a1@v0) i@v9) #)
              else if ((lt i@v9) l2@v7) then
                -- Inline v10
                let v10 = ((arrayIndex a2@v1) i@v9);
                letEffect v3@v11 = (# f3@v4 i@v9 v10 #);
                letEffect a'@v12 =
                  (-- Stop
                  Data.Array.ST.pushAll
                    [ v3@v11 ]
                    a3@v5
                  );
                (# effectPure <PrimUndefined> #)
              else
                (# effectPure <PrimUndefined> #)
            #)
          )
        )
      #);
    letEffect $__unused@v10 = v9;
    (# effectPure a3@v5 #)
  #)
---------------
Snapshot.HalogenVDomST01.diffWithIxE (Step 4)
  (# \a1@v0 a2@v1 f1@v2 f2@v3 f3@v4 ->
    letEffect a3@v5 = Data.Array.ST.new;
    let l1@v6 = (arrayLength a1@v0);
    let l2@v7 = (arrayLength a2@v1);
    -- Inline v8
    let v8 = if ((lt l1@v6) l2@v7) then l2@v7 else l1@v6;
    letEffect $__unused@v9 =
      (-- Stop
      Effect.forE
        0
        v8
        (\i@v9 ->
          (# effectDefer
            if ((lt i@v9) l1@v6) then
              if ((lt i@v9) l2@v7) then
                -- Inline v10
                let v10 = ((arrayIndex a1@v0) i@v9);
                -- Inline v11
                let v11 = ((arrayIndex a2@v1) i@v9);
                letEffect v3@v12 = (# f1@v2 i@v9 v10 v11 #);
                letEffect a'@v13 =
                  (-- Stop
                  Data.Array.ST.pushAll
                    [ v3@v12 ]
                    a3@v5
                  );
                (# effectPure <PrimUndefined> #)
              else
                (# f2@v3 i@v9 ((arrayIndex a1@v0) i@v9) #)
            else if ((lt i@v9) l2@v7) then
              letEffect v3@v10 = (# f3@v4 i@v9 ((arrayIndex a2@v1) i@v9) #);
              letEffect a'@v11 =
                (-- Stop
                Data.Array.ST.pushAll
                  [ v3@v10 ]
                  a3@v5
                );
              (# effectPure <PrimUndefined> #)
            else
              (# effectPure <PrimUndefined> #)
          #)
        )
      );
    (# effectPure a3@v5 #)
  #)
---------------
Snapshot.HalogenVDomST01.diffWithIxE (Step 5; Final)
  (# \a1@v0 a2@v1 f1@v2 f2@v3 f3@v4 ->
    letEffect a3@v5 = Data.Array.ST.new;
    let l1@v6 = (arrayLength a1@v0);
    let l2@v7 = (arrayLength a2@v1);
    letEffect $__unused@v8 =
      (-- Stop
      Effect.forE
        0
        if ((lt l1@v6) l2@v7) then l2@v7 else l1@v6
        (\i@v8 ->
          (# effectDefer
            if ((lt i@v8) l1@v6) then
              if ((lt i@v8) l2@v7) then
                letEffect v3@v9 =
                  (# f1@v2
                    i@v8
                    ((arrayIndex a1@v0) i@v8)
                    ((arrayIndex a2@v1) i@v8)
                  #);
                letEffect a'@v10 =
                  (-- Stop
                  Data.Array.ST.pushAll
                    [ v3@v9 ]
                    a3@v5
                  );
                (# effectPure <PrimUndefined> #)
              else
                (# f2@v3 i@v8 ((arrayIndex a1@v0) i@v8) #)
            else if ((lt i@v8) l2@v7) then
              letEffect v3@v9 = (# f3@v4 i@v8 ((arrayIndex a2@v1) i@v8) #);
              letEffect a'@v10 =
                (-- Stop
                Data.Array.ST.pushAll
                  [ v3@v9 ]
                  a3@v5
                );
              (# effectPure <PrimUndefined> #)
            else
              (# effectPure <PrimUndefined> #)
          #)
        )
      );
    (# effectPure a3@v5 #)
  #)

===============

Snapshot.HalogenVDomST01.diffWithKeyAndIxE (Step 0; Original)
  (Effect.Uncurried.mkEffectFn6
    (\o1@v0 -> \as@v1 -> \fk@v2 -> \f1@v3 -> \f2@v4 -> \f3@v5 ->
      (Snapshot.HalogenVDomST01.bind
        (Snapshot.HalogenVDomST01.liftST Foreign.Object.ST.new)
        (\o2@v6 ->
          (Snapshot.HalogenVDomST01.discard
            (Effect.forE
              0
              (Data.Array.length as@v1)
              (\i@v7 ->
                let a@v8 =
                  (Partial.Unsafe.unsafePartial
                    (\$__unused@v8 -> Snapshot.HalogenVDomST01.unsafeIndex)
                    as@v1
                    i@v7
                  );
                let k@v9 = (fk@v2 a@v8);
                -- Inline v10
                let v10 = ((Foreign.Object.member k@v9) o1@v0);
                -- Inline v11
                let v11 =
                  (\->
                    -- Inline v1@v11
                    let v1@v11 =
                      ((Foreign.Object.Unsafe.unsafeIndex o1@v0) k@v9);
                    (Snapshot.HalogenVDomST01.bind
                      (Effect.Uncurried.runEffectFn4
                        f1@v3
                        k@v9
                        i@v7
                        v1@v11
                        a@v8
                      )
                      (\v2@v12 ->
                        (Snapshot.HalogenVDomST01.void
                          (Snapshot.HalogenVDomST01.liftST
                            (((Foreign.Object.ST.poke k@v9) v2@v12) o2@v6)
                          )
                        )
                      )
                    )
                  );
                -- Inline v12
                let v12 =
                  (\->
                    (Snapshot.HalogenVDomST01.bind
                      ((((Effect.Uncurried.runEffectFn3 f3@v5) k@v9) i@v7) a@v8)
                      (\v2@v12 ->
                        (Snapshot.HalogenVDomST01.void
                          (Snapshot.HalogenVDomST01.liftST
                            (((Foreign.Object.ST.poke k@v9) v2@v12) o2@v6)
                          )
                        )
                      )
                    )
                  );
                if ((eq v10) true) then (v11!) else (v12!)
              )
            )
            (\$__unused@v7 ->
              (Snapshot.HalogenVDomST01.bind
                (Snapshot.HalogenVDomST01.liftST
                  (Foreign.Object.ST.Unsafe.unsafeFreeze o2@v6)
                )
                (\o3@v8 ->
                  (Snapshot.HalogenVDomST01.discard
                    (Effect.foreachE
                      (Foreign.Object.keys o1@v0)
                      (\k@v9 ->
                        -- Inline v10
                        let v10 = ((Foreign.Object.member k@v9) o3@v8);
                        -- Inline v11
                        let v11 =
                          (\-> (Snapshot.HalogenVDomST01.pure Data.Unit.unit));
                        -- Inline v12
                        let v12 =
                          (\->
                            (Snapshot.HalogenVDomST01.void
                              (Effect.Uncurried.runEffectFn2
                                f2@v4
                                k@v9
                                ((Foreign.Object.Unsafe.unsafeIndex o1@v0) k@v9)
                              )
                            )
                          );
                        if ((eq v10) true) then (v11!) else (v12!)
                      )
                    )
                    (\$__unused@v9 -> (Snapshot.HalogenVDomST01.pure o3@v8))
                  )
                )
              )
            )
          )
        )
      )
    )
  )
---------------
Snapshot.HalogenVDomST01.diffWithKeyAndIxE (Step 1)
  (# \o1@v0 as@v1 fk@v2 f1@v3 f2@v4 f3@v5 ->
    letEffect o2@v6 = Foreign.Object.ST.new;
    let v7 =
      -- Inline v7
      let v7 = 0;
      -- LetAssoc
      let v8 =
        let v8 = (arrayLength as@v1);
        (# effectDefer
          (-- Stop
          Effect.forE
            v7
            v8
            (\i@v9 ->
              (# effectDefer
                let a@v10 = ((arrayIndex as@v1) i@v9);
                let k@v11 = (fk@v2 a@v10);
                if (-- Stop
                Foreign.Object.member
                  k@v11
                  o1@v0
                ) then
                  -- LetAssoc
                  let v12 =
                    let v12 = ((Foreign.Object.Unsafe.unsafeIndex o1@v0) k@v11);
                    -- Inline v13
                    let v13 = (# f1@v3 k@v11 i@v9 v12 a@v10 #);
                    v13;
                  -- Inline v13
                  let v13 =
                    letEffect v2@v13 = v12;
                    -- Inline v14
                    let v14 =
                      letEffect v14 =
                        (-- Stop
                        Foreign.Object.ST.poke
                          k@v11
                          v2@v13
                          o2@v6
                        );
                      (# effectPure o2@v6 #);
                    (# effectDefer
                      letEffect a'@v15 = v14;
                      (# effectPure <PrimUndefined> #)
                    #);
                  v13
                else
                  -- Inline v12
                  let v12 = (# f3@v5 k@v11 i@v9 a@v10 #);
                  -- Inline v13
                  let v13 =
                    letEffect v2@v13 = v12;
                    -- Inline v14
                    let v14 =
                      letEffect v14 =
                        (-- Stop
                        Foreign.Object.ST.poke
                          k@v11
                          v2@v13
                          o2@v6
                        );
                      (# effectPure o2@v6 #);
                    (# effectDefer
                      letEffect a'@v15 = v14;
                      (# effectPure <PrimUndefined> #)
                    #);
                  v13
              #)
            )
          )
        #);
      v8;
    -- Inline v8
    let v8 =
      letEffect $__unused@v8 = v7;
      -- Inline v9
      let v9 = (# effectPure o2@v6 #);
      -- Inline v10
      let v10 =
        letEffect o3@v10 = v9;
        -- LetAssoc
        let v11 =
          let v11 = (Foreign.Object.keys o1@v0);
          -- Inline v12
          let v12 =
            (# effectDefer
              (-- Stop
              Effect.foreachE
                v11
                (\k@v12 ->
                  (# effectDefer
                    if (-- Stop
                    Foreign.Object.member
                      k@v12
                      o3@v10
                    ) then
                      -- Inline v13
                      let v13 = <PrimUndefined>;
                      -- Inline v14
                      let v14 = (# effectPure v13 #);
                      v14
                    else
                      -- LetAssoc
                      let v13 =
                        let v13 =
                          ((Foreign.Object.Unsafe.unsafeIndex o1@v0) k@v12);
                        -- Inline v14
                        let v14 = (# f2@v4 k@v12 v13 #);
                        v14;
                      (# effectDefer
                        letEffect a'@v14 = v13;
                        (# effectPure <PrimUndefined> #)
                      #)
                  #)
                )
              )
            #);
          v12;
        -- Inline v12
        let v12 =
          letEffect $__unused@v12 = v11;
          (# effectPure o3@v10 #);
        v12;
      v10;
    v8
  #)
---------------
Snapshot.HalogenVDomST01.diffWithKeyAndIxE (Step 2)
  (# \o1@v0 as@v1 fk@v2 f1@v3 f2@v4 f3@v5 ->
    letEffect o2@v6 = Foreign.Object.ST.new;
    -- LetAssoc
    let v7 =
      let v7 = (arrayLength as@v1);
      -- Inline v8
      let v8 =
        (# effectDefer
          (-- Stop
          Effect.forE
            0
            v7
            (\i@v8 ->
              (# effectDefer
                let a@v9 = ((arrayIndex as@v1) i@v8);
                let k@v10 = (fk@v2 a@v9);
                if (-- Stop
                Foreign.Object.member
                  k@v10
                  o1@v0
                ) then
                  let v11 = ((Foreign.Object.Unsafe.unsafeIndex o1@v0) k@v10);
                  -- Inline v12
                  let v12 = (# f1@v3 k@v10 i@v8 v11 a@v9 #);
                  letEffect v2@v13 = v12;
                  -- EffectBindAssoc
                  let a'@v14 =
                    letEffect v14 =
                      (-- Stop
                      Foreign.Object.ST.poke
                        k@v10
                        v2@v13
                        o2@v6
                      );
                    (# effectPure o2@v6 #);
                  (# effectPure <PrimUndefined> #)
                else
                  letEffect v2@v11 = (# f3@v5 k@v10 i@v8 a@v9 #);
                  -- EffectBindAssoc
                  let a'@v12 =
                    letEffect v12 =
                      (-- Stop
                      Foreign.Object.ST.poke
                        k@v10
                        v2@v11
                        o2@v6
                      );
                    (# effectPure o2@v6 #);
                  (# effectPure <PrimUndefined> #)
              #)
            )
          )
        #);
      v8;
    letEffect $__unused@v8 = v7;
    -- Inline o3@v9
    let o3@v9 = o2@v6;
    let v10 = (Foreign.Object.keys o1@v0);
    -- Inline v11
    let v11 =
      (# effectDefer
        (-- Stop
        Effect.foreachE
          v10
          (\k@v11 ->
            (# effectDefer
              if (-- Stop
              Foreign.Object.member
                k@v11
                o3@v9
              ) then
                (# effectPure <PrimUndefined> #)
              else
                let v12 = ((Foreign.Object.Unsafe.unsafeIndex o1@v0) k@v11);
                -- Inline v13
                let v13 = (# f2@v4 k@v11 v12 #);
                (# effectDefer
                  letEffect a'@v14 = v13;
                  (# effectPure <PrimUndefined> #)
                #)
            #)
          )
        )
      #);
    letEffect $__unused@v12 = v11;
    (# effectPure o3@v9 #)
  #)
---------------
Snapshot.HalogenVDomST01.diffWithKeyAndIxE (Step 3)
  (# \o1@v0 as@v1 fk@v2 f1@v3 f2@v4 f3@v5 ->
    letEffect o2@v6 = Foreign.Object.ST.new;
    let v7 = (arrayLength as@v1);
    -- Inline v8
    let v8 =
      (# effectDefer
        (-- Stop
        Effect.forE
          0
          v7
          (\i@v8 ->
            (# effectDefer
              let a@v9 = ((arrayIndex as@v1) i@v8);
              let k@v10 = (fk@v2 a@v9);
              if (-- Stop
              Foreign.Object.member
                k@v10
                o1@v0
              ) then
                -- Inline v11
                let v11 = ((Foreign.Object.Unsafe.unsafeIndex o1@v0) k@v10);
                letEffect v2@v12 = (# f1@v3 k@v10 i@v8 v11 a@v9 #);
                letEffect v13 =
                  (-- Stop
                  Foreign.Object.ST.poke
                    k@v10
                    v2@v12
                    o2@v6
                  );
                -- Inline a'@v14
                let a'@v14 = o2@v6;
                (# effectPure <PrimUndefined> #)
              else
                letEffect v2@v11 = (# f3@v5 k@v10 i@v8 a@v9 #);
                letEffect v12 =
                  (-- Stop
                  Foreign.Object.ST.poke
                    k@v10
                    v2@v11
                    o2@v6
                  );
                -- Inline a'@v13
                let a'@v13 = o2@v6;
                (# effectPure <PrimUndefined> #)
            #)
          )
        )
      #);
    letEffect $__unused@v9 = v8;
    -- Inline v10
    let v10 = (Foreign.Object.keys o1@v0);
    letEffect $__unused@v11 =
      (-- Stop
      Effect.foreachE
        v10
        (\k@v11 ->
          (# effectDefer
            if (-- Stop
            Foreign.Object.member
              k@v11
              o2@v6
            ) then
              (# effectPure <PrimUndefined> #)
            else
              -- Inline v12
              let v12 = ((Foreign.Object.Unsafe.unsafeIndex o1@v0) k@v11);
              (# effectDefer
                letEffect a'@v13 = (# f2@v4 k@v11 v12 #);
                (# effectPure <PrimUndefined> #)
              #)
          #)
        )
      );
    (# effectPure o2@v6 #)
  #)
---------------
Snapshot.HalogenVDomST01.diffWithKeyAndIxE (Step 4)
  (# \o1@v0 as@v1 fk@v2 f1@v3 f2@v4 f3@v5 ->
    letEffect o2@v6 = Foreign.Object.ST.new;
    -- Inline v7
    let v7 = (arrayLength as@v1);
    letEffect $__unused@v8 =
      (-- Stop
      Effect.forE
        0
        v7
        (\i@v8 ->
          (# effectDefer
            let a@v9 = ((arrayIndex as@v1) i@v8);
            let k@v10 = (fk@v2 a@v9);
            if (-- Stop
            Foreign.Object.member
              k@v10
              o1@v0
            ) then
              letEffect v2@v11 =
                (# f1@v3
                  k@v10
                  i@v8
                  ((Foreign.Object.Unsafe.unsafeIndex o1@v0) k@v10)
                  a@v9
                #);
              letEffect v12 =
                (-- Stop
                Foreign.Object.ST.poke
                  k@v10
                  v2@v11
                  o2@v6
                );
              (# effectPure <PrimUndefined> #)
            else
              letEffect v2@v11 = (# f3@v5 k@v10 i@v8 a@v9 #);
              letEffect v12 =
                (-- Stop
                Foreign.Object.ST.poke
                  k@v10
                  v2@v11
                  o2@v6
                );
              (# effectPure <PrimUndefined> #)
          #)
        )
      );
    letEffect $__unused@v9 =
      (-- Stop
      Effect.foreachE
        (Foreign.Object.keys o1@v0)
        (\k@v9 ->
          (# effectDefer
            if (-- Stop
            Foreign.Object.member
              k@v9
              o2@v6
            ) then
              (# effectPure <PrimUndefined> #)
            else
              (# effectDefer
                letEffect a'@v10 =
                  (# f2@v4
                    k@v9
                    ((Foreign.Object.Unsafe.unsafeIndex o1@v0) k@v9)
                  #);
                (# effectPure <PrimUndefined> #)
              #)
          #)
        )
      );
    (# effectPure o2@v6 #)
  #)
---------------
Snapshot.HalogenVDomST01.diffWithKeyAndIxE (Step 5; Final)
  (# \o1@v0 as@v1 fk@v2 f1@v3 f2@v4 f3@v5 ->
    letEffect o2@v6 = Foreign.Object.ST.new;
    letEffect $__unused@v7 =
      (-- Stop
      Effect.forE
        0
        (arrayLength as@v1)
        (\i@v7 ->
          (# effectDefer
            let a@v8 = ((arrayIndex as@v1) i@v7);
            let k@v9 = (fk@v2 a@v8);
            if (-- Stop
            Foreign.Object.member
              k@v9
              o1@v0
            ) then
              letEffect v2@v10 =
                (# f1@v3
                  k@v9
                  i@v7
                  ((Foreign.Object.Unsafe.unsafeIndex o1@v0) k@v9)
                  a@v8
                #);
              letEffect v11 =
                (-- Stop
                Foreign.Object.ST.poke
                  k@v9
                  v2@v10
                  o2@v6
                );
              (# effectPure <PrimUndefined> #)
            else
              letEffect v2@v10 = (# f3@v5 k@v9 i@v7 a@v8 #);
              letEffect v11 =
                (-- Stop
                Foreign.Object.ST.poke
                  k@v9
                  v2@v10
                  o2@v6
                );
              (# effectPure <PrimUndefined> #)
          #)
        )
      );
    letEffect $__unused@v8 =
      (-- Stop
      Effect.foreachE
        (Foreign.Object.keys o1@v0)
        (\k@v8 ->
          (# effectDefer
            if (-- Stop
            Foreign.Object.member
              k@v8
              o2@v6
            ) then
              (# effectPure <PrimUndefined> #)
            else
              (# effectDefer
                letEffect a'@v9 =
                  (# f2@v4
                    k@v8
                    ((Foreign.Object.Unsafe.unsafeIndex o1@v0) k@v8)
                  #);
                (# effectPure <PrimUndefined> #)
              #)
          #)
        )
      );
    (# effectPure o2@v6 #)
  #)

===============

Snapshot.HalogenVDomST01.discard (Step 0; Original)
  ((Control.Bind.discard Control.Bind.discardUnit) Effect.bindEffect)
---------------
Snapshot.HalogenVDomST01.discard (Step 1; Final)
  Effect.bindE

===============

Snapshot.HalogenVDomST01.lessThan (Step 0; Original)
  (Data.Ord.lessThan Data.Ord.ordInt)
---------------
Snapshot.HalogenVDomST01.lessThan (Step 1; Final)
  (\a1@v0 -> \a2@v1 -> ((lt a1@v0) a2@v1))

===============

Snapshot.HalogenVDomST01.liftST (Step 0; Original)
  (Control.Monad.ST.Class.liftST Control.Monad.ST.Class.monadSTEffect)
---------------
Snapshot.HalogenVDomST01.liftST (Step 1; Final)
  Unsafe.Coerce.unsafeCoerce

===============

Snapshot.HalogenVDomST01.pure (Step 0; Original)
  (Control.Applicative.pure Effect.applicativeEffect)
---------------
Snapshot.HalogenVDomST01.pure (Step 1; Final)
  Effect.pureE

===============

Snapshot.HalogenVDomST01.unsafeIndex (Step 0; Original)
  (Data.Array.unsafeIndex <PrimUndefined>)
---------------
Snapshot.HalogenVDomST01.unsafeIndex (Step 1)
  -- Inline v0
  let v0 = <PrimUndefined>;
  Data.Array.unsafeIndexImpl
---------------
Snapshot.HalogenVDomST01.unsafeIndex (Step 2; Final)
  Data.Array.unsafeIndexImpl

===============

Snapshot.HalogenVDomST01.void (Step 0; Original)
  (Data.Functor.void Effect.functorEffect)
---------------
Snapshot.HalogenVDomST01.void (Step 1)
  -- Inline v0
  let v0 = (\v@v0 -> <PrimUndefined>);
  -- Inline v1
  let v1 =
    -- Inline v1
    let v1 =
      -- Inline v1
      let v1 =
        (\a@v1 ->
          (# effectDefer
            letEffect a'@v2 = a@v1;
            (# effectPure (v0 a'@v2) #)
          #)
        );
      v1;
    v1;
  v1
---------------
Snapshot.HalogenVDomST01.void (Step 2; Final)
  (\a@v0 ->
    (# effectDefer
      letEffect a'@v1 = a@v0;
      (# effectPure <PrimUndefined> #)
    #)
  )
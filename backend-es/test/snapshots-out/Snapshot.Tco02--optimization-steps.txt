Snapshot.Tco02.eq (Step 0; Original)
  (Data.Eq.eq Data.Eq.eqInt)
---------------
Snapshot.Tco02.eq (Step 1; Final)
  Data.Eq.eqIntImpl

===============

Snapshot.Tco02.sub (Step 0; Original)
  (Data.Ring.sub Data.Ring.ringInt)
---------------
Snapshot.Tco02.sub (Step 1; Final)
  Data.Ring.intSub

===============

Snapshot.Tco02.test (Step 0; Original)
  (\n@v0 ->
    -- Uncurry k@v1
    let k@v1 =
      (\wat@v1 ->
        -- Inline j@v2
        let j@v2 = (\i@v2 -> \v@v3 -> (Snapshot.Tco02.test i@v2));
        -- Inline v3
        let v3 = wat@v1;
        -- Inline v4
        let v4 = (\-> ((j@v2 ((Snapshot.Tco02.sub n@v0) 1)) Data.Unit.unit));
        -- Inline v5
        let v5 = (\-> n@v0);
        if ((eq v3) true) then (v4!) else (v5!)
      );
    -- Inline v2
    let v2 = ((Snapshot.Tco02.eq n@v0) 0);
    -- Inline v3
    let v3 = (\-> (k@v1 false));
    -- Inline v4
    let v4 = (\-> (k@v1 true));
    if ((eq v2) true) then (v3!) else (v4!)
  )
---------------
Snapshot.Tco02.test (Step 1)
  (\n@v0 ->
    -- Inline k@v1
    let k@v1 =
      (\wat@v1 ->
        if wat@v1 then
          -- Inline v2
          let v2 =
            -- Inline v2
            let v2 = 1;
            ((subtract n@v0) v2);
          -- Inline v3
          let v3 = <PrimUndefined>;
          (Snapshot.Tco02.test v2)
        else
          n@v0
      );
    if -- Inline v2
    let v2 = 0;
    ((eq n@v0) v2) then
      -- Inline v2
      let v2 = false;
      (k@v1 v2)
    else
      -- Inline v2
      let v2 = true;
      (k@v1 v2)
  )
---------------
Snapshot.Tco02.test (Step 2)
  (\n@v0 ->
    if ((eq n@v0) 0) then
      -- Inline v1
      let v1 = false;
      if v1 then (Snapshot.Tco02.test ((subtract n@v0) 1)) else n@v0
    else
      -- Inline v1
      let v1 = true;
      if v1 then (Snapshot.Tco02.test ((subtract n@v0) 1)) else n@v0
  )
---------------
Snapshot.Tco02.test (Step 3; Final)
  (\n@v0 ->
    if ((eq n@v0) 0) then n@v0 else (Snapshot.Tco02.test ((subtract n@v0) 1))
  )
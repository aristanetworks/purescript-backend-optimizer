Snapshot.DefaultRulesEq01.eq (Step 0; Original)
  (Data.Eq.eq
    (Data.Eq.eqRec
      <PrimUndefined>
      (Data.Eq.eqRowCons
        (Data.Eq.eqRowCons
          (Data.Eq.eqRowCons
            Data.Eq.eqRowNil
            <PrimUndefined>
            { reflectSymbol: (\$__unused@v0 -> "foo") }
            Data.Eq.eqInt
          )
          <PrimUndefined>
          { reflectSymbol: (\$__unused@v0 -> "baz") }
          Data.Eq.eqBoolean
        )
        <PrimUndefined>
        { reflectSymbol: (\$__unused@v0 -> "bar") }
        Data.Eq.eqString
      )
    )
  )
---------------
Snapshot.DefaultRulesEq01.eq (Step 1)
  -- Inline v0
  let v0 =
    -- Inline v0
    let v0 = <PrimUndefined>;
    -- LetAssoc
    let v1 =
      let v1 =
        let v1 =
          let v1 =
            -- Inline v1
            let v1 = <PrimUndefined>;
            -- Inline v2
            let v2 =
              -- Inline v2
              let v2 = { reflectSymbol: (\$__unused@v2 -> "foo") };
              { eqRecord:
                  (\v@v3 -> \ra@v4 -> \rb@v5 ->
                    let get@v6 =
                      (Record.Unsafe.unsafeGet
                        (v2.reflectSymbol Type.Proxy.Proxy)
                      );
                    (booleanAnd
                      (let v7 = (get@v6 ra@v4);
                      -- Inline v8
                      let v8 = (\v8 -> ((eq v7) v8));
                      (v8 (get@v6 rb@v5)))
                      (-- Inline v7
                      let v7 = Type.Proxy.Proxy;
                      -- Inline v8
                      let v8 = (\v1@v8 -> \v2@v9 -> true);
                      ((v8 ra@v4) rb@v5))
                    )
                  )
              };
            v2;
          -- Inline v2
          let v2 =
            -- Inline v2
            let v2 = <PrimUndefined>;
            -- Inline v3
            let v3 = { reflectSymbol: (\$__unused@v3 -> "baz") };
            { eqRecord:
                (\v@v4 -> \ra@v5 -> \rb@v6 ->
                  let get@v7 =
                    (Record.Unsafe.unsafeGet
                      (v3.reflectSymbol Type.Proxy.Proxy)
                    );
                  (booleanAnd
                    (let v8 = (get@v7 ra@v5);
                    -- Inline v9
                    let v9 = (\v9 -> ((eq v8) v9));
                    (v9 (get@v7 rb@v6)))
                    (((v1.eqRecord Type.Proxy.Proxy) ra@v5) rb@v6)
                  )
                )
            };
          v2;
        -- Inline v2
        let v2 =
          -- Inline v2
          let v2 = <PrimUndefined>;
          -- Inline v3
          let v3 = { reflectSymbol: (\$__unused@v3 -> "bar") };
          { eqRecord:
              (\v@v4 -> \ra@v5 -> \rb@v6 ->
                let get@v7 =
                  (Record.Unsafe.unsafeGet (v3.reflectSymbol Type.Proxy.Proxy));
                (booleanAnd
                  (let v8 = (get@v7 ra@v5);
                  -- Inline v9
                  let v9 = (\v9 -> ((eq v8) v9));
                  (v9 (get@v7 rb@v6)))
                  (((v1.eqRecord Type.Proxy.Proxy) ra@v5) rb@v6)
                )
              )
          };
        v2;
      { eq: (v1.eqRecord Type.Proxy.Proxy) };
    v1;
  -- Inline v1
  let v1 = v0.eq;
  v1
---------------
Snapshot.DefaultRulesEq01.eq (Step 2)
  -- UnpackOp v0 Record ["eqRecord"]
  let v0 =
    { eqRecord:
        (\v@v0 -> \ra@v1 -> \rb@v2 ->
          let get@v3 =
            (Record.Unsafe.unsafeGet
              -- Inline v3
              let v3 = Type.Proxy.Proxy;
              "foo"
            );
          -- Inline v4
          let v4 = (get@v3 ra@v1);
          -- Inline v5
          let v5 = (get@v3 rb@v2);
          ((eq v4) v5)
        )
    };
  -- Inline v1
  let v1 =
    -- UnpackOp v1 Record ["eqRecord"]
    let v1 =
      { eqRecord:
          (\v@v1 -> \ra@v2 -> \rb@v3 ->
            let get@v4 =
              (Record.Unsafe.unsafeGet
                -- Inline v4
                let v4 = Type.Proxy.Proxy;
                "baz"
              );
            (booleanAnd
              (-- Inline v5
              let v5 = (get@v4 ra@v2);
              -- Inline v6
              let v6 = (get@v4 rb@v3);
              ((eq v5) v6))
              (((v0.eqRecord Type.Proxy.Proxy) ra@v2) rb@v3)
            )
          )
      };
    -- Inline v2
    let v2 =
      { eqRecord:
          (\v@v2 -> \ra@v3 -> \rb@v4 ->
            let get@v5 =
              (Record.Unsafe.unsafeGet
                -- Inline v5
                let v5 = Type.Proxy.Proxy;
                "bar"
              );
            (booleanAnd
              (-- Inline v6
              let v6 = (get@v5 ra@v3);
              -- Inline v7
              let v7 = (get@v5 rb@v4);
              ((eq v6) v7))
              (((v1.eqRecord Type.Proxy.Proxy) ra@v3) rb@v4)
            )
          )
      };
    -- Inline v3
    let v3 = { eq: (v2.eqRecord Type.Proxy.Proxy) };
    v3;
  v1.eq
---------------
Snapshot.DefaultRulesEq01.eq (Step 3)
  -- Inline v0
  let v0 =
    (\v@v0 -> \ra@v1 -> \rb@v2 ->
      -- Inline get@v3
      let get@v3 = (\v3 -> v3.foo);
      ((eq (get@v3 ra@v1)) (get@v3 rb@v2))
    );
  -- Inline v1
  let v1 =
    (\v@v1 -> \ra@v2 -> \rb@v3 ->
      -- Inline get@v4
      let get@v4 = (\v4 -> v4.baz);
      (booleanAnd
        ((eq (get@v4 ra@v2)) (get@v4 rb@v3))
        (((v0 Type.Proxy.Proxy) ra@v2) rb@v3)
      )
    );
  -- Inline v2
  let v2 =
    { eq:
        -- Inline v2
        let v2 = Type.Proxy.Proxy;
        (\ra@v3 -> \rb@v4 ->
          -- Inline get@v5
          let get@v5 = (\v5 -> v5.bar);
          (booleanAnd
            ((eq (get@v5 ra@v3)) (get@v5 rb@v4))
            (((v1 Type.Proxy.Proxy) ra@v3) rb@v4)
          )
        )
    };
  v2.eq
---------------
Snapshot.DefaultRulesEq01.eq (Step 4)
  (\ra@v0 -> \rb@v1 ->
    (booleanAnd
      ((eq ra@v0.bar) rb@v1.bar)
      (-- Inline v2
      let v2 = Type.Proxy.Proxy;
      (booleanAnd
        ((eq ra@v0.baz) rb@v1.baz)
        (-- Inline v3
        let v3 = Type.Proxy.Proxy;
        ((eq ra@v0.foo) rb@v1.foo))
      ))
    )
  )
---------------
Snapshot.DefaultRulesEq01.eq (Step 5; Final)
  (\ra@v0 -> \rb@v1 ->
    (booleanAnd
      ((eq ra@v0.bar) rb@v1.bar)
      ((booleanAnd ((eq ra@v0.baz) rb@v1.baz)) ((eq ra@v0.foo) rb@v1.foo))
    )
  )

===============

Snapshot.DefaultRulesEq01.test1 (Step 0; Original)
  Snapshot.DefaultRulesEq01.eq
---------------
Snapshot.DefaultRulesEq01.test1 (Step 1; Final)
  Snapshot.DefaultRulesEq01.eq

===============

Snapshot.DefaultRulesEq01.test10 (Step 0; Original)
  (\x@v0 ->
    (Snapshot.DefaultRulesEq01.eq
      { foo: 42, bar: (x@v0 Data.Unit.unit), baz: true }
    )
  )
---------------
Snapshot.DefaultRulesEq01.test10 (Step 1)
  (\x@v0 ->
    -- UnpackOp v1 Record ["foo","bar","baz"]
    let v1 = { foo: 42, bar: (x@v0 <PrimUndefined>), baz: true };
    -- Inline v2
    let v2 =
      (\rb@v2 ->
        (booleanAnd
          ((eq v1.bar) rb@v2.bar)
          ((booleanAnd ((eq v1.baz) rb@v2.baz)) ((eq v1.foo) rb@v2.foo))
        )
      );
    v2
  )
---------------
Snapshot.DefaultRulesEq01.test10 (Step 2)
  (\x@v0 ->
    -- Inline v1
    let v1 = 42;
    let v2 = (x@v0 <PrimUndefined>);
    -- Inline v3
    let v3 = true;
    (\rb@v4 ->
      (booleanAnd
        ((eq v2) rb@v4.bar)
        ((booleanAnd ((eq v3) rb@v4.baz)) ((eq v1) rb@v4.foo))
      )
    )
  )
---------------
Snapshot.DefaultRulesEq01.test10 (Step 3; Final)
  (\x@v0 ->
    let v1 = (x@v0 <PrimUndefined>);
    (\rb@v2 ->
      (booleanAnd
        ((eq v1) rb@v2.bar)
        ((booleanAnd rb@v2.baz) ((eq 42) rb@v2.foo))
      )
    )
  )

===============

Snapshot.DefaultRulesEq01.test2 (Step 0; Original)
  (\a@v0 -> \b@v1 -> ((Snapshot.DefaultRulesEq01.eq a@v0) b@v1))
---------------
Snapshot.DefaultRulesEq01.test2 (Step 1; Final)
  (\a@v0 -> \b@v1 ->
    (booleanAnd
      ((eq a@v0.bar) b@v1.bar)
      ((booleanAnd ((eq a@v0.baz) b@v1.baz)) ((eq a@v0.foo) b@v1.foo))
    )
  )

===============

Snapshot.DefaultRulesEq01.test3 (Step 0; Original)
  (Snapshot.DefaultRulesEq01.eq { foo: 42, bar: "hello", baz: false })
---------------
Snapshot.DefaultRulesEq01.test3 (Step 1)
  -- UnpackOp v0 Record ["foo","bar","baz"]
  let v0 = { foo: 42, bar: "hello", baz: false };
  -- Inline v1
  let v1 =
    (\rb@v1 ->
      (booleanAnd
        ((eq v0.bar) rb@v1.bar)
        ((booleanAnd ((eq v0.baz) rb@v1.baz)) ((eq v0.foo) rb@v1.foo))
      )
    );
  v1
---------------
Snapshot.DefaultRulesEq01.test3 (Step 2)
  -- Inline v0
  let v0 = 42;
  -- Inline v1
  let v1 = "hello";
  -- Inline v2
  let v2 = false;
  (\rb@v3 ->
    (booleanAnd
      ((eq v1) rb@v3.bar)
      ((booleanAnd ((eq v2) rb@v3.baz)) ((eq v0) rb@v3.foo))
    )
  )
---------------
Snapshot.DefaultRulesEq01.test3 (Step 3; Final)
  (\rb@v0 ->
    (booleanAnd
      ((eq "hello") rb@v0.bar)
      ((booleanAnd (not rb@v0.baz)) ((eq 42) rb@v0.foo))
    )
  )

===============

Snapshot.DefaultRulesEq01.test4 (Step 0; Original)
  (\a@v0 ->
    ((Snapshot.DefaultRulesEq01.eq { foo: 42, bar: "hello", baz: false }) a@v0)
  )
---------------
Snapshot.DefaultRulesEq01.test4 (Step 1)
  (\a@v0 ->
    -- UnpackOp v1 Record ["foo","bar","baz"]
    let v1 = { foo: 42, bar: "hello", baz: false };
    -- Inline v2
    let v2 =
      (\rb@v2 ->
        (booleanAnd
          ((eq v1.bar) rb@v2.bar)
          ((booleanAnd ((eq v1.baz) rb@v2.baz)) ((eq v1.foo) rb@v2.foo))
        )
      );
    (v2 a@v0)
  )
---------------
Snapshot.DefaultRulesEq01.test4 (Step 2)
  (\a@v0 ->
    -- Inline v1
    let v1 = 42;
    -- Inline v2
    let v2 = "hello";
    -- Inline v3
    let v3 = false;
    (booleanAnd
      ((eq v2) a@v0.bar)
      ((booleanAnd ((eq v3) a@v0.baz)) ((eq v1) a@v0.foo))
    )
  )
---------------
Snapshot.DefaultRulesEq01.test4 (Step 3; Final)
  (\a@v0 ->
    (booleanAnd
      ((eq "hello") a@v0.bar)
      ((booleanAnd (not a@v0.baz)) ((eq 42) a@v0.foo))
    )
  )

===============

Snapshot.DefaultRulesEq01.test5 (Step 0; Original)
  (\a@v0 ->
    ((Snapshot.DefaultRulesEq01.eq a@v0) { foo: 42, bar: "hello", baz: false })
  )
---------------
Snapshot.DefaultRulesEq01.test5 (Step 1)
  (\a@v0 ->
    -- UnpackOp v1 Record ["foo","bar","baz"]
    let v1 = { foo: 42, bar: "hello", baz: false };
    (booleanAnd
      ((eq a@v0.bar) v1.bar)
      ((booleanAnd ((eq a@v0.baz) v1.baz)) ((eq a@v0.foo) v1.foo))
    )
  )
---------------
Snapshot.DefaultRulesEq01.test5 (Step 2)
  (\a@v0 ->
    -- Inline v1
    let v1 = 42;
    -- Inline v2
    let v2 = "hello";
    -- Inline v3
    let v3 = false;
    (booleanAnd
      ((eq a@v0.bar) v2)
      ((booleanAnd ((eq a@v0.baz) v3)) ((eq a@v0.foo) v1))
    )
  )
---------------
Snapshot.DefaultRulesEq01.test5 (Step 3; Final)
  (\a@v0 ->
    (booleanAnd
      ((eq a@v0.bar) "hello")
      ((booleanAnd (not a@v0.baz)) ((eq a@v0.foo) 42))
    )
  )

===============

Snapshot.DefaultRulesEq01.test6 (Step 0; Original)
  (Snapshot.DefaultRulesEq01.eq
    { foo: 42, bar: "hello", baz: false }
    { foo: 42, bar: "hello", baz: false }
  )
---------------
Snapshot.DefaultRulesEq01.test6 (Step 1)
  -- UnpackOp v0 Record ["foo","bar","baz"]
  let v0 = { foo: 42, bar: "hello", baz: false };
  -- Inline v1
  let v1 =
    (\rb@v1 ->
      (booleanAnd
        ((eq v0.bar) rb@v1.bar)
        ((booleanAnd ((eq v0.baz) rb@v1.baz)) ((eq v0.foo) rb@v1.foo))
      )
    );
  (v1 { foo: 42, bar: "hello", baz: false })
---------------
Snapshot.DefaultRulesEq01.test6 (Step 2)
  -- Inline v0
  let v0 = 42;
  -- Inline v1
  let v1 = "hello";
  -- Inline v2
  let v2 = false;
  -- UnpackOp v3 Record ["foo","bar","baz"]
  let v3 = { foo: 42, bar: "hello", baz: false };
  (booleanAnd
    ((eq v1) v3.bar)
    ((booleanAnd ((eq v2) v3.baz)) ((eq v0) v3.foo))
  )
---------------
Snapshot.DefaultRulesEq01.test6 (Step 3)
  -- Inline v0
  let v0 = 42;
  -- Inline v1
  let v1 = "hello";
  -- Inline v2
  let v2 = false;
  ((booleanAnd ((eq "hello") v1)) ((booleanAnd (not v2)) ((eq 42) v0)))
---------------
Snapshot.DefaultRulesEq01.test6 (Step 4; Final)
  true

===============

Snapshot.DefaultRulesEq01.test7 (Step 0; Original)
  (Snapshot.DefaultRulesEq01.eq
    { foo: 42, bar: "hello", baz: false }
    { foo: 43, bar: "hello", baz: false }
  )
---------------
Snapshot.DefaultRulesEq01.test7 (Step 1)
  -- UnpackOp v0 Record ["foo","bar","baz"]
  let v0 = { foo: 42, bar: "hello", baz: false };
  -- Inline v1
  let v1 =
    (\rb@v1 ->
      (booleanAnd
        ((eq v0.bar) rb@v1.bar)
        ((booleanAnd ((eq v0.baz) rb@v1.baz)) ((eq v0.foo) rb@v1.foo))
      )
    );
  (v1 { foo: 43, bar: "hello", baz: false })
---------------
Snapshot.DefaultRulesEq01.test7 (Step 2)
  -- Inline v0
  let v0 = 42;
  -- Inline v1
  let v1 = "hello";
  -- Inline v2
  let v2 = false;
  -- UnpackOp v3 Record ["foo","bar","baz"]
  let v3 = { foo: 43, bar: "hello", baz: false };
  (booleanAnd
    ((eq v1) v3.bar)
    ((booleanAnd ((eq v2) v3.baz)) ((eq v0) v3.foo))
  )
---------------
Snapshot.DefaultRulesEq01.test7 (Step 3)
  -- Inline v0
  let v0 = 43;
  -- Inline v1
  let v1 = "hello";
  -- Inline v2
  let v2 = false;
  ((booleanAnd ((eq "hello") v1)) ((booleanAnd (not v2)) ((eq 42) v0)))
---------------
Snapshot.DefaultRulesEq01.test7 (Step 4; Final)
  false

===============

Snapshot.DefaultRulesEq01.test8 (Step 0; Original)
  (\x@v0 ->
    (Snapshot.DefaultRulesEq01.eq
      { foo: 42, bar: "hello", baz: false }
      { foo: 43, bar: (x@v0 Data.Unit.unit), baz: false }
    )
  )
---------------
Snapshot.DefaultRulesEq01.test8 (Step 1)
  (\x@v0 ->
    -- UnpackOp v1 Record ["foo","bar","baz"]
    let v1 = { foo: 42, bar: "hello", baz: false };
    -- Inline v2
    let v2 =
      (\rb@v2 ->
        (booleanAnd
          ((eq v1.bar) rb@v2.bar)
          ((booleanAnd ((eq v1.baz) rb@v2.baz)) ((eq v1.foo) rb@v2.foo))
        )
      );
    (v2 { foo: 43, bar: (x@v0 <PrimUndefined>), baz: false })
  )
---------------
Snapshot.DefaultRulesEq01.test8 (Step 2)
  (\x@v0 ->
    -- Inline v1
    let v1 = 42;
    -- Inline v2
    let v2 = "hello";
    -- Inline v3
    let v3 = false;
    -- UnpackOp v4 Record ["foo","bar","baz"]
    let v4 = { foo: 43, bar: (x@v0 <PrimUndefined>), baz: false };
    (booleanAnd
      ((eq v2) v4.bar)
      ((booleanAnd ((eq v3) v4.baz)) ((eq v1) v4.foo))
    )
  )
---------------
Snapshot.DefaultRulesEq01.test8 (Step 3)
  (\x@v0 ->
    -- Inline v1
    let v1 = 43;
    -- Inline v2
    let v2 = (x@v0 <PrimUndefined>);
    -- Inline v3
    let v3 = false;
    ((booleanAnd ((eq "hello") v2)) ((booleanAnd (not v3)) ((eq 42) v1)))
  )
---------------
Snapshot.DefaultRulesEq01.test8 (Step 4; Final)
  (\x@v0 -> false)

===============

Snapshot.DefaultRulesEq01.test9 (Step 0; Original)
  (\x@v0 ->
    (Snapshot.DefaultRulesEq01.eq
      { foo: 42, bar: "hello", baz: true }
      { foo: 42, bar: (x@v0 Data.Unit.unit), baz: true }
    )
  )
---------------
Snapshot.DefaultRulesEq01.test9 (Step 1)
  (\x@v0 ->
    -- UnpackOp v1 Record ["foo","bar","baz"]
    let v1 = { foo: 42, bar: "hello", baz: true };
    -- Inline v2
    let v2 =
      (\rb@v2 ->
        (booleanAnd
          ((eq v1.bar) rb@v2.bar)
          ((booleanAnd ((eq v1.baz) rb@v2.baz)) ((eq v1.foo) rb@v2.foo))
        )
      );
    (v2 { foo: 42, bar: (x@v0 <PrimUndefined>), baz: true })
  )
---------------
Snapshot.DefaultRulesEq01.test9 (Step 2)
  (\x@v0 ->
    -- Inline v1
    let v1 = 42;
    -- Inline v2
    let v2 = "hello";
    -- Inline v3
    let v3 = true;
    -- UnpackOp v4 Record ["foo","bar","baz"]
    let v4 = { foo: 42, bar: (x@v0 <PrimUndefined>), baz: true };
    (booleanAnd
      ((eq v2) v4.bar)
      ((booleanAnd ((eq v3) v4.baz)) ((eq v1) v4.foo))
    )
  )
---------------
Snapshot.DefaultRulesEq01.test9 (Step 3)
  (\x@v0 ->
    -- Inline v1
    let v1 = 42;
    -- Inline v2
    let v2 = (x@v0 <PrimUndefined>);
    -- Inline v3
    let v3 = true;
    ((booleanAnd ((eq "hello") v2)) ((booleanAnd v3) ((eq 42) v1)))
  )
---------------
Snapshot.DefaultRulesEq01.test9 (Step 4; Final)
  (\x@v0 -> ((eq "hello") (x@v0 <PrimUndefined>)))
Snapshot.TransformerExceptT01.add (Step 0; Original)
  (Data.Semiring.add Data.Semiring.semiringInt)
---------------
Snapshot.TransformerExceptT01.add (Step 1; Final)
  Data.Semiring.intAdd
===============
Snapshot.TransformerExceptT01.applicativeExceptT (Step 0; Original)
  (Control.Monad.Except.Trans.applicativeExceptT Effect.monadEffect)
---------------
Snapshot.TransformerExceptT01.applicativeExceptT (Step 1; Final)
  (Control.Monad.Except.Trans.applicativeExceptT Effect.monadEffect)
===============
Snapshot.TransformerExceptT01.apply (Step 0; Original)
  (Control.Apply.apply (Control.Monad.Except.Trans.applyExceptT Effect.monadEffect))
---------------
Snapshot.TransformerExceptT01.apply (Step 1)
  {#- Rewrite - Inline -#}
  let v0 =
    (Control.Monad.Except.Trans.applyExceptT Effect.monadEffect);
  {#- Rewrite - Inline -#}
  let v1 =
    (
      v0
    ).apply;
  v1
---------------
Snapshot.TransformerExceptT01.apply (Step 2; Final)
  (
    (Control.Monad.Except.Trans.applyExceptT Effect.monadEffect)
  ).apply
===============
Snapshot.TransformerExceptT01.bind (Step 0; Original)
  (Control.Bind.bind Snapshot.TransformerExceptT01.bindExceptT)
---------------
Snapshot.TransformerExceptT01.bind (Step 1; Final)
  (
    Snapshot.TransformerExceptT01.bindExceptT
  ).bind
===============
Snapshot.TransformerExceptT01.bindExceptT (Step 0; Original)
  (Control.Monad.Except.Trans.bindExceptT Effect.monadEffect)
---------------
Snapshot.TransformerExceptT01.bindExceptT (Step 1; Final)
  (Control.Monad.Except.Trans.bindExceptT Effect.monadEffect)
===============
Snapshot.TransformerExceptT01.discard (Step 0; Original)
  (Control.Bind.discard Control.Bind.discardUnit)
---------------
Snapshot.TransformerExceptT01.discard (Step 1; Final)
  (
    Control.Bind.discardUnit
  ).discard
===============
Snapshot.TransformerExceptT01.discard1 (Step 0; Original)
  (Snapshot.TransformerExceptT01.discard Snapshot.TransformerExceptT01.bindExceptT)
---------------
Snapshot.TransformerExceptT01.discard1 (Step 1; Final)
  (
    Snapshot.TransformerExceptT01.bindExceptT
  ).bind
===============
Snapshot.TransformerExceptT01.lessThan (Step 0; Original)
  (Data.Ord.lessThan Data.Ord.ordInt)
---------------
Snapshot.TransformerExceptT01.lessThan (Step 1; Final)
  (\a1@v0 -> \a2@v1 -> 
    (< a1@v0 a2@v1)
  )
===============
Snapshot.TransformerExceptT01.liftEffect (Step 0; Original)
  (Effect.Class.liftEffect Effect.Class.monadEffectEffect)
---------------
Snapshot.TransformerExceptT01.liftEffect (Step 1; Final)
  (
    Effect.Class.monadEffectEffect
  ).liftEffect
===============
Snapshot.TransformerExceptT01.map (Step 0; Original)
  (Data.Functor.map Effect.functorEffect)
---------------
Snapshot.TransformerExceptT01.map (Step 1; Final)
  (
    Effect.functorEffect
  ).map
===============
Snapshot.TransformerExceptT01.map1 (Step 0; Original)
  (Data.Functor.map (Control.Monad.Except.Trans.functorExceptT Effect.functorEffect))
---------------
Snapshot.TransformerExceptT01.map1 (Step 1)
  {#- Rewrite - Inline -#}
  let v0 =
    { map =
        (\f@v0 -> 
          {#- Rewrite - Inline -#}
          let v1 =
            ((
              Data.Either.functorEither
            ).map f@v0);
          {#- Rewrite - Inline -#}
          let v2 =
            (\a@v2 -> 
              (effectDefer letEffect a'@v3 =
                a@v2;
              (effectPure (v1 a'@v3)))
            );
          v2
        )
    };
  {#- Rewrite - Inline -#}
  let v1 =
    (
      v0
    ).map;
  v1
---------------
Snapshot.TransformerExceptT01.map1 (Step 2; Final)
  (\f@v0 -> \a@v1 -> 
    (effectDefer letEffect a'@v2 =
      a@v1;
    (effectPure if (isTag Data.Either.Left a'@v2) then
      (Data.Either.Left.Either (
        a'@v2
      )#value0)
    else if (isTag Data.Either.Right a'@v2) then
      (Data.Either.Right.Either (f@v0 (
        a'@v2
      )#value0))
    else
      <PatternMatchFailure>))
  )
===============
Snapshot.TransformerExceptT01.map2 (Step 0; Original)
  (Data.Functor.map Data.Either.functorEither)
---------------
Snapshot.TransformerExceptT01.map2 (Step 1; Final)
  (
    Data.Either.functorEither
  ).map
===============
Snapshot.TransformerExceptT01.monadThrowExceptT (Step 0; Original)
  (Control.Monad.Except.Trans.monadThrowExceptT Effect.monadEffect)
---------------
Snapshot.TransformerExceptT01.monadThrowExceptT (Step 1; Final)
  (Control.Monad.Except.Trans.monadThrowExceptT Effect.monadEffect)
===============
Snapshot.TransformerExceptT01.program1 (Step 0; Original)
  (\dictMonadEffect@v0 -> 
    let Monad0@v1 =
      ((
        dictMonadEffect@v0
      ).Monad0 <PrimUndefined>);
    let bindExceptT1@v2 =
      (Control.Monad.Except.Trans.bindExceptT Monad0@v1);
    let discard2@v3 =
      (Snapshot.TransformerExceptT01.discard bindExceptT1@v2);
    let Functor0@v4 =
      ((
        ((
          ((
            Monad0@v1
          ).Bind1 <PrimUndefined>)
        ).Apply0 <PrimUndefined>)
      ).Functor0 <PrimUndefined>);
    let map3@v5 =
      (Data.Functor.map Functor0@v4);
    let liftEffect1@v6 =
      (Effect.Class.liftEffect dictMonadEffect@v0);
    let bind1@v7 =
      (Control.Bind.bind bindExceptT1@v2);
    let map4@v8 =
      (Data.Functor.map (Control.Monad.Except.Trans.functorExceptT Functor0@v4));
    let apply1@v9 =
      (Control.Apply.apply (Control.Monad.Except.Trans.applyExceptT Monad0@v1));
    let applicativeExceptT1@v10 =
      (Control.Monad.Except.Trans.applicativeExceptT Monad0@v1);
    {#- Rewrite - Inline -#}
    let when1@v11 =
      (Control.Applicative.when applicativeExceptT1@v10);
    let throwError1@v12 =
      (Control.Monad.Error.Class.throwError (Control.Monad.Except.Trans.monadThrowExceptT Monad0@v1));
    let pure1@v13 =
      (Control.Applicative.pure applicativeExceptT1@v10);
    ((discard2@v3 ((map3@v5 Data.Either.Right) (liftEffect1@v6 (Effect.Console.log "foo")))) (\$__unused@v14 -> 
      ((bind1@v7 (liftEffect1@v6 ((Snapshot.TransformerExceptT01.map Data.Either.Right) ((Effect.Random.randomInt 1) 10)))) (\i1@v15 -> 
        ((bind1@v7 ((map4@v8 (\v@v16 -> 
          ((Snapshot.TransformerExceptT01.add v@v16) 4)
        )) ((map3@v5 (Snapshot.TransformerExceptT01.map2 (\v@v16 -> 
          ((Snapshot.TransformerExceptT01.add v@v16) 1)
        ))) (liftEffect1@v6 ((Snapshot.TransformerExceptT01.map Data.Either.Right) ((Effect.Random.randomInt 1) 10)))))) (\i2@v16 -> 
          ((bind1@v7 ((apply1@v9 ((map4@v8 Snapshot.TransformerExceptT01.add) (liftEffect1@v6 ((Snapshot.TransformerExceptT01.map Data.Either.Right) ((Effect.Random.randomInt 1) 10))))) (liftEffect1@v6 ((Snapshot.TransformerExceptT01.map Data.Either.Right) ((Effect.Random.randomInt 1) 10))))) (\i3@v17 -> 
            ((discard2@v3 ((when1@v11 ((Snapshot.TransformerExceptT01.lessThan ((Snapshot.TransformerExceptT01.add i1@v15) i2@v16)) i3@v17)) (throwError1@v12 "error"))) (\$__unused@v18 -> 
              (pure1@v13 ((Snapshot.TransformerExceptT01.add ((Snapshot.TransformerExceptT01.add ((Snapshot.TransformerExceptT01.add 1) i1@v15)) i2@v16)) i3@v17))
            ))
          ))
        ))
      ))
    ))
  )
---------------
Snapshot.TransformerExceptT01.program1 (Step 1)
  (\dictMonadEffect@v0 -> 
    let Monad0@v1 =
      ((
        dictMonadEffect@v0
      ).Monad0 <PrimUndefined>);
    let bindExceptT1@v2 =
      (Control.Monad.Except.Trans.bindExceptT Monad0@v1);
    {#- Rewrite - Inline -#}
    let discard2@v3 =
      (
        bindExceptT1@v2
      ).bind;
    let Functor0@v4 =
      ((
        ((
          ((
            Monad0@v1
          ).Bind1 <PrimUndefined>)
        ).Apply0 <PrimUndefined>)
      ).Functor0 <PrimUndefined>);
    {#- Rewrite - Inline -#}
    let map3@v5 =
      (
        Functor0@v4
      ).map;
    {#- Rewrite - Inline -#}
    let liftEffect1@v6 =
      (
        dictMonadEffect@v0
      ).liftEffect;
    {#- Rewrite - Inline -#}
    let bind1@v7 =
      (
        bindExceptT1@v2
      ).bind;
    let map4@v8 =
      {#- Rewrite - Inline -#}
      let v8 =
        { map =
            (\f@v8 -> 
              ((
                Functor0@v4
              ).map ((
                Data.Either.functorEither
              ).map f@v8))
            )
        };
      {#- Rewrite - Inline -#}
      let v9 =
        (
          v8
        ).map;
      v9;
    let apply1@v9 =
      {#- Rewrite - Inline -#}
      let v9 =
        (Control.Monad.Except.Trans.applyExceptT Monad0@v1);
      {#- Rewrite - Inline -#}
      let v10 =
        (
          v9
        ).apply;
      v10;
    let applicativeExceptT1@v10 =
      (Control.Monad.Except.Trans.applicativeExceptT Monad0@v1);
    let throwError1@v11 =
      {#- Rewrite - Inline -#}
      let v11 =
        (Control.Monad.Except.Trans.monadThrowExceptT Monad0@v1);
      {#- Rewrite - Inline -#}
      let v12 =
        (
          v11
        ).throwError;
      v12;
    {#- Rewrite - Inline -#}
    let pure1@v12 =
      (
        applicativeExceptT1@v10
      ).pure;
    ((discard2@v3 ((map3@v5 Data.Either.Right) (liftEffect1@v6 (Effect.Console.log "foo")))) (\$__unused@v13 -> 
      ((bind1@v7 (liftEffect1@v6 let v14 =
        ((Effect.Random.randomInt 1) 10);
      (effectDefer letEffect a'@v15 =
        v14;
      (effectPure (Data.Either.Right.Either a'@v15))))) (\i1@v14 -> 
        ((bind1@v7 ((map4@v8 (\v@v15 -> 
          {#- Rewrite - Inline -#}
          let v16 =
            4;
          (add v@v15 v16)
        )) ((map3@v5 {#- Rewrite - Inline -#}
        let v15 =
          (\v@v15 -> 
            {#- Rewrite - Inline -#}
            let v16 =
              1;
            (add v@v15 v16)
          );
        {#- Rewrite - Inline -#}
        let v16 =
          (\m@v16 -> 
            if (isTag Data.Either.Left m@v16) then
              (Data.Either.Left.Either (
                m@v16
              )#value0)
            else if (isTag Data.Either.Right m@v16) then
              (Data.Either.Right.Either (v15 (
                m@v16
              )#value0))
            else
              <PatternMatchFailure>
          );
        v16) (liftEffect1@v6 let v15 =
          ((Effect.Random.randomInt 1) 10);
        (effectDefer letEffect a'@v16 =
          v15;
        (effectPure (Data.Either.Right.Either a'@v16))))))) (\i2@v15 -> 
          ((bind1@v7 ((apply1@v9 ((map4@v8 Data.Semiring.intAdd) (liftEffect1@v6 let v16 =
            ((Effect.Random.randomInt 1) 10);
          (effectDefer letEffect a'@v17 =
            v16;
          (effectPure (Data.Either.Right.Either a'@v17)))))) (liftEffect1@v6 let v16 =
            ((Effect.Random.randomInt 1) 10);
          (effectDefer letEffect a'@v17 =
            v16;
          (effectPure (Data.Either.Right.Either a'@v17)))))) (\i3@v16 -> 
            ((discard2@v3 [[ LetAssoc
              let v17 =
                (add i1@v14 i2@v15);
              let v17 =
                {#- Rewrite - Inline -#}
                let v18 =
                  (\a2@v18 -> 
                    (< v17 a2@v18)
                  );
                (v18 i3@v16);
              let v18 =
                (throwError1@v11 "error");
              if v17 then
                v18
              else
                ((
                  applicativeExceptT1@v10
                ).pure <PrimUndefined>)
            ]]) (\$__unused@v17 -> 
              (pure1@v12 [[ LetAssoc
                let v18 =
                  {#- Rewrite - Inline -#}
                  let v18 =
                    1;
                  {#- Rewrite - Inline -#}
                  let v19 =
                    (\v19 -> 
                      (add v18 v19)
                    );
                  (v19 i1@v14);
                let v18 =
                  {#- Rewrite - Inline -#}
                  let v19 =
                    (\v19 -> 
                      (add v18 v19)
                    );
                  (v19 i2@v15);
                {#- Rewrite - Inline -#}
                let v19 =
                  (\v19 -> 
                    (add v18 v19)
                  );
                (v19 i3@v16)
              ]])
            ))
          ))
        ))
      ))
    ))
  )
---------------
Snapshot.TransformerExceptT01.program1 (Step 2)
  (\dictMonadEffect@v0 -> 
    let Monad0@v1 =
      ((
        dictMonadEffect@v0
      ).Monad0 <PrimUndefined>);
    let bindExceptT1@v2 =
      (Control.Monad.Except.Trans.bindExceptT Monad0@v1);
    let Functor0@v3 =
      ((
        ((
          ((
            Monad0@v1
          ).Bind1 <PrimUndefined>)
        ).Apply0 <PrimUndefined>)
      ).Functor0 <PrimUndefined>);
    {#- Rewrite - Inline -#}
    let map4@v4 =
      (\f@v4 -> 
        ((
          Functor0@v3
        ).map ((
          Data.Either.functorEither
        ).map f@v4))
      );
    let apply1@v5 =
      (
        (Control.Monad.Except.Trans.applyExceptT Monad0@v1)
      ).apply;
    let applicativeExceptT1@v6 =
      (Control.Monad.Except.Trans.applicativeExceptT Monad0@v1);
    let throwError1@v7 =
      (
        (Control.Monad.Except.Trans.monadThrowExceptT Monad0@v1)
      ).throwError;
    (((
      bindExceptT1@v2
    ).bind (((
      Functor0@v3
    ).map Data.Either.Right) ((
      dictMonadEffect@v0
    ).liftEffect (Effect.Console.log "foo")))) (\$__unused@v8 -> 
      (((
        bindExceptT1@v2
      ).bind ((
        dictMonadEffect@v0
      ).liftEffect let v9 =
        ((Effect.Random.randomInt 1) 10);
      (effectDefer letEffect a'@v10 =
        v9;
      (effectPure (Data.Either.Right.Either a'@v10))))) (\i1@v9 -> 
        (((
          bindExceptT1@v2
        ).bind ((map4@v4 (\v@v10 -> 
          (add v@v10 4)
        )) (((
          Functor0@v3
        ).map (\m@v10 -> 
          if (isTag Data.Either.Left m@v10) then
            (Data.Either.Left.Either (
              m@v10
            )#value0)
          else if (isTag Data.Either.Right m@v10) then
            (Data.Either.Right.Either {#- Rewrite - Inline -#}
            let v11 =
              (
                m@v10
              )#value0;
            (add v11 1))
          else
            <PatternMatchFailure>
        )) ((
          dictMonadEffect@v0
        ).liftEffect let v10 =
          ((Effect.Random.randomInt 1) 10);
        (effectDefer letEffect a'@v11 =
          v10;
        (effectPure (Data.Either.Right.Either a'@v11))))))) (\i2@v10 -> 
          (((
            bindExceptT1@v2
          ).bind ((apply1@v5 ((map4@v4 Data.Semiring.intAdd) ((
            dictMonadEffect@v0
          ).liftEffect let v11 =
            ((Effect.Random.randomInt 1) 10);
          (effectDefer letEffect a'@v12 =
            v11;
          (effectPure (Data.Either.Right.Either a'@v12)))))) ((
            dictMonadEffect@v0
          ).liftEffect let v11 =
            ((Effect.Random.randomInt 1) 10);
          (effectDefer letEffect a'@v12 =
            v11;
          (effectPure (Data.Either.Right.Either a'@v12)))))) (\i3@v11 -> 
            (((
              bindExceptT1@v2
            ).bind {#- Rewrite - Inline -#}
            let v12 =
              (add i1@v9 i2@v10);
            {#- Rewrite - Inline -#}
            let v13 =
              (< v12 i3@v11);
            let v14 =
              (throwError1@v7 "error");
            if v13 then
              v14
            else
              ((
                applicativeExceptT1@v6
              ).pure <PrimUndefined>)) (\$__unused@v12 -> 
              ((
                applicativeExceptT1@v6
              ).pure {#- Rewrite - Inline -#}
              let v13 =
                (add 1 i1@v9);
              {#- Rewrite - Inline -#}
              let v14 =
                (add v13 i2@v10);
              (add v14 i3@v11))
            ))
          ))
        ))
      ))
    ))
  )
---------------
Snapshot.TransformerExceptT01.program1 (Step 3)
  (\dictMonadEffect@v0 -> 
    let Monad0@v1 =
      ((
        dictMonadEffect@v0
      ).Monad0 <PrimUndefined>);
    let bindExceptT1@v2 =
      (Control.Monad.Except.Trans.bindExceptT Monad0@v1);
    let Functor0@v3 =
      ((
        ((
          ((
            Monad0@v1
          ).Bind1 <PrimUndefined>)
        ).Apply0 <PrimUndefined>)
      ).Functor0 <PrimUndefined>);
    let apply1@v4 =
      (
        (Control.Monad.Except.Trans.applyExceptT Monad0@v1)
      ).apply;
    let applicativeExceptT1@v5 =
      (Control.Monad.Except.Trans.applicativeExceptT Monad0@v1);
    let throwError1@v6 =
      (
        (Control.Monad.Except.Trans.monadThrowExceptT Monad0@v1)
      ).throwError;
    (((
      bindExceptT1@v2
    ).bind (((
      Functor0@v3
    ).map Data.Either.Right) ((
      dictMonadEffect@v0
    ).liftEffect (Effect.Console.log "foo")))) (\$__unused@v7 -> 
      (((
        bindExceptT1@v2
      ).bind ((
        dictMonadEffect@v0
      ).liftEffect let v8 =
        ((Effect.Random.randomInt 1) 10);
      (effectDefer letEffect a'@v9 =
        v8;
      (effectPure (Data.Either.Right.Either a'@v9))))) (\i1@v8 -> 
        (((
          bindExceptT1@v2
        ).bind {#- Rewrite - Inline -#}
        let v9 =
          (\v@v9 -> 
            (add v@v9 4)
          );
        (((
          Functor0@v3
        ).map ((
          Data.Either.functorEither
        ).map v9)) (((
          Functor0@v3
        ).map (\m@v10 -> 
          if (isTag Data.Either.Left m@v10) then
            (Data.Either.Left.Either (
              m@v10
            )#value0)
          else if (isTag Data.Either.Right m@v10) then
            (Data.Either.Right.Either (add (
              m@v10
            )#value0 1))
          else
            <PatternMatchFailure>
        )) ((
          dictMonadEffect@v0
        ).liftEffect let v10 =
          ((Effect.Random.randomInt 1) 10);
        (effectDefer letEffect a'@v11 =
          v10;
        (effectPure (Data.Either.Right.Either a'@v11))))))) (\i2@v9 -> 
          (((
            bindExceptT1@v2
          ).bind ((apply1@v4 (((
            Functor0@v3
          ).map ((
            Data.Either.functorEither
          ).map Data.Semiring.intAdd)) ((
            dictMonadEffect@v0
          ).liftEffect let v10 =
            ((Effect.Random.randomInt 1) 10);
          (effectDefer letEffect a'@v11 =
            v10;
          (effectPure (Data.Either.Right.Either a'@v11)))))) ((
            dictMonadEffect@v0
          ).liftEffect let v10 =
            ((Effect.Random.randomInt 1) 10);
          (effectDefer letEffect a'@v11 =
            v10;
          (effectPure (Data.Either.Right.Either a'@v11)))))) (\i3@v10 -> 
            (((
              bindExceptT1@v2
            ).bind let v11 =
              (throwError1@v6 "error");
            if (< (add i1@v8 i2@v9) i3@v10) then
              v11
            else
              ((
                applicativeExceptT1@v5
              ).pure <PrimUndefined>)) (\$__unused@v11 -> 
              ((
                applicativeExceptT1@v5
              ).pure (add (add (add 1 i1@v8) i2@v9) i3@v10))
            ))
          ))
        ))
      ))
    ))
  )
---------------
Snapshot.TransformerExceptT01.program1 (Step 4)
  (\dictMonadEffect@v0 -> 
    let Monad0@v1 =
      ((
        dictMonadEffect@v0
      ).Monad0 <PrimUndefined>);
    let bindExceptT1@v2 =
      (Control.Monad.Except.Trans.bindExceptT Monad0@v1);
    let Functor0@v3 =
      ((
        ((
          ((
            Monad0@v1
          ).Bind1 <PrimUndefined>)
        ).Apply0 <PrimUndefined>)
      ).Functor0 <PrimUndefined>);
    let apply1@v4 =
      (
        (Control.Monad.Except.Trans.applyExceptT Monad0@v1)
      ).apply;
    let applicativeExceptT1@v5 =
      (Control.Monad.Except.Trans.applicativeExceptT Monad0@v1);
    let throwError1@v6 =
      (
        (Control.Monad.Except.Trans.monadThrowExceptT Monad0@v1)
      ).throwError;
    (((
      bindExceptT1@v2
    ).bind (((
      Functor0@v3
    ).map Data.Either.Right) ((
      dictMonadEffect@v0
    ).liftEffect (Effect.Console.log "foo")))) (\$__unused@v7 -> 
      (((
        bindExceptT1@v2
      ).bind ((
        dictMonadEffect@v0
      ).liftEffect let v8 =
        ((Effect.Random.randomInt 1) 10);
      (effectDefer letEffect a'@v9 =
        v8;
      (effectPure (Data.Either.Right.Either a'@v9))))) (\i1@v8 -> 
        (((
          bindExceptT1@v2
        ).bind (((
          Functor0@v3
        ).map {#- Rewrite - Inline -#}
        let v9 =
          (\v@v9 -> 
            (add v@v9 4)
          );
        {#- Rewrite - Inline -#}
        let v10 =
          (\m@v10 -> 
            if (isTag Data.Either.Left m@v10) then
              (Data.Either.Left.Either (
                m@v10
              )#value0)
            else if (isTag Data.Either.Right m@v10) then
              (Data.Either.Right.Either (v9 (
                m@v10
              )#value0))
            else
              <PatternMatchFailure>
          );
        v10) (((
          Functor0@v3
        ).map (\m@v9 -> 
          if (isTag Data.Either.Left m@v9) then
            (Data.Either.Left.Either (
              m@v9
            )#value0)
          else if (isTag Data.Either.Right m@v9) then
            (Data.Either.Right.Either (add (
              m@v9
            )#value0 1))
          else
            <PatternMatchFailure>
        )) ((
          dictMonadEffect@v0
        ).liftEffect let v9 =
          ((Effect.Random.randomInt 1) 10);
        (effectDefer letEffect a'@v10 =
          v9;
        (effectPure (Data.Either.Right.Either a'@v10))))))) (\i2@v9 -> 
          (((
            bindExceptT1@v2
          ).bind ((apply1@v4 (((
            Functor0@v3
          ).map ((
            Data.Either.functorEither
          ).map Data.Semiring.intAdd)) ((
            dictMonadEffect@v0
          ).liftEffect let v10 =
            ((Effect.Random.randomInt 1) 10);
          (effectDefer letEffect a'@v11 =
            v10;
          (effectPure (Data.Either.Right.Either a'@v11)))))) ((
            dictMonadEffect@v0
          ).liftEffect let v10 =
            ((Effect.Random.randomInt 1) 10);
          (effectDefer letEffect a'@v11 =
            v10;
          (effectPure (Data.Either.Right.Either a'@v11)))))) (\i3@v10 -> 
            (((
              bindExceptT1@v2
            ).bind let v11 =
              (throwError1@v6 "error");
            if (< (add i1@v8 i2@v9) i3@v10) then
              v11
            else
              ((
                applicativeExceptT1@v5
              ).pure <PrimUndefined>)) (\$__unused@v11 -> 
              ((
                applicativeExceptT1@v5
              ).pure (add (add (add 1 i1@v8) i2@v9) i3@v10))
            ))
          ))
        ))
      ))
    ))
  )
---------------
Snapshot.TransformerExceptT01.program1 (Step 5)
  (\dictMonadEffect@v0 -> 
    let Monad0@v1 =
      ((
        dictMonadEffect@v0
      ).Monad0 <PrimUndefined>);
    let bindExceptT1@v2 =
      (Control.Monad.Except.Trans.bindExceptT Monad0@v1);
    let Functor0@v3 =
      ((
        ((
          ((
            Monad0@v1
          ).Bind1 <PrimUndefined>)
        ).Apply0 <PrimUndefined>)
      ).Functor0 <PrimUndefined>);
    let apply1@v4 =
      (
        (Control.Monad.Except.Trans.applyExceptT Monad0@v1)
      ).apply;
    let applicativeExceptT1@v5 =
      (Control.Monad.Except.Trans.applicativeExceptT Monad0@v1);
    let throwError1@v6 =
      (
        (Control.Monad.Except.Trans.monadThrowExceptT Monad0@v1)
      ).throwError;
    (((
      bindExceptT1@v2
    ).bind (((
      Functor0@v3
    ).map Data.Either.Right) ((
      dictMonadEffect@v0
    ).liftEffect (Effect.Console.log "foo")))) (\$__unused@v7 -> 
      (((
        bindExceptT1@v2
      ).bind ((
        dictMonadEffect@v0
      ).liftEffect let v8 =
        ((Effect.Random.randomInt 1) 10);
      (effectDefer letEffect a'@v9 =
        v8;
      (effectPure (Data.Either.Right.Either a'@v9))))) (\i1@v8 -> 
        (((
          bindExceptT1@v2
        ).bind (((
          Functor0@v3
        ).map (\m@v9 -> 
          if (isTag Data.Either.Left m@v9) then
            (Data.Either.Left.Either (
              m@v9
            )#value0)
          else if (isTag Data.Either.Right m@v9) then
            (Data.Either.Right.Either {#- Rewrite - Inline -#}
            let v10 =
              (
                m@v9
              )#value0;
            (add v10 4))
          else
            <PatternMatchFailure>
        )) (((
          Functor0@v3
        ).map (\m@v9 -> 
          if (isTag Data.Either.Left m@v9) then
            (Data.Either.Left.Either (
              m@v9
            )#value0)
          else if (isTag Data.Either.Right m@v9) then
            (Data.Either.Right.Either (add (
              m@v9
            )#value0 1))
          else
            <PatternMatchFailure>
        )) ((
          dictMonadEffect@v0
        ).liftEffect let v9 =
          ((Effect.Random.randomInt 1) 10);
        (effectDefer letEffect a'@v10 =
          v9;
        (effectPure (Data.Either.Right.Either a'@v10))))))) (\i2@v9 -> 
          (((
            bindExceptT1@v2
          ).bind ((apply1@v4 (((
            Functor0@v3
          ).map ((
            Data.Either.functorEither
          ).map Data.Semiring.intAdd)) ((
            dictMonadEffect@v0
          ).liftEffect let v10 =
            ((Effect.Random.randomInt 1) 10);
          (effectDefer letEffect a'@v11 =
            v10;
          (effectPure (Data.Either.Right.Either a'@v11)))))) ((
            dictMonadEffect@v0
          ).liftEffect let v10 =
            ((Effect.Random.randomInt 1) 10);
          (effectDefer letEffect a'@v11 =
            v10;
          (effectPure (Data.Either.Right.Either a'@v11)))))) (\i3@v10 -> 
            (((
              bindExceptT1@v2
            ).bind let v11 =
              (throwError1@v6 "error");
            if (< (add i1@v8 i2@v9) i3@v10) then
              v11
            else
              ((
                applicativeExceptT1@v5
              ).pure <PrimUndefined>)) (\$__unused@v11 -> 
              ((
                applicativeExceptT1@v5
              ).pure (add (add (add 1 i1@v8) i2@v9) i3@v10))
            ))
          ))
        ))
      ))
    ))
  )
---------------
Snapshot.TransformerExceptT01.program1 (Step 6; Final)
  (\dictMonadEffect@v0 -> 
    let Monad0@v1 =
      ((
        dictMonadEffect@v0
      ).Monad0 <PrimUndefined>);
    let bindExceptT1@v2 =
      (Control.Monad.Except.Trans.bindExceptT Monad0@v1);
    let Functor0@v3 =
      ((
        ((
          ((
            Monad0@v1
          ).Bind1 <PrimUndefined>)
        ).Apply0 <PrimUndefined>)
      ).Functor0 <PrimUndefined>);
    let apply1@v4 =
      (
        (Control.Monad.Except.Trans.applyExceptT Monad0@v1)
      ).apply;
    let applicativeExceptT1@v5 =
      (Control.Monad.Except.Trans.applicativeExceptT Monad0@v1);
    let throwError1@v6 =
      (
        (Control.Monad.Except.Trans.monadThrowExceptT Monad0@v1)
      ).throwError;
    (((
      bindExceptT1@v2
    ).bind (((
      Functor0@v3
    ).map Data.Either.Right) ((
      dictMonadEffect@v0
    ).liftEffect (Effect.Console.log "foo")))) (\$__unused@v7 -> 
      (((
        bindExceptT1@v2
      ).bind ((
        dictMonadEffect@v0
      ).liftEffect let v8 =
        ((Effect.Random.randomInt 1) 10);
      (effectDefer letEffect a'@v9 =
        v8;
      (effectPure (Data.Either.Right.Either a'@v9))))) (\i1@v8 -> 
        (((
          bindExceptT1@v2
        ).bind (((
          Functor0@v3
        ).map (\m@v9 -> 
          if (isTag Data.Either.Left m@v9) then
            (Data.Either.Left.Either (
              m@v9
            )#value0)
          else if (isTag Data.Either.Right m@v9) then
            (Data.Either.Right.Either (add (
              m@v9
            )#value0 4))
          else
            <PatternMatchFailure>
        )) (((
          Functor0@v3
        ).map (\m@v9 -> 
          if (isTag Data.Either.Left m@v9) then
            (Data.Either.Left.Either (
              m@v9
            )#value0)
          else if (isTag Data.Either.Right m@v9) then
            (Data.Either.Right.Either (add (
              m@v9
            )#value0 1))
          else
            <PatternMatchFailure>
        )) ((
          dictMonadEffect@v0
        ).liftEffect let v9 =
          ((Effect.Random.randomInt 1) 10);
        (effectDefer letEffect a'@v10 =
          v9;
        (effectPure (Data.Either.Right.Either a'@v10))))))) (\i2@v9 -> 
          (((
            bindExceptT1@v2
          ).bind ((apply1@v4 (((
            Functor0@v3
          ).map ((
            Data.Either.functorEither
          ).map Data.Semiring.intAdd)) ((
            dictMonadEffect@v0
          ).liftEffect let v10 =
            ((Effect.Random.randomInt 1) 10);
          (effectDefer letEffect a'@v11 =
            v10;
          (effectPure (Data.Either.Right.Either a'@v11)))))) ((
            dictMonadEffect@v0
          ).liftEffect let v10 =
            ((Effect.Random.randomInt 1) 10);
          (effectDefer letEffect a'@v11 =
            v10;
          (effectPure (Data.Either.Right.Either a'@v11)))))) (\i3@v10 -> 
            (((
              bindExceptT1@v2
            ).bind let v11 =
              (throwError1@v6 "error");
            if (< (add i1@v8 i2@v9) i3@v10) then
              v11
            else
              ((
                applicativeExceptT1@v5
              ).pure <PrimUndefined>)) (\$__unused@v11 -> 
              ((
                applicativeExceptT1@v5
              ).pure (add (add (add 1 i1@v8) i2@v9) i3@v10))
            ))
          ))
        ))
      ))
    ))
  )
===============
Snapshot.TransformerExceptT01.program2 (Step 0; Original)
  (\dictMonadThrow@v0 -> 
    let throwError1@v1 =
      (Control.Monad.Error.Class.throwError dictMonadThrow@v0);
    (\dictMonadEffect@v2 -> 
      let Monad0@v3 =
        ((
          dictMonadEffect@v2
        ).Monad0 <PrimUndefined>);
      let Bind1@v4 =
        ((
          Monad0@v3
        ).Bind1 <PrimUndefined>);
      let discard2@v5 =
        (Snapshot.TransformerExceptT01.discard Bind1@v4);
      let liftEffect1@v6 =
        (Effect.Class.liftEffect dictMonadEffect@v2);
      let bind1@v7 =
        (Control.Bind.bind Bind1@v4);
      let Apply0@v8 =
        ((
          Bind1@v4
        ).Apply0 <PrimUndefined>);
      let map3@v9 =
        (Data.Functor.map ((
          Apply0@v8
        ).Functor0 <PrimUndefined>));
      let apply1@v10 =
        (Control.Apply.apply Apply0@v8);
      let Applicative0@v11 =
        ((
          Monad0@v3
        ).Applicative0 <PrimUndefined>);
      {#- Rewrite - Inline -#}
      let when1@v12 =
        (Control.Applicative.when Applicative0@v11);
      let pure1@v13 =
        (Control.Applicative.pure Applicative0@v11);
      ((discard2@v5 (liftEffect1@v6 (Effect.Console.log "foo"))) (\$__unused@v14 -> 
        ((bind1@v7 (liftEffect1@v6 ((Effect.Random.randomInt 1) 10))) (\i1@v15 -> 
          ((bind1@v7 ((map3@v9 (\v@v16 -> 
            ((Snapshot.TransformerExceptT01.add v@v16) 4)
          )) (liftEffect1@v6 ((Effect.Random.randomInt 1) 10)))) (\i2@v16 -> 
            ((bind1@v7 ((apply1@v10 ((map3@v9 Snapshot.TransformerExceptT01.add) (liftEffect1@v6 ((Effect.Random.randomInt 1) 10)))) (liftEffect1@v6 ((Effect.Random.randomInt 1) 10)))) (\i3@v17 -> 
              ((discard2@v5 ((when1@v12 ((Snapshot.TransformerExceptT01.lessThan ((Snapshot.TransformerExceptT01.add i1@v15) i2@v16)) i3@v17)) (throwError1@v1 "error"))) (\$__unused@v18 -> 
                (pure1@v13 ((Snapshot.TransformerExceptT01.add ((Snapshot.TransformerExceptT01.add ((Snapshot.TransformerExceptT01.add 1) i1@v15)) i2@v16)) i3@v17))
              ))
            ))
          ))
        ))
      ))
    )
  )
---------------
Snapshot.TransformerExceptT01.program2 (Step 1)
  (\dictMonadThrow@v0 -> 
    {#- Rewrite - Inline -#}
    let throwError1@v1 =
      (
        dictMonadThrow@v0
      ).throwError;
    (\dictMonadEffect@v2 -> 
      let Monad0@v3 =
        ((
          dictMonadEffect@v2
        ).Monad0 <PrimUndefined>);
      let Bind1@v4 =
        ((
          Monad0@v3
        ).Bind1 <PrimUndefined>);
      {#- Rewrite - Inline -#}
      let discard2@v5 =
        (
          Bind1@v4
        ).bind;
      {#- Rewrite - Inline -#}
      let liftEffect1@v6 =
        (
          dictMonadEffect@v2
        ).liftEffect;
      {#- Rewrite - Inline -#}
      let bind1@v7 =
        (
          Bind1@v4
        ).bind;
      let Apply0@v8 =
        ((
          Bind1@v4
        ).Apply0 <PrimUndefined>);
      let map3@v9 =
        {#- Rewrite - Inline -#}
        let v9 =
          ((
            Apply0@v8
          ).Functor0 <PrimUndefined>);
        {#- Rewrite - Inline -#}
        let v10 =
          (
            v9
          ).map;
        v10;
      {#- Rewrite - Inline -#}
      let apply1@v10 =
        (
          Apply0@v8
        ).apply;
      let Applicative0@v11 =
        ((
          Monad0@v3
        ).Applicative0 <PrimUndefined>);
      {#- Rewrite - Inline -#}
      let pure1@v12 =
        (
          Applicative0@v11
        ).pure;
      ((discard2@v5 (liftEffect1@v6 (Effect.Console.log "foo"))) (\$__unused@v13 -> 
        ((bind1@v7 (liftEffect1@v6 ((Effect.Random.randomInt 1) 10))) (\i1@v14 -> 
          ((bind1@v7 ((map3@v9 (\v@v15 -> 
            {#- Rewrite - Inline -#}
            let v16 =
              4;
            (add v@v15 v16)
          )) (liftEffect1@v6 ((Effect.Random.randomInt 1) 10)))) (\i2@v15 -> 
            ((bind1@v7 ((apply1@v10 ((map3@v9 Data.Semiring.intAdd) (liftEffect1@v6 ((Effect.Random.randomInt 1) 10)))) (liftEffect1@v6 ((Effect.Random.randomInt 1) 10)))) (\i3@v16 -> 
              ((discard2@v5 [[ LetAssoc
                let v17 =
                  (add i1@v14 i2@v15);
                let v17 =
                  {#- Rewrite - Inline -#}
                  let v18 =
                    (\a2@v18 -> 
                      (< v17 a2@v18)
                    );
                  (v18 i3@v16);
                let v18 =
                  (throwError1@v1 "error");
                if v17 then
                  v18
                else
                  ((
                    Applicative0@v11
                  ).pure <PrimUndefined>)
              ]]) (\$__unused@v17 -> 
                (pure1@v12 [[ LetAssoc
                  let v18 =
                    {#- Rewrite - Inline -#}
                    let v18 =
                      1;
                    {#- Rewrite - Inline -#}
                    let v19 =
                      (\v19 -> 
                        (add v18 v19)
                      );
                    (v19 i1@v14);
                  let v18 =
                    {#- Rewrite - Inline -#}
                    let v19 =
                      (\v19 -> 
                        (add v18 v19)
                      );
                    (v19 i2@v15);
                  {#- Rewrite - Inline -#}
                  let v19 =
                    (\v19 -> 
                      (add v18 v19)
                    );
                  (v19 i3@v16)
                ]])
              ))
            ))
          ))
        ))
      ))
    )
  )
---------------
Snapshot.TransformerExceptT01.program2 (Step 2)
  (\dictMonadThrow@v0 -> \dictMonadEffect@v1 -> 
    let Monad0@v2 =
      ((
        dictMonadEffect@v1
      ).Monad0 <PrimUndefined>);
    let Bind1@v3 =
      ((
        Monad0@v2
      ).Bind1 <PrimUndefined>);
    let Apply0@v4 =
      ((
        Bind1@v3
      ).Apply0 <PrimUndefined>);
    let map3@v5 =
      (
        ((
          Apply0@v4
        ).Functor0 <PrimUndefined>)
      ).map;
    let Applicative0@v6 =
      ((
        Monad0@v2
      ).Applicative0 <PrimUndefined>);
    (((
      Bind1@v3
    ).bind ((
      dictMonadEffect@v1
    ).liftEffect (Effect.Console.log "foo"))) (\$__unused@v7 -> 
      (((
        Bind1@v3
      ).bind ((
        dictMonadEffect@v1
      ).liftEffect ((Effect.Random.randomInt 1) 10))) (\i1@v8 -> 
        (((
          Bind1@v3
        ).bind ((map3@v5 (\v@v9 -> 
          (add v@v9 4)
        )) ((
          dictMonadEffect@v1
        ).liftEffect ((Effect.Random.randomInt 1) 10)))) (\i2@v9 -> 
          (((
            Bind1@v3
          ).bind (((
            Apply0@v4
          ).apply ((map3@v5 Data.Semiring.intAdd) ((
            dictMonadEffect@v1
          ).liftEffect ((Effect.Random.randomInt 1) 10)))) ((
            dictMonadEffect@v1
          ).liftEffect ((Effect.Random.randomInt 1) 10)))) (\i3@v10 -> 
            (((
              Bind1@v3
            ).bind {#- Rewrite - Inline -#}
            let v11 =
              (add i1@v8 i2@v9);
            {#- Rewrite - Inline -#}
            let v12 =
              (< v11 i3@v10);
            let v13 =
              ((
                dictMonadThrow@v0
              ).throwError "error");
            if v12 then
              v13
            else
              ((
                Applicative0@v6
              ).pure <PrimUndefined>)) (\$__unused@v11 -> 
              ((
                Applicative0@v6
              ).pure {#- Rewrite - Inline -#}
              let v12 =
                (add 1 i1@v8);
              {#- Rewrite - Inline -#}
              let v13 =
                (add v12 i2@v9);
              (add v13 i3@v10))
            ))
          ))
        ))
      ))
    ))
  )
---------------
Snapshot.TransformerExceptT01.program2 (Step 3; Final)
  (\dictMonadThrow@v0 -> \dictMonadEffect@v1 -> 
    let Monad0@v2 =
      ((
        dictMonadEffect@v1
      ).Monad0 <PrimUndefined>);
    let Bind1@v3 =
      ((
        Monad0@v2
      ).Bind1 <PrimUndefined>);
    let Apply0@v4 =
      ((
        Bind1@v3
      ).Apply0 <PrimUndefined>);
    let map3@v5 =
      (
        ((
          Apply0@v4
        ).Functor0 <PrimUndefined>)
      ).map;
    let Applicative0@v6 =
      ((
        Monad0@v2
      ).Applicative0 <PrimUndefined>);
    (((
      Bind1@v3
    ).bind ((
      dictMonadEffect@v1
    ).liftEffect (Effect.Console.log "foo"))) (\$__unused@v7 -> 
      (((
        Bind1@v3
      ).bind ((
        dictMonadEffect@v1
      ).liftEffect ((Effect.Random.randomInt 1) 10))) (\i1@v8 -> 
        (((
          Bind1@v3
        ).bind ((map3@v5 (\v@v9 -> 
          (add v@v9 4)
        )) ((
          dictMonadEffect@v1
        ).liftEffect ((Effect.Random.randomInt 1) 10)))) (\i2@v9 -> 
          (((
            Bind1@v3
          ).bind (((
            Apply0@v4
          ).apply ((map3@v5 Data.Semiring.intAdd) ((
            dictMonadEffect@v1
          ).liftEffect ((Effect.Random.randomInt 1) 10)))) ((
            dictMonadEffect@v1
          ).liftEffect ((Effect.Random.randomInt 1) 10)))) (\i3@v10 -> 
            (((
              Bind1@v3
            ).bind let v11 =
              ((
                dictMonadThrow@v0
              ).throwError "error");
            if (< (add i1@v8 i2@v9) i3@v10) then
              v11
            else
              ((
                Applicative0@v6
              ).pure <PrimUndefined>)) (\$__unused@v11 -> 
              ((
                Applicative0@v6
              ).pure (add (add (add 1 i1@v8) i2@v9) i3@v10))
            ))
          ))
        ))
      ))
    ))
  )
===============
Snapshot.TransformerExceptT01.pure (Step 0; Original)
  (Control.Applicative.pure Snapshot.TransformerExceptT01.applicativeExceptT)
---------------
Snapshot.TransformerExceptT01.pure (Step 1; Final)
  (
    Snapshot.TransformerExceptT01.applicativeExceptT
  ).pure
===============
Snapshot.TransformerExceptT01.test1 (Step 0; Original)
  (Control.Monad.Except.Trans.runExceptT ((Snapshot.TransformerExceptT01.discard1 ((Snapshot.TransformerExceptT01.map Data.Either.Right) (Snapshot.TransformerExceptT01.liftEffect (Effect.Console.log "foo")))) (\$__unused@v0 -> 
    ((Snapshot.TransformerExceptT01.bind (Snapshot.TransformerExceptT01.liftEffect ((Snapshot.TransformerExceptT01.map Data.Either.Right) ((Effect.Random.randomInt 1) 10)))) (\i1@v1 -> 
      ((Snapshot.TransformerExceptT01.bind ((Snapshot.TransformerExceptT01.map1 (\v@v2 -> 
        ((Snapshot.TransformerExceptT01.add v@v2) 4)
      )) ((Snapshot.TransformerExceptT01.map (Snapshot.TransformerExceptT01.map2 (\v@v2 -> 
        ((Snapshot.TransformerExceptT01.add v@v2) 1)
      ))) (Snapshot.TransformerExceptT01.liftEffect ((Snapshot.TransformerExceptT01.map Data.Either.Right) ((Effect.Random.randomInt 1) 10)))))) (\i2@v2 -> 
        ((Snapshot.TransformerExceptT01.bind ((Snapshot.TransformerExceptT01.apply ((Snapshot.TransformerExceptT01.map1 Snapshot.TransformerExceptT01.add) (Snapshot.TransformerExceptT01.liftEffect ((Snapshot.TransformerExceptT01.map Data.Either.Right) ((Effect.Random.randomInt 1) 10))))) (Snapshot.TransformerExceptT01.liftEffect ((Snapshot.TransformerExceptT01.map Data.Either.Right) ((Effect.Random.randomInt 1) 10))))) (\i3@v3 -> 
          ((Snapshot.TransformerExceptT01.discard1 ((Snapshot.TransformerExceptT01.when ((Snapshot.TransformerExceptT01.lessThan ((Snapshot.TransformerExceptT01.add i1@v1) i2@v2)) i3@v3)) (Snapshot.TransformerExceptT01.throwError "error"))) (\$__unused@v4 -> 
            (Snapshot.TransformerExceptT01.pure ((Snapshot.TransformerExceptT01.add ((Snapshot.TransformerExceptT01.add ((Snapshot.TransformerExceptT01.add 1) i1@v1)) i2@v2)) i3@v3))
          ))
        ))
      ))
    ))
  )))
---------------
Snapshot.TransformerExceptT01.test1 (Step 1)
  {#- Rewrite - Inline -#}
  let v0 =
    (((
      Snapshot.TransformerExceptT01.bindExceptT
    ).bind let v0 =
      {#- Rewrite - Inline -#}
      let v0 =
        (Effect.Console.log "foo");
      v0;
    (effectDefer letEffect a'@v1 =
      v0;
    (effectPure (Data.Either.Right.Either a'@v1)))) (\$__unused@v0 -> 
      (((
        Snapshot.TransformerExceptT01.bindExceptT
      ).bind [[ LetAssoc
        let v1 =
          ((Effect.Random.randomInt 1) 10);
        let v1 =
          (effectDefer letEffect a'@v2 =
            v1;
          (effectPure (Data.Either.Right.Either a'@v2)));
        v1
      ]]) (\i1@v1 -> 
        (((
          Snapshot.TransformerExceptT01.bindExceptT
        ).bind ((Snapshot.TransformerExceptT01.map1 (\v@v2 -> 
          {#- Rewrite - Inline -#}
          let v3 =
            4;
          (add v@v2 v3)
        )) let v2 =
          {#- Rewrite - Inline -#}
          let v2 =
            (\v@v2 -> 
              {#- Rewrite - Inline -#}
              let v3 =
                1;
              (add v@v2 v3)
            );
          {#- Rewrite - Inline -#}
          let v3 =
            (\m@v3 -> 
              if (isTag Data.Either.Left m@v3) then
                (Data.Either.Left.Either (
                  m@v3
                )#value0)
              else if (isTag Data.Either.Right m@v3) then
                (Data.Either.Right.Either (v2 (
                  m@v3
                )#value0))
              else
                <PatternMatchFailure>
            );
          v3;
        {#- Rewrite - Inline -#}
        let v3 =
          (\a@v3 -> 
            (effectDefer letEffect a'@v4 =
              a@v3;
            (effectPure (v2 a'@v4)))
          );
        (v3 [[ LetAssoc
          let v4 =
            ((Effect.Random.randomInt 1) 10);
          let v4 =
            (effectDefer letEffect a'@v5 =
              v4;
            (effectPure (Data.Either.Right.Either a'@v5)));
          v4
        ]]))) (\i2@v2 -> 
          (((
            Snapshot.TransformerExceptT01.bindExceptT
          ).bind ((Snapshot.TransformerExceptT01.apply ((Snapshot.TransformerExceptT01.map1 Data.Semiring.intAdd) [[ LetAssoc
            let v3 =
              ((Effect.Random.randomInt 1) 10);
            let v3 =
              (effectDefer letEffect a'@v4 =
                v3;
              (effectPure (Data.Either.Right.Either a'@v4)));
            v3
          ]])) [[ LetAssoc
            let v3 =
              ((Effect.Random.randomInt 1) 10);
            let v3 =
              (effectDefer letEffect a'@v4 =
                v3;
              (effectPure (Data.Either.Right.Either a'@v4)));
            v3
          ]])) (\i3@v3 -> 
            (((
              Snapshot.TransformerExceptT01.bindExceptT
            ).bind [[ LetAssoc
              let v4 =
                (add i1@v1 i2@v2);
              let v4 =
                {#- Rewrite - Inline -#}
                let v5 =
                  (\a2@v5 -> 
                    (< v4 a2@v5)
                  );
                (v5 i3@v3);
              let v5 =
                ((
                  Snapshot.TransformerExceptT01.monadThrowExceptT
                ).throwError "error");
              if v4 then
                v5
              else
                ((
                  Snapshot.TransformerExceptT01.applicativeExceptT
                ).pure <PrimUndefined>)
            ]]) (\$__unused@v4 -> 
              ((
                Snapshot.TransformerExceptT01.applicativeExceptT
              ).pure [[ LetAssoc
                let v5 =
                  {#- Rewrite - Inline -#}
                  let v5 =
                    1;
                  {#- Rewrite - Inline -#}
                  let v6 =
                    (\v6 -> 
                      (add v5 v6)
                    );
                  (v6 i1@v1);
                let v5 =
                  {#- Rewrite - Inline -#}
                  let v6 =
                    (\v6 -> 
                      (add v5 v6)
                    );
                  (v6 i2@v2);
                {#- Rewrite - Inline -#}
                let v6 =
                  (\v6 -> 
                    (add v5 v6)
                  );
                (v6 i3@v3)
              ]])
            ))
          ))
        ))
      ))
    ));
  v0
---------------
Snapshot.TransformerExceptT01.test1 (Step 2)
  (((
    Snapshot.TransformerExceptT01.bindExceptT
  ).bind let v0 =
    (Effect.Console.log "foo");
  (effectDefer letEffect a'@v1 =
    v0;
  (effectPure (Data.Either.Right.Either a'@v1)))) (\$__unused@v0 -> 
    (((
      Snapshot.TransformerExceptT01.bindExceptT
    ).bind let v1 =
      ((Effect.Random.randomInt 1) 10);
    {#- Rewrite - Inline -#}
    let v2 =
      (effectDefer letEffect a'@v2 =
        v1;
      (effectPure (Data.Either.Right.Either a'@v2)));
    v2) (\i1@v1 -> 
      (((
        Snapshot.TransformerExceptT01.bindExceptT
      ).bind ((Snapshot.TransformerExceptT01.map1 (\v@v2 -> 
        (add v@v2 4)
      )) {#- Rewrite - Inline -#}
      let v2 =
        (\m@v2 -> 
          if (isTag Data.Either.Left m@v2) then
            (Data.Either.Left.Either (
              m@v2
            )#value0)
          else if (isTag Data.Either.Right m@v2) then
            (Data.Either.Right.Either {#- Rewrite - Inline -#}
            let v3 =
              (
                m@v2
              )#value0;
            (add v3 1))
          else
            <PatternMatchFailure>
        );
      [[ LetAssoc
        let v3 =
          ((Effect.Random.randomInt 1) 10);
        let v3 =
          {#- Rewrite - Inline -#}
          let v4 =
            (effectDefer letEffect a'@v4 =
              v3;
            (effectPure (Data.Either.Right.Either a'@v4)));
          v4;
        (effectDefer letEffect a'@v4 =
          v3;
        (effectPure (v2 a'@v4)))
      ]])) (\i2@v2 -> 
        (((
          Snapshot.TransformerExceptT01.bindExceptT
        ).bind ((Snapshot.TransformerExceptT01.apply ((Snapshot.TransformerExceptT01.map1 Data.Semiring.intAdd) let v3 =
          ((Effect.Random.randomInt 1) 10);
        {#- Rewrite - Inline -#}
        let v4 =
          (effectDefer letEffect a'@v4 =
            v3;
          (effectPure (Data.Either.Right.Either a'@v4)));
        v4)) let v3 =
          ((Effect.Random.randomInt 1) 10);
        {#- Rewrite - Inline -#}
        let v4 =
          (effectDefer letEffect a'@v4 =
            v3;
          (effectPure (Data.Either.Right.Either a'@v4)));
        v4)) (\i3@v3 -> 
          (((
            Snapshot.TransformerExceptT01.bindExceptT
          ).bind {#- Rewrite - Inline -#}
          let v4 =
            (add i1@v1 i2@v2);
          {#- Rewrite - Inline -#}
          let v5 =
            (< v4 i3@v3);
          let v6 =
            ((
              Snapshot.TransformerExceptT01.monadThrowExceptT
            ).throwError "error");
          if v5 then
            v6
          else
            ((
              Snapshot.TransformerExceptT01.applicativeExceptT
            ).pure <PrimUndefined>)) (\$__unused@v4 -> 
            ((
              Snapshot.TransformerExceptT01.applicativeExceptT
            ).pure {#- Rewrite - Inline -#}
            let v5 =
              (add 1 i1@v1);
            {#- Rewrite - Inline -#}
            let v6 =
              (add v5 i2@v2);
            (add v6 i3@v3))
          ))
        ))
      ))
    ))
  ))
---------------
Snapshot.TransformerExceptT01.test1 (Step 3)
  (((
    Snapshot.TransformerExceptT01.bindExceptT
  ).bind let v0 =
    (Effect.Console.log "foo");
  (effectDefer letEffect a'@v1 =
    v0;
  (effectPure (Data.Either.Right.Either a'@v1)))) (\$__unused@v0 -> 
    (((
      Snapshot.TransformerExceptT01.bindExceptT
    ).bind let v1 =
      ((Effect.Random.randomInt 1) 10);
    (effectDefer letEffect a'@v2 =
      v1;
    (effectPure (Data.Either.Right.Either a'@v2)))) (\i1@v1 -> 
      (((
        Snapshot.TransformerExceptT01.bindExceptT
      ).bind ((Snapshot.TransformerExceptT01.map1 (\v@v2 -> 
        (add v@v2 4)
      )) let v2 =
        ((Effect.Random.randomInt 1) 10);
      {#- Rewrite - Inline -#}
      let v3 =
        (effectDefer letEffect a'@v3 =
          v2;
        (effectPure (Data.Either.Right.Either a'@v3)));
      (effectDefer letEffect a'@v4 =
        v3;
      (effectPure if (isTag Data.Either.Left a'@v4) then
        (Data.Either.Left.Either (
          a'@v4
        )#value0)
      else if (isTag Data.Either.Right a'@v4) then
        (Data.Either.Right.Either (add (
          a'@v4
        )#value0 1))
      else
        <PatternMatchFailure>)))) (\i2@v2 -> 
        (((
          Snapshot.TransformerExceptT01.bindExceptT
        ).bind ((Snapshot.TransformerExceptT01.apply ((Snapshot.TransformerExceptT01.map1 Data.Semiring.intAdd) let v3 =
          ((Effect.Random.randomInt 1) 10);
        (effectDefer letEffect a'@v4 =
          v3;
        (effectPure (Data.Either.Right.Either a'@v4))))) let v3 =
          ((Effect.Random.randomInt 1) 10);
        (effectDefer letEffect a'@v4 =
          v3;
        (effectPure (Data.Either.Right.Either a'@v4))))) (\i3@v3 -> 
          (((
            Snapshot.TransformerExceptT01.bindExceptT
          ).bind let v4 =
            ((
              Snapshot.TransformerExceptT01.monadThrowExceptT
            ).throwError "error");
          if (< (add i1@v1 i2@v2) i3@v3) then
            v4
          else
            ((
              Snapshot.TransformerExceptT01.applicativeExceptT
            ).pure <PrimUndefined>)) (\$__unused@v4 -> 
            ((
              Snapshot.TransformerExceptT01.applicativeExceptT
            ).pure (add (add (add 1 i1@v1) i2@v2) i3@v3))
          ))
        ))
      ))
    ))
  ))
---------------
Snapshot.TransformerExceptT01.test1 (Step 4)
  (((
    Snapshot.TransformerExceptT01.bindExceptT
  ).bind let v0 =
    (Effect.Console.log "foo");
  (effectDefer letEffect a'@v1 =
    v0;
  (effectPure (Data.Either.Right.Either a'@v1)))) (\$__unused@v0 -> 
    (((
      Snapshot.TransformerExceptT01.bindExceptT
    ).bind let v1 =
      ((Effect.Random.randomInt 1) 10);
    (effectDefer letEffect a'@v2 =
      v1;
    (effectPure (Data.Either.Right.Either a'@v2)))) (\i1@v1 -> 
      (((
        Snapshot.TransformerExceptT01.bindExceptT
      ).bind ((Snapshot.TransformerExceptT01.map1 (\v@v2 -> 
        (add v@v2 4)
      )) let v2 =
        ((Effect.Random.randomInt 1) 10);
      (effectDefer [[ EffectBindAssoc
        letEffect a'@v3 =
          v2;
        letEffect a'@v3 =
          (effectPure (Data.Either.Right.Either a'@v3));
        (effectPure if (isTag Data.Either.Left a'@v3) then
          (Data.Either.Left.Either (
            a'@v3
          )#value0)
        else if (isTag Data.Either.Right a'@v3) then
          (Data.Either.Right.Either (add (
            a'@v3
          )#value0 1))
        else
          <PatternMatchFailure>)
      ]]))) (\i2@v2 -> 
        (((
          Snapshot.TransformerExceptT01.bindExceptT
        ).bind ((Snapshot.TransformerExceptT01.apply ((Snapshot.TransformerExceptT01.map1 Data.Semiring.intAdd) let v3 =
          ((Effect.Random.randomInt 1) 10);
        (effectDefer letEffect a'@v4 =
          v3;
        (effectPure (Data.Either.Right.Either a'@v4))))) let v3 =
          ((Effect.Random.randomInt 1) 10);
        (effectDefer letEffect a'@v4 =
          v3;
        (effectPure (Data.Either.Right.Either a'@v4))))) (\i3@v3 -> 
          (((
            Snapshot.TransformerExceptT01.bindExceptT
          ).bind let v4 =
            ((
              Snapshot.TransformerExceptT01.monadThrowExceptT
            ).throwError "error");
          if (< (add i1@v1 i2@v2) i3@v3) then
            v4
          else
            ((
              Snapshot.TransformerExceptT01.applicativeExceptT
            ).pure <PrimUndefined>)) (\$__unused@v4 -> 
            ((
              Snapshot.TransformerExceptT01.applicativeExceptT
            ).pure (add (add (add 1 i1@v1) i2@v2) i3@v3))
          ))
        ))
      ))
    ))
  ))
---------------
Snapshot.TransformerExceptT01.test1 (Step 5)
  (((
    Snapshot.TransformerExceptT01.bindExceptT
  ).bind let v0 =
    (Effect.Console.log "foo");
  (effectDefer letEffect a'@v1 =
    v0;
  (effectPure (Data.Either.Right.Either a'@v1)))) (\$__unused@v0 -> 
    (((
      Snapshot.TransformerExceptT01.bindExceptT
    ).bind let v1 =
      ((Effect.Random.randomInt 1) 10);
    (effectDefer letEffect a'@v2 =
      v1;
    (effectPure (Data.Either.Right.Either a'@v2)))) (\i1@v1 -> 
      (((
        Snapshot.TransformerExceptT01.bindExceptT
      ).bind ((Snapshot.TransformerExceptT01.map1 (\v@v2 -> 
        (add v@v2 4)
      )) let v2 =
        ((Effect.Random.randomInt 1) 10);
      (effectDefer letEffect a'@v3 =
        v2;
      {#- Rewrite - Inline -#}
      let a'@v4 =
        (Data.Either.Right.Either a'@v3);
      (effectPure if (isTag Data.Either.Left a'@v4) then
        (Data.Either.Left.Either (
          a'@v4
        )#value0)
      else if (isTag Data.Either.Right a'@v4) then
        (Data.Either.Right.Either (add (
          a'@v4
        )#value0 1))
      else
        <PatternMatchFailure>)))) (\i2@v2 -> 
        (((
          Snapshot.TransformerExceptT01.bindExceptT
        ).bind ((Snapshot.TransformerExceptT01.apply ((Snapshot.TransformerExceptT01.map1 Data.Semiring.intAdd) let v3 =
          ((Effect.Random.randomInt 1) 10);
        (effectDefer letEffect a'@v4 =
          v3;
        (effectPure (Data.Either.Right.Either a'@v4))))) let v3 =
          ((Effect.Random.randomInt 1) 10);
        (effectDefer letEffect a'@v4 =
          v3;
        (effectPure (Data.Either.Right.Either a'@v4))))) (\i3@v3 -> 
          (((
            Snapshot.TransformerExceptT01.bindExceptT
          ).bind let v4 =
            ((
              Snapshot.TransformerExceptT01.monadThrowExceptT
            ).throwError "error");
          if (< (add i1@v1 i2@v2) i3@v3) then
            v4
          else
            ((
              Snapshot.TransformerExceptT01.applicativeExceptT
            ).pure <PrimUndefined>)) (\$__unused@v4 -> 
            ((
              Snapshot.TransformerExceptT01.applicativeExceptT
            ).pure (add (add (add 1 i1@v1) i2@v2) i3@v3))
          ))
        ))
      ))
    ))
  ))
---------------
Snapshot.TransformerExceptT01.test1 (Step 6; Final)
  (((
    Snapshot.TransformerExceptT01.bindExceptT
  ).bind let v0 =
    (Effect.Console.log "foo");
  (effectDefer letEffect a'@v1 =
    v0;
  (effectPure (Data.Either.Right.Either a'@v1)))) (\$__unused@v0 -> 
    (((
      Snapshot.TransformerExceptT01.bindExceptT
    ).bind let v1 =
      ((Effect.Random.randomInt 1) 10);
    (effectDefer letEffect a'@v2 =
      v1;
    (effectPure (Data.Either.Right.Either a'@v2)))) (\i1@v1 -> 
      (((
        Snapshot.TransformerExceptT01.bindExceptT
      ).bind ((Snapshot.TransformerExceptT01.map1 (\v@v2 -> 
        (add v@v2 4)
      )) let v2 =
        ((Effect.Random.randomInt 1) 10);
      (effectDefer letEffect a'@v3 =
        v2;
      (effectPure (Data.Either.Right.Either (add a'@v3 1)))))) (\i2@v2 -> 
        (((
          Snapshot.TransformerExceptT01.bindExceptT
        ).bind ((Snapshot.TransformerExceptT01.apply ((Snapshot.TransformerExceptT01.map1 Data.Semiring.intAdd) let v3 =
          ((Effect.Random.randomInt 1) 10);
        (effectDefer letEffect a'@v4 =
          v3;
        (effectPure (Data.Either.Right.Either a'@v4))))) let v3 =
          ((Effect.Random.randomInt 1) 10);
        (effectDefer letEffect a'@v4 =
          v3;
        (effectPure (Data.Either.Right.Either a'@v4))))) (\i3@v3 -> 
          (((
            Snapshot.TransformerExceptT01.bindExceptT
          ).bind let v4 =
            ((
              Snapshot.TransformerExceptT01.monadThrowExceptT
            ).throwError "error");
          if (< (add i1@v1 i2@v2) i3@v3) then
            v4
          else
            ((
              Snapshot.TransformerExceptT01.applicativeExceptT
            ).pure <PrimUndefined>)) (\$__unused@v4 -> 
            ((
              Snapshot.TransformerExceptT01.applicativeExceptT
            ).pure (add (add (add 1 i1@v1) i2@v2) i3@v3))
          ))
        ))
      ))
    ))
  ))
===============
Snapshot.TransformerExceptT01.test2 (Step 0; Original)
  (Control.Monad.Except.Trans.runExceptT (Snapshot.TransformerExceptT01.program1 Effect.Class.monadEffectEffect))
---------------
Snapshot.TransformerExceptT01.test2 (Step 1)
  {#- Rewrite - Inline -#}
  let v0 =
    {#- Rewrite - Inline -#}
    let Monad0@v0 =
      {#- Rewrite - Inline -#}
      let v0 =
        <PrimUndefined>;
      Effect.monadEffect;
    [[ LetAssoc
      let bindExceptT1@v1 =
        (Control.Monad.Except.Trans.bindExceptT Monad0@v0);
      let v1 =
        let Functor0@v2 =
          ((
            ((
              ((
                Monad0@v0
              ).Bind1 <PrimUndefined>)
            ).Apply0 <PrimUndefined>)
          ).Functor0 <PrimUndefined>);
        let apply1@v3 =
          (
            (Control.Monad.Except.Trans.applyExceptT Monad0@v0)
          ).apply;
        let applicativeExceptT1@v4 =
          (Control.Monad.Except.Trans.applicativeExceptT Monad0@v0);
        let throwError1@v5 =
          (
            (Control.Monad.Except.Trans.monadThrowExceptT Monad0@v0)
          ).throwError;
        (((
          bindExceptT1@v1
        ).bind (((
          Functor0@v2
        ).map Data.Either.Right) {#- Rewrite - Inline -#}
        let v6 =
          (Effect.Console.log "foo");
        v6)) (\$__unused@v6 -> 
          (((
            bindExceptT1@v1
          ).bind [[ LetAssoc
            let v7 =
              ((Effect.Random.randomInt 1) 10);
            let v7 =
              (effectDefer letEffect a'@v8 =
                v7;
              (effectPure (Data.Either.Right.Either a'@v8)));
            v7
          ]]) (\i1@v7 -> 
            (((
              bindExceptT1@v1
            ).bind (((
              Functor0@v2
            ).map (\m@v8 -> 
              if (isTag Data.Either.Left m@v8) then
                (Data.Either.Left.Either (
                  m@v8
                )#value0)
              else if (isTag Data.Either.Right m@v8) then
                (Data.Either.Right.Either (add (
                  m@v8
                )#value0 4))
              else
                <PatternMatchFailure>
            )) (((
              Functor0@v2
            ).map (\m@v8 -> 
              if (isTag Data.Either.Left m@v8) then
                (Data.Either.Left.Either (
                  m@v8
                )#value0)
              else if (isTag Data.Either.Right m@v8) then
                (Data.Either.Right.Either (add (
                  m@v8
                )#value0 1))
              else
                <PatternMatchFailure>
            )) [[ LetAssoc
              let v8 =
                ((Effect.Random.randomInt 1) 10);
              let v8 =
                (effectDefer letEffect a'@v9 =
                  v8;
                (effectPure (Data.Either.Right.Either a'@v9)));
              v8
            ]]))) (\i2@v8 -> 
              (((
                bindExceptT1@v1
              ).bind ((apply1@v3 (((
                Functor0@v2
              ).map ((
                Data.Either.functorEither
              ).map Data.Semiring.intAdd)) [[ LetAssoc
                let v9 =
                  ((Effect.Random.randomInt 1) 10);
                let v9 =
                  (effectDefer letEffect a'@v10 =
                    v9;
                  (effectPure (Data.Either.Right.Either a'@v10)));
                v9
              ]])) [[ LetAssoc
                let v9 =
                  ((Effect.Random.randomInt 1) 10);
                let v9 =
                  (effectDefer letEffect a'@v10 =
                    v9;
                  (effectPure (Data.Either.Right.Either a'@v10)));
                v9
              ]])) (\i3@v9 -> 
                (((
                  bindExceptT1@v1
                ).bind let v10 =
                  (throwError1@v5 "error");
                if (< (add i1@v7 i2@v8) i3@v9) then
                  v10
                else
                  ((
                    applicativeExceptT1@v4
                  ).pure <PrimUndefined>)) (\$__unused@v10 -> 
                  ((
                    applicativeExceptT1@v4
                  ).pure (add (add (add 1 i1@v7) i2@v8) i3@v9))
                ))
              ))
            ))
          ))
        ));
      let v1 =
        v1;
      v1
    ]];
  v0
---------------
Snapshot.TransformerExceptT01.test2 (Step 2)
  let bindExceptT1@v0 =
    (Control.Monad.Except.Trans.bindExceptT Effect.monadEffect);
  [[ LetAssoc
    let Functor0@v1 =
      {#- Rewrite - Inline -#}
      let v1 =
        <PrimUndefined>;
      {#- Rewrite - Inline -#}
      let v2 =
        {#- Rewrite - Inline -#}
        let v2 =
          {#- Rewrite - Inline -#}
          let v2 =
            (
              Effect.bindEffect
            ).Apply0;
          (v2 <PrimUndefined>);
        (
          v2
        ).Functor0;
      (v2 <PrimUndefined>);
    let v1 =
      let apply1@v2 =
        (
          (Control.Monad.Except.Trans.applyExceptT Effect.monadEffect)
        ).apply;
      let applicativeExceptT1@v3 =
        (Control.Monad.Except.Trans.applicativeExceptT Effect.monadEffect);
      let throwError1@v4 =
        (
          (Control.Monad.Except.Trans.monadThrowExceptT Effect.monadEffect)
        ).throwError;
      (((
        bindExceptT1@v0
      ).bind (((
        Functor0@v1
      ).map Data.Either.Right) (Effect.Console.log "foo"))) (\$__unused@v5 -> 
        (((
          bindExceptT1@v0
        ).bind let v6 =
          ((Effect.Random.randomInt 1) 10);
        {#- Rewrite - Inline -#}
        let v7 =
          (effectDefer letEffect a'@v7 =
            v6;
          (effectPure (Data.Either.Right.Either a'@v7)));
        v7) (\i1@v6 -> 
          (((
            bindExceptT1@v0
          ).bind (((
            Functor0@v1
          ).map (\m@v7 -> 
            if (isTag Data.Either.Left m@v7) then
              (Data.Either.Left.Either (
                m@v7
              )#value0)
            else if (isTag Data.Either.Right m@v7) then
              (Data.Either.Right.Either (add (
                m@v7
              )#value0 4))
            else
              <PatternMatchFailure>
          )) (((
            Functor0@v1
          ).map (\m@v7 -> 
            if (isTag Data.Either.Left m@v7) then
              (Data.Either.Left.Either (
                m@v7
              )#value0)
            else if (isTag Data.Either.Right m@v7) then
              (Data.Either.Right.Either (add (
                m@v7
              )#value0 1))
            else
              <PatternMatchFailure>
          )) let v7 =
            ((Effect.Random.randomInt 1) 10);
          {#- Rewrite - Inline -#}
          let v8 =
            (effectDefer letEffect a'@v8 =
              v7;
            (effectPure (Data.Either.Right.Either a'@v8)));
          v8))) (\i2@v7 -> 
            (((
              bindExceptT1@v0
            ).bind ((apply1@v2 (((
              Functor0@v1
            ).map ((
              Data.Either.functorEither
            ).map Data.Semiring.intAdd)) let v8 =
              ((Effect.Random.randomInt 1) 10);
            {#- Rewrite - Inline -#}
            let v9 =
              (effectDefer letEffect a'@v9 =
                v8;
              (effectPure (Data.Either.Right.Either a'@v9)));
            v9)) let v8 =
              ((Effect.Random.randomInt 1) 10);
            {#- Rewrite - Inline -#}
            let v9 =
              (effectDefer letEffect a'@v9 =
                v8;
              (effectPure (Data.Either.Right.Either a'@v9)));
            v9)) (\i3@v8 -> 
              (((
                bindExceptT1@v0
              ).bind let v9 =
                (throwError1@v4 "error");
              if (< (add i1@v6 i2@v7) i3@v8) then
                v9
              else
                ((
                  applicativeExceptT1@v3
                ).pure <PrimUndefined>)) (\$__unused@v9 -> 
                ((
                  applicativeExceptT1@v3
                ).pure (add (add (add 1 i1@v6) i2@v7) i3@v8))
              ))
            ))
          ))
        ))
      ));
    v1
  ]]
---------------
Snapshot.TransformerExceptT01.test2 (Step 3)
  let bindExceptT1@v0 =
    (Control.Monad.Except.Trans.bindExceptT Effect.monadEffect);
  let Functor0@v1 =
    {#- Rewrite - Inline -#}
    let v1 =
      <PrimUndefined>;
    {#- Rewrite - Inline -#}
    let v2 =
      (
        Effect.applyEffect
      ).Functor0;
    (v2 <PrimUndefined>);
  [[ LetAssoc
    let apply1@v2 =
      (
        (Control.Monad.Except.Trans.applyExceptT Effect.monadEffect)
      ).apply;
    let v2 =
      let applicativeExceptT1@v3 =
        (Control.Monad.Except.Trans.applicativeExceptT Effect.monadEffect);
      let throwError1@v4 =
        (
          (Control.Monad.Except.Trans.monadThrowExceptT Effect.monadEffect)
        ).throwError;
      (((
        bindExceptT1@v0
      ).bind (((
        Functor0@v1
      ).map Data.Either.Right) (Effect.Console.log "foo"))) (\$__unused@v5 -> 
        (((
          bindExceptT1@v0
        ).bind let v6 =
          ((Effect.Random.randomInt 1) 10);
        (effectDefer letEffect a'@v7 =
          v6;
        (effectPure (Data.Either.Right.Either a'@v7)))) (\i1@v6 -> 
          (((
            bindExceptT1@v0
          ).bind (((
            Functor0@v1
          ).map (\m@v7 -> 
            if (isTag Data.Either.Left m@v7) then
              (Data.Either.Left.Either (
                m@v7
              )#value0)
            else if (isTag Data.Either.Right m@v7) then
              (Data.Either.Right.Either (add (
                m@v7
              )#value0 4))
            else
              <PatternMatchFailure>
          )) (((
            Functor0@v1
          ).map (\m@v7 -> 
            if (isTag Data.Either.Left m@v7) then
              (Data.Either.Left.Either (
                m@v7
              )#value0)
            else if (isTag Data.Either.Right m@v7) then
              (Data.Either.Right.Either (add (
                m@v7
              )#value0 1))
            else
              <PatternMatchFailure>
          )) let v7 =
            ((Effect.Random.randomInt 1) 10);
          (effectDefer letEffect a'@v8 =
            v7;
          (effectPure (Data.Either.Right.Either a'@v8)))))) (\i2@v7 -> 
            (((
              bindExceptT1@v0
            ).bind ((apply1@v2 (((
              Functor0@v1
            ).map ((
              Data.Either.functorEither
            ).map Data.Semiring.intAdd)) let v8 =
              ((Effect.Random.randomInt 1) 10);
            (effectDefer letEffect a'@v9 =
              v8;
            (effectPure (Data.Either.Right.Either a'@v9))))) let v8 =
              ((Effect.Random.randomInt 1) 10);
            (effectDefer letEffect a'@v9 =
              v8;
            (effectPure (Data.Either.Right.Either a'@v9))))) (\i3@v8 -> 
              (((
                bindExceptT1@v0
              ).bind let v9 =
                (throwError1@v4 "error");
              if (< (add i1@v6 i2@v7) i3@v8) then
                v9
              else
                ((
                  applicativeExceptT1@v3
                ).pure <PrimUndefined>)) (\$__unused@v9 -> 
                ((
                  applicativeExceptT1@v3
                ).pure (add (add (add 1 i1@v6) i2@v7) i3@v8))
              ))
            ))
          ))
        ))
      ));
    v2
  ]]
---------------
Snapshot.TransformerExceptT01.test2 (Step 4)
  let bindExceptT1@v0 =
    (Control.Monad.Except.Trans.bindExceptT Effect.monadEffect);
  {#- Rewrite - Inline -#}
  let Functor0@v1 =
    {#- Rewrite - Inline -#}
    let v1 =
      <PrimUndefined>;
    Effect.functorEffect;
  let apply1@v2 =
    (
      (Control.Monad.Except.Trans.applyExceptT Effect.monadEffect)
    ).apply;
  [[ LetAssoc
    let applicativeExceptT1@v3 =
      (Control.Monad.Except.Trans.applicativeExceptT Effect.monadEffect);
    let v3 =
      let throwError1@v4 =
        (
          (Control.Monad.Except.Trans.monadThrowExceptT Effect.monadEffect)
        ).throwError;
      (((
        bindExceptT1@v0
      ).bind (((
        Functor0@v1
      ).map Data.Either.Right) (Effect.Console.log "foo"))) (\$__unused@v5 -> 
        (((
          bindExceptT1@v0
        ).bind let v6 =
          ((Effect.Random.randomInt 1) 10);
        (effectDefer letEffect a'@v7 =
          v6;
        (effectPure (Data.Either.Right.Either a'@v7)))) (\i1@v6 -> 
          (((
            bindExceptT1@v0
          ).bind (((
            Functor0@v1
          ).map (\m@v7 -> 
            if (isTag Data.Either.Left m@v7) then
              (Data.Either.Left.Either (
                m@v7
              )#value0)
            else if (isTag Data.Either.Right m@v7) then
              (Data.Either.Right.Either (add (
                m@v7
              )#value0 4))
            else
              <PatternMatchFailure>
          )) (((
            Functor0@v1
          ).map (\m@v7 -> 
            if (isTag Data.Either.Left m@v7) then
              (Data.Either.Left.Either (
                m@v7
              )#value0)
            else if (isTag Data.Either.Right m@v7) then
              (Data.Either.Right.Either (add (
                m@v7
              )#value0 1))
            else
              <PatternMatchFailure>
          )) let v7 =
            ((Effect.Random.randomInt 1) 10);
          (effectDefer letEffect a'@v8 =
            v7;
          (effectPure (Data.Either.Right.Either a'@v8)))))) (\i2@v7 -> 
            (((
              bindExceptT1@v0
            ).bind ((apply1@v2 (((
              Functor0@v1
            ).map ((
              Data.Either.functorEither
            ).map Data.Semiring.intAdd)) let v8 =
              ((Effect.Random.randomInt 1) 10);
            (effectDefer letEffect a'@v9 =
              v8;
            (effectPure (Data.Either.Right.Either a'@v9))))) let v8 =
              ((Effect.Random.randomInt 1) 10);
            (effectDefer letEffect a'@v9 =
              v8;
            (effectPure (Data.Either.Right.Either a'@v9))))) (\i3@v8 -> 
              (((
                bindExceptT1@v0
              ).bind let v9 =
                (throwError1@v4 "error");
              if (< (add i1@v6 i2@v7) i3@v8) then
                v9
              else
                ((
                  applicativeExceptT1@v3
                ).pure <PrimUndefined>)) (\$__unused@v9 -> 
                ((
                  applicativeExceptT1@v3
                ).pure (add (add (add 1 i1@v6) i2@v7) i3@v8))
              ))
            ))
          ))
        ))
      ));
    v3
  ]]
---------------
Snapshot.TransformerExceptT01.test2 (Step 5)
  let bindExceptT1@v0 =
    (Control.Monad.Except.Trans.bindExceptT Effect.monadEffect);
  let apply1@v1 =
    (
      (Control.Monad.Except.Trans.applyExceptT Effect.monadEffect)
    ).apply;
  let applicativeExceptT1@v2 =
    (Control.Monad.Except.Trans.applicativeExceptT Effect.monadEffect);
  [[ LetAssoc
    let throwError1@v3 =
      (
        (Control.Monad.Except.Trans.monadThrowExceptT Effect.monadEffect)
      ).throwError;
    let v3 =
      (((
        bindExceptT1@v0
      ).bind let v4 =
        (Effect.Console.log "foo");
      (effectDefer letEffect a'@v5 =
        v4;
      (effectPure (Data.Either.Right.Either a'@v5)))) (\$__unused@v4 -> 
        (((
          bindExceptT1@v0
        ).bind let v5 =
          ((Effect.Random.randomInt 1) 10);
        (effectDefer letEffect a'@v6 =
          v5;
        (effectPure (Data.Either.Right.Either a'@v6)))) (\i1@v5 -> 
          (((
            bindExceptT1@v0
          ).bind {#- Rewrite - Inline -#}
          let v6 =
            (\m@v6 -> 
              if (isTag Data.Either.Left m@v6) then
                (Data.Either.Left.Either (
                  m@v6
                )#value0)
              else if (isTag Data.Either.Right m@v6) then
                (Data.Either.Right.Either (add (
                  m@v6
                )#value0 4))
              else
                <PatternMatchFailure>
            );
          {#- Rewrite - Inline -#}
          let v7 =
            (\a@v7 -> 
              (effectDefer letEffect a'@v8 =
                a@v7;
              (effectPure (v6 a'@v8)))
            );
          (v7 {#- Rewrite - Inline -#}
          let v8 =
            (\m@v8 -> 
              if (isTag Data.Either.Left m@v8) then
                (Data.Either.Left.Either (
                  m@v8
                )#value0)
              else if (isTag Data.Either.Right m@v8) then
                (Data.Either.Right.Either (add (
                  m@v8
                )#value0 1))
              else
                <PatternMatchFailure>
            );
          {#- Rewrite - Inline -#}
          let v9 =
            (\a@v9 -> 
              (effectDefer letEffect a'@v10 =
                a@v9;
              (effectPure (v8 a'@v10)))
            );
          (v9 let v10 =
            ((Effect.Random.randomInt 1) 10);
          (effectDefer letEffect a'@v11 =
            v10;
          (effectPure (Data.Either.Right.Either a'@v11)))))) (\i2@v6 -> 
            (((
              bindExceptT1@v0
            ).bind ((apply1@v1 {#- Rewrite - Inline -#}
            let v7 =
              ((
                Data.Either.functorEither
              ).map Data.Semiring.intAdd);
            {#- Rewrite - Inline -#}
            let v8 =
              (\a@v8 -> 
                (effectDefer letEffect a'@v9 =
                  a@v8;
                (effectPure (v7 a'@v9)))
              );
            (v8 let v9 =
              ((Effect.Random.randomInt 1) 10);
            (effectDefer letEffect a'@v10 =
              v9;
            (effectPure (Data.Either.Right.Either a'@v10))))) let v7 =
              ((Effect.Random.randomInt 1) 10);
            (effectDefer letEffect a'@v8 =
              v7;
            (effectPure (Data.Either.Right.Either a'@v8))))) (\i3@v7 -> 
              (((
                bindExceptT1@v0
              ).bind let v8 =
                (throwError1@v3 "error");
              if (< (add i1@v5 i2@v6) i3@v7) then
                v8
              else
                ((
                  applicativeExceptT1@v2
                ).pure <PrimUndefined>)) (\$__unused@v8 -> 
                ((
                  applicativeExceptT1@v2
                ).pure (add (add (add 1 i1@v5) i2@v6) i3@v7))
              ))
            ))
          ))
        ))
      ));
    v3
  ]]
---------------
Snapshot.TransformerExceptT01.test2 (Step 6)
  let bindExceptT1@v0 =
    (Control.Monad.Except.Trans.bindExceptT Effect.monadEffect);
  let apply1@v1 =
    (
      (Control.Monad.Except.Trans.applyExceptT Effect.monadEffect)
    ).apply;
  let applicativeExceptT1@v2 =
    (Control.Monad.Except.Trans.applicativeExceptT Effect.monadEffect);
  let throwError1@v3 =
    (
      (Control.Monad.Except.Trans.monadThrowExceptT Effect.monadEffect)
    ).throwError;
  {#- Rewrite - Inline -#}
  let v4 =
    (((
      bindExceptT1@v0
    ).bind let v4 =
      (Effect.Console.log "foo");
    (effectDefer letEffect a'@v5 =
      v4;
    (effectPure (Data.Either.Right.Either a'@v5)))) (\$__unused@v4 -> 
      (((
        bindExceptT1@v0
      ).bind let v5 =
        ((Effect.Random.randomInt 1) 10);
      (effectDefer letEffect a'@v6 =
        v5;
      (effectPure (Data.Either.Right.Either a'@v6)))) (\i1@v5 -> 
        (((
          bindExceptT1@v0
        ).bind [[ LetAssoc
          let v6 =
            ((Effect.Random.randomInt 1) 10);
          let v6 =
            (effectDefer letEffect a'@v7 =
              v6;
            (effectPure (Data.Either.Right.Either a'@v7)));
          let v6 =
            (effectDefer letEffect a'@v7 =
              v6;
            (effectPure if (isTag Data.Either.Left a'@v7) then
              (Data.Either.Left.Either (
                a'@v7
              )#value0)
            else if (isTag Data.Either.Right a'@v7) then
              (Data.Either.Right.Either (add (
                a'@v7
              )#value0 1))
            else
              <PatternMatchFailure>));
          (effectDefer letEffect a'@v7 =
            v6;
          (effectPure if (isTag Data.Either.Left a'@v7) then
            (Data.Either.Left.Either (
              a'@v7
            )#value0)
          else if (isTag Data.Either.Right a'@v7) then
            (Data.Either.Right.Either (add (
              a'@v7
            )#value0 4))
          else
            <PatternMatchFailure>))
        ]]) (\i2@v6 -> 
          (((
            bindExceptT1@v0
          ).bind ((apply1@v1 [[ LetAssoc
            let v7 =
              ((Effect.Random.randomInt 1) 10);
            let v7 =
              (effectDefer letEffect a'@v8 =
                v7;
              (effectPure (Data.Either.Right.Either a'@v8)));
            (effectDefer letEffect a'@v8 =
              v7;
            (effectPure if (isTag Data.Either.Left a'@v8) then
              (Data.Either.Left.Either (
                a'@v8
              )#value0)
            else if (isTag Data.Either.Right a'@v8) then
              (Data.Either.Right.Either let v9 =
                (
                  a'@v8
                )#value0;
              {#- Rewrite - Inline -#}
              let v10 =
                (\v10 -> 
                  (add v9 v10)
                );
              v10)
            else
              <PatternMatchFailure>))
          ]]) let v7 =
            ((Effect.Random.randomInt 1) 10);
          (effectDefer letEffect a'@v8 =
            v7;
          (effectPure (Data.Either.Right.Either a'@v8))))) (\i3@v7 -> 
            (((
              bindExceptT1@v0
            ).bind let v8 =
              (throwError1@v3 "error");
            if (< (add i1@v5 i2@v6) i3@v7) then
              v8
            else
              ((
                applicativeExceptT1@v2
              ).pure <PrimUndefined>)) (\$__unused@v8 -> 
              ((
                applicativeExceptT1@v2
              ).pure (add (add (add 1 i1@v5) i2@v6) i3@v7))
            ))
          ))
        ))
      ))
    ));
  v4
---------------
Snapshot.TransformerExceptT01.test2 (Step 7)
  let bindExceptT1@v0 =
    (Control.Monad.Except.Trans.bindExceptT Effect.monadEffect);
  let apply1@v1 =
    (
      (Control.Monad.Except.Trans.applyExceptT Effect.monadEffect)
    ).apply;
  let applicativeExceptT1@v2 =
    (Control.Monad.Except.Trans.applicativeExceptT Effect.monadEffect);
  let throwError1@v3 =
    (
      (Control.Monad.Except.Trans.monadThrowExceptT Effect.monadEffect)
    ).throwError;
  (((
    bindExceptT1@v0
  ).bind let v4 =
    (Effect.Console.log "foo");
  (effectDefer letEffect a'@v5 =
    v4;
  (effectPure (Data.Either.Right.Either a'@v5)))) (\$__unused@v4 -> 
    (((
      bindExceptT1@v0
    ).bind let v5 =
      ((Effect.Random.randomInt 1) 10);
    (effectDefer letEffect a'@v6 =
      v5;
    (effectPure (Data.Either.Right.Either a'@v6)))) (\i1@v5 -> 
      (((
        bindExceptT1@v0
      ).bind let v6 =
        ((Effect.Random.randomInt 1) 10);
      {#- Rewrite - Inline -#}
      let v7 =
        (effectDefer letEffect a'@v7 =
          v6;
        (effectPure (Data.Either.Right.Either a'@v7)));
      {#- Rewrite - Inline -#}
      let v8 =
        (effectDefer letEffect a'@v8 =
          v7;
        (effectPure if (isTag Data.Either.Left a'@v8) then
          (Data.Either.Left.Either (
            a'@v8
          )#value0)
        else if (isTag Data.Either.Right a'@v8) then
          (Data.Either.Right.Either (add (
            a'@v8
          )#value0 1))
        else
          <PatternMatchFailure>));
      (effectDefer letEffect a'@v9 =
        v8;
      (effectPure if (isTag Data.Either.Left a'@v9) then
        (Data.Either.Left.Either (
          a'@v9
        )#value0)
      else if (isTag Data.Either.Right a'@v9) then
        (Data.Either.Right.Either (add (
          a'@v9
        )#value0 4))
      else
        <PatternMatchFailure>))) (\i2@v6 -> 
        (((
          bindExceptT1@v0
        ).bind ((apply1@v1 let v7 =
          ((Effect.Random.randomInt 1) 10);
        {#- Rewrite - Inline -#}
        let v8 =
          (effectDefer letEffect a'@v8 =
            v7;
          (effectPure (Data.Either.Right.Either a'@v8)));
        (effectDefer letEffect a'@v9 =
          v8;
        (effectPure if (isTag Data.Either.Left a'@v9) then
          (Data.Either.Left.Either (
            a'@v9
          )#value0)
        else if (isTag Data.Either.Right a'@v9) then
          (Data.Either.Right.Either let v10 =
            (
              a'@v9
            )#value0;
          (\v11 -> 
            (add v10 v11)
          ))
        else
          <PatternMatchFailure>))) let v7 =
          ((Effect.Random.randomInt 1) 10);
        (effectDefer letEffect a'@v8 =
          v7;
        (effectPure (Data.Either.Right.Either a'@v8))))) (\i3@v7 -> 
          (((
            bindExceptT1@v0
          ).bind let v8 =
            (throwError1@v3 "error");
          if (< (add i1@v5 i2@v6) i3@v7) then
            v8
          else
            ((
              applicativeExceptT1@v2
            ).pure <PrimUndefined>)) (\$__unused@v8 -> 
            ((
              applicativeExceptT1@v2
            ).pure (add (add (add 1 i1@v5) i2@v6) i3@v7))
          ))
        ))
      ))
    ))
  ))
---------------
Snapshot.TransformerExceptT01.test2 (Step 8)
  let bindExceptT1@v0 =
    (Control.Monad.Except.Trans.bindExceptT Effect.monadEffect);
  let apply1@v1 =
    (
      (Control.Monad.Except.Trans.applyExceptT Effect.monadEffect)
    ).apply;
  let applicativeExceptT1@v2 =
    (Control.Monad.Except.Trans.applicativeExceptT Effect.monadEffect);
  let throwError1@v3 =
    (
      (Control.Monad.Except.Trans.monadThrowExceptT Effect.monadEffect)
    ).throwError;
  (((
    bindExceptT1@v0
  ).bind let v4 =
    (Effect.Console.log "foo");
  (effectDefer letEffect a'@v5 =
    v4;
  (effectPure (Data.Either.Right.Either a'@v5)))) (\$__unused@v4 -> 
    (((
      bindExceptT1@v0
    ).bind let v5 =
      ((Effect.Random.randomInt 1) 10);
    (effectDefer letEffect a'@v6 =
      v5;
    (effectPure (Data.Either.Right.Either a'@v6)))) (\i1@v5 -> 
      (((
        bindExceptT1@v0
      ).bind let v6 =
        ((Effect.Random.randomInt 1) 10);
      (effectDefer [[ EffectBindAssoc
        letEffect a'@v7 =
          v6;
        letEffect a'@v7 =
          (effectPure (Data.Either.Right.Either a'@v7));
        letEffect a'@v7 =
          (effectPure if (isTag Data.Either.Left a'@v7) then
            (Data.Either.Left.Either (
              a'@v7
            )#value0)
          else if (isTag Data.Either.Right a'@v7) then
            (Data.Either.Right.Either (add (
              a'@v7
            )#value0 1))
          else
            <PatternMatchFailure>);
        (effectPure if (isTag Data.Either.Left a'@v7) then
          (Data.Either.Left.Either (
            a'@v7
          )#value0)
        else if (isTag Data.Either.Right a'@v7) then
          (Data.Either.Right.Either (add (
            a'@v7
          )#value0 4))
        else
          <PatternMatchFailure>)
      ]])) (\i2@v6 -> 
        (((
          bindExceptT1@v0
        ).bind ((apply1@v1 let v7 =
          ((Effect.Random.randomInt 1) 10);
        (effectDefer [[ EffectBindAssoc
          letEffect a'@v8 =
            v7;
          letEffect a'@v8 =
            (effectPure (Data.Either.Right.Either a'@v8));
          (effectPure if (isTag Data.Either.Left a'@v8) then
            (Data.Either.Left.Either (
              a'@v8
            )#value0)
          else if (isTag Data.Either.Right a'@v8) then
            (Data.Either.Right.Either let v9 =
              (
                a'@v8
              )#value0;
            (\v10 -> 
              (add v9 v10)
            ))
          else
            <PatternMatchFailure>)
        ]])) let v7 =
          ((Effect.Random.randomInt 1) 10);
        (effectDefer letEffect a'@v8 =
          v7;
        (effectPure (Data.Either.Right.Either a'@v8))))) (\i3@v7 -> 
          (((
            bindExceptT1@v0
          ).bind let v8 =
            (throwError1@v3 "error");
          if (< (add i1@v5 i2@v6) i3@v7) then
            v8
          else
            ((
              applicativeExceptT1@v2
            ).pure <PrimUndefined>)) (\$__unused@v8 -> 
            ((
              applicativeExceptT1@v2
            ).pure (add (add (add 1 i1@v5) i2@v6) i3@v7))
          ))
        ))
      ))
    ))
  ))
---------------
Snapshot.TransformerExceptT01.test2 (Step 9)
  let bindExceptT1@v0 =
    (Control.Monad.Except.Trans.bindExceptT Effect.monadEffect);
  let apply1@v1 =
    (
      (Control.Monad.Except.Trans.applyExceptT Effect.monadEffect)
    ).apply;
  let applicativeExceptT1@v2 =
    (Control.Monad.Except.Trans.applicativeExceptT Effect.monadEffect);
  let throwError1@v3 =
    (
      (Control.Monad.Except.Trans.monadThrowExceptT Effect.monadEffect)
    ).throwError;
  (((
    bindExceptT1@v0
  ).bind let v4 =
    (Effect.Console.log "foo");
  (effectDefer letEffect a'@v5 =
    v4;
  (effectPure (Data.Either.Right.Either a'@v5)))) (\$__unused@v4 -> 
    (((
      bindExceptT1@v0
    ).bind let v5 =
      ((Effect.Random.randomInt 1) 10);
    (effectDefer letEffect a'@v6 =
      v5;
    (effectPure (Data.Either.Right.Either a'@v6)))) (\i1@v5 -> 
      (((
        bindExceptT1@v0
      ).bind let v6 =
        ((Effect.Random.randomInt 1) 10);
      (effectDefer letEffect a'@v7 =
        v6;
      {#- Rewrite - Inline -#}
      let a'@v8 =
        (Data.Either.Right.Either a'@v7);
      (effectDefer [[ DistBranchesLet
        let a'@v9 =
          if (isTag Data.Either.Left a'@v8) then
            (Data.Either.Left.Either (
              a'@v8
            )#value0)
          else if (isTag Data.Either.Right a'@v8) then
            (Data.Either.Right.Either (add (
              a'@v8
            )#value0 1))
          else
            <PatternMatchFailure>;
        (effectPure if (isTag Data.Either.Left a'@v9) then
          (Data.Either.Left.Either (
            a'@v9
          )#value0)
        else if (isTag Data.Either.Right a'@v9) then
          (Data.Either.Right.Either (add (
            a'@v9
          )#value0 4))
        else
          <PatternMatchFailure>)
      ]]))) (\i2@v6 -> 
        (((
          bindExceptT1@v0
        ).bind ((apply1@v1 let v7 =
          ((Effect.Random.randomInt 1) 10);
        (effectDefer letEffect a'@v8 =
          v7;
        {#- Rewrite - Inline -#}
        let a'@v9 =
          (Data.Either.Right.Either a'@v8);
        (effectPure if (isTag Data.Either.Left a'@v9) then
          (Data.Either.Left.Either (
            a'@v9
          )#value0)
        else if (isTag Data.Either.Right a'@v9) then
          (Data.Either.Right.Either let v10 =
            (
              a'@v9
            )#value0;
          (\v11 -> 
            (add v10 v11)
          ))
        else
          <PatternMatchFailure>))) let v7 =
          ((Effect.Random.randomInt 1) 10);
        (effectDefer letEffect a'@v8 =
          v7;
        (effectPure (Data.Either.Right.Either a'@v8))))) (\i3@v7 -> 
          (((
            bindExceptT1@v0
          ).bind let v8 =
            (throwError1@v3 "error");
          if (< (add i1@v5 i2@v6) i3@v7) then
            v8
          else
            ((
              applicativeExceptT1@v2
            ).pure <PrimUndefined>)) (\$__unused@v8 -> 
            ((
              applicativeExceptT1@v2
            ).pure (add (add (add 1 i1@v5) i2@v6) i3@v7))
          ))
        ))
      ))
    ))
  ))
---------------
Snapshot.TransformerExceptT01.test2 (Step 10; Final)
  let bindExceptT1@v0 =
    (Control.Monad.Except.Trans.bindExceptT Effect.monadEffect);
  let apply1@v1 =
    (
      (Control.Monad.Except.Trans.applyExceptT Effect.monadEffect)
    ).apply;
  let applicativeExceptT1@v2 =
    (Control.Monad.Except.Trans.applicativeExceptT Effect.monadEffect);
  let throwError1@v3 =
    (
      (Control.Monad.Except.Trans.monadThrowExceptT Effect.monadEffect)
    ).throwError;
  (((
    bindExceptT1@v0
  ).bind let v4 =
    (Effect.Console.log "foo");
  (effectDefer letEffect a'@v5 =
    v4;
  (effectPure (Data.Either.Right.Either a'@v5)))) (\$__unused@v4 -> 
    (((
      bindExceptT1@v0
    ).bind let v5 =
      ((Effect.Random.randomInt 1) 10);
    (effectDefer letEffect a'@v6 =
      v5;
    (effectPure (Data.Either.Right.Either a'@v6)))) (\i1@v5 -> 
      (((
        bindExceptT1@v0
      ).bind let v6 =
        ((Effect.Random.randomInt 1) 10);
      (effectDefer letEffect a'@v7 =
        v6;
      (effectPure (Data.Either.Right.Either (add a'@v7 5))))) (\i2@v6 -> 
        (((
          bindExceptT1@v0
        ).bind ((apply1@v1 let v7 =
          ((Effect.Random.randomInt 1) 10);
        (effectDefer letEffect a'@v8 =
          v7;
        (effectPure (Data.Either.Right.Either (\v9 -> 
          (add a'@v8 v9)
        ))))) let v7 =
          ((Effect.Random.randomInt 1) 10);
        (effectDefer letEffect a'@v8 =
          v7;
        (effectPure (Data.Either.Right.Either a'@v8))))) (\i3@v7 -> 
          (((
            bindExceptT1@v0
          ).bind let v8 =
            (throwError1@v3 "error");
          if (< (add i1@v5 i2@v6) i3@v7) then
            v8
          else
            ((
              applicativeExceptT1@v2
            ).pure <PrimUndefined>)) (\$__unused@v8 -> 
            ((
              applicativeExceptT1@v2
            ).pure (add (add (add 1 i1@v5) i2@v6) i3@v7))
          ))
        ))
      ))
    ))
  ))
===============
Snapshot.TransformerExceptT01.test3 (Step 0; Original)
  (Control.Monad.Except.Trans.runExceptT ((Snapshot.TransformerExceptT01.program2 Snapshot.TransformerExceptT01.monadThrowExceptT) (Control.Monad.Except.Trans.monadEffectExceptT Effect.Class.monadEffectEffect)))
---------------
Snapshot.TransformerExceptT01.test3 (Step 1)
  [[ LetAssoc
    let v0 =
      (Control.Monad.Except.Trans.monadEffectExceptT Effect.Class.monadEffectEffect);
    let v0 =
      [[ LetAssoc
        let Monad0@v1 =
          ((
            v0
          ).Monad0 <PrimUndefined>);
        let v1 =
          [[ LetAssoc
            let Bind1@v2 =
              ((
                Monad0@v1
              ).Bind1 <PrimUndefined>);
            let v2 =
              let Apply0@v3 =
                ((
                  Bind1@v2
                ).Apply0 <PrimUndefined>);
              let map3@v4 =
                (
                  ((
                    Apply0@v3
                  ).Functor0 <PrimUndefined>)
                ).map;
              let Applicative0@v5 =
                ((
                  Monad0@v1
                ).Applicative0 <PrimUndefined>);
              (((
                Bind1@v2
              ).bind ((
                v0
              ).liftEffect (Effect.Console.log "foo"))) (\$__unused@v6 -> 
                (((
                  Bind1@v2
                ).bind ((
                  v0
                ).liftEffect ((Effect.Random.randomInt 1) 10))) (\i1@v7 -> 
                  (((
                    Bind1@v2
                  ).bind ((map3@v4 (\v@v8 -> 
                    (add v@v8 4)
                  )) ((
                    v0
                  ).liftEffect ((Effect.Random.randomInt 1) 10)))) (\i2@v8 -> 
                    (((
                      Bind1@v2
                    ).bind (((
                      Apply0@v3
                    ).apply ((map3@v4 Data.Semiring.intAdd) ((
                      v0
                    ).liftEffect ((Effect.Random.randomInt 1) 10)))) ((
                      v0
                    ).liftEffect ((Effect.Random.randomInt 1) 10)))) (\i3@v9 -> 
                      (((
                        Bind1@v2
                      ).bind let v10 =
                        ((
                          Snapshot.TransformerExceptT01.monadThrowExceptT
                        ).throwError "error");
                      if (< (add i1@v7 i2@v8) i3@v9) then
                        v10
                      else
                        ((
                          Applicative0@v5
                        ).pure <PrimUndefined>)) (\$__unused@v10 -> 
                        ((
                          Applicative0@v5
                        ).pure (add (add (add 1 i1@v7) i2@v8) i3@v9))
                      ))
                    ))
                  ))
                ))
              ));
            v2
          ]];
        v1
      ]];
    v0
  ]]
---------------
Snapshot.TransformerExceptT01.test3 (Step 2)
  let v0 =
    (Control.Monad.Except.Trans.monadEffectExceptT Effect.Class.monadEffectEffect);
  [[ LetAssoc
    let Monad0@v1 =
      ((
        v0
      ).Monad0 <PrimUndefined>);
    let v1 =
      [[ LetAssoc
        let Bind1@v2 =
          ((
            Monad0@v1
          ).Bind1 <PrimUndefined>);
        let v2 =
          [[ LetAssoc
            let Apply0@v3 =
              ((
                Bind1@v2
              ).Apply0 <PrimUndefined>);
            let v3 =
              let map3@v4 =
                (
                  ((
                    Apply0@v3
                  ).Functor0 <PrimUndefined>)
                ).map;
              let Applicative0@v5 =
                ((
                  Monad0@v1
                ).Applicative0 <PrimUndefined>);
              (((
                Bind1@v2
              ).bind ((
                v0
              ).liftEffect (Effect.Console.log "foo"))) (\$__unused@v6 -> 
                (((
                  Bind1@v2
                ).bind ((
                  v0
                ).liftEffect ((Effect.Random.randomInt 1) 10))) (\i1@v7 -> 
                  (((
                    Bind1@v2
                  ).bind ((map3@v4 (\v@v8 -> 
                    (add v@v8 4)
                  )) ((
                    v0
                  ).liftEffect ((Effect.Random.randomInt 1) 10)))) (\i2@v8 -> 
                    (((
                      Bind1@v2
                    ).bind (((
                      Apply0@v3
                    ).apply ((map3@v4 Data.Semiring.intAdd) ((
                      v0
                    ).liftEffect ((Effect.Random.randomInt 1) 10)))) ((
                      v0
                    ).liftEffect ((Effect.Random.randomInt 1) 10)))) (\i3@v9 -> 
                      (((
                        Bind1@v2
                      ).bind let v10 =
                        ((
                          Snapshot.TransformerExceptT01.monadThrowExceptT
                        ).throwError "error");
                      if (< (add i1@v7 i2@v8) i3@v9) then
                        v10
                      else
                        ((
                          Applicative0@v5
                        ).pure <PrimUndefined>)) (\$__unused@v10 -> 
                        ((
                          Applicative0@v5
                        ).pure (add (add (add 1 i1@v7) i2@v8) i3@v9))
                      ))
                    ))
                  ))
                ))
              ));
            v3
          ]];
        v2
      ]];
    v1
  ]]
---------------
Snapshot.TransformerExceptT01.test3 (Step 3)
  let v0 =
    (Control.Monad.Except.Trans.monadEffectExceptT Effect.Class.monadEffectEffect);
  let Monad0@v1 =
    ((
      v0
    ).Monad0 <PrimUndefined>);
  [[ LetAssoc
    let Bind1@v2 =
      ((
        Monad0@v1
      ).Bind1 <PrimUndefined>);
    let v2 =
      [[ LetAssoc
        let Apply0@v3 =
          ((
            Bind1@v2
          ).Apply0 <PrimUndefined>);
        let v3 =
          [[ LetAssoc
            let map3@v4 =
              (
                ((
                  Apply0@v3
                ).Functor0 <PrimUndefined>)
              ).map;
            let v4 =
              let Applicative0@v5 =
                ((
                  Monad0@v1
                ).Applicative0 <PrimUndefined>);
              (((
                Bind1@v2
              ).bind ((
                v0
              ).liftEffect (Effect.Console.log "foo"))) (\$__unused@v6 -> 
                (((
                  Bind1@v2
                ).bind ((
                  v0
                ).liftEffect ((Effect.Random.randomInt 1) 10))) (\i1@v7 -> 
                  (((
                    Bind1@v2
                  ).bind ((map3@v4 (\v@v8 -> 
                    (add v@v8 4)
                  )) ((
                    v0
                  ).liftEffect ((Effect.Random.randomInt 1) 10)))) (\i2@v8 -> 
                    (((
                      Bind1@v2
                    ).bind (((
                      Apply0@v3
                    ).apply ((map3@v4 Data.Semiring.intAdd) ((
                      v0
                    ).liftEffect ((Effect.Random.randomInt 1) 10)))) ((
                      v0
                    ).liftEffect ((Effect.Random.randomInt 1) 10)))) (\i3@v9 -> 
                      (((
                        Bind1@v2
                      ).bind let v10 =
                        ((
                          Snapshot.TransformerExceptT01.monadThrowExceptT
                        ).throwError "error");
                      if (< (add i1@v7 i2@v8) i3@v9) then
                        v10
                      else
                        ((
                          Applicative0@v5
                        ).pure <PrimUndefined>)) (\$__unused@v10 -> 
                        ((
                          Applicative0@v5
                        ).pure (add (add (add 1 i1@v7) i2@v8) i3@v9))
                      ))
                    ))
                  ))
                ))
              ));
            v4
          ]];
        v3
      ]];
    v2
  ]]
---------------
Snapshot.TransformerExceptT01.test3 (Step 4)
  let v0 =
    (Control.Monad.Except.Trans.monadEffectExceptT Effect.Class.monadEffectEffect);
  let Monad0@v1 =
    ((
      v0
    ).Monad0 <PrimUndefined>);
  let Bind1@v2 =
    ((
      Monad0@v1
    ).Bind1 <PrimUndefined>);
  [[ LetAssoc
    let Apply0@v3 =
      ((
        Bind1@v2
      ).Apply0 <PrimUndefined>);
    let v3 =
      [[ LetAssoc
        let map3@v4 =
          (
            ((
              Apply0@v3
            ).Functor0 <PrimUndefined>)
          ).map;
        let v4 =
          [[ LetAssoc
            let Applicative0@v5 =
              ((
                Monad0@v1
              ).Applicative0 <PrimUndefined>);
            let v5 =
              (((
                Bind1@v2
              ).bind ((
                v0
              ).liftEffect (Effect.Console.log "foo"))) (\$__unused@v6 -> 
                (((
                  Bind1@v2
                ).bind ((
                  v0
                ).liftEffect ((Effect.Random.randomInt 1) 10))) (\i1@v7 -> 
                  (((
                    Bind1@v2
                  ).bind ((map3@v4 (\v@v8 -> 
                    (add v@v8 4)
                  )) ((
                    v0
                  ).liftEffect ((Effect.Random.randomInt 1) 10)))) (\i2@v8 -> 
                    (((
                      Bind1@v2
                    ).bind (((
                      Apply0@v3
                    ).apply ((map3@v4 Data.Semiring.intAdd) ((
                      v0
                    ).liftEffect ((Effect.Random.randomInt 1) 10)))) ((
                      v0
                    ).liftEffect ((Effect.Random.randomInt 1) 10)))) (\i3@v9 -> 
                      (((
                        Bind1@v2
                      ).bind let v10 =
                        ((
                          Snapshot.TransformerExceptT01.monadThrowExceptT
                        ).throwError "error");
                      if (< (add i1@v7 i2@v8) i3@v9) then
                        v10
                      else
                        ((
                          Applicative0@v5
                        ).pure <PrimUndefined>)) (\$__unused@v10 -> 
                        ((
                          Applicative0@v5
                        ).pure (add (add (add 1 i1@v7) i2@v8) i3@v9))
                      ))
                    ))
                  ))
                ))
              ));
            v5
          ]];
        v4
      ]];
    v3
  ]]
---------------
Snapshot.TransformerExceptT01.test3 (Step 5)
  let v0 =
    (Control.Monad.Except.Trans.monadEffectExceptT Effect.Class.monadEffectEffect);
  let Monad0@v1 =
    ((
      v0
    ).Monad0 <PrimUndefined>);
  let Bind1@v2 =
    ((
      Monad0@v1
    ).Bind1 <PrimUndefined>);
  let Apply0@v3 =
    ((
      Bind1@v2
    ).Apply0 <PrimUndefined>);
  [[ LetAssoc
    let map3@v4 =
      (
        ((
          Apply0@v3
        ).Functor0 <PrimUndefined>)
      ).map;
    let v4 =
      [[ LetAssoc
        let Applicative0@v5 =
          ((
            Monad0@v1
          ).Applicative0 <PrimUndefined>);
        let v5 =
          {#- Rewrite - Inline -#}
          let v6 =
            (((
              Bind1@v2
            ).bind ((
              v0
            ).liftEffect (Effect.Console.log "foo"))) (\$__unused@v6 -> 
              (((
                Bind1@v2
              ).bind ((
                v0
              ).liftEffect ((Effect.Random.randomInt 1) 10))) (\i1@v7 -> 
                (((
                  Bind1@v2
                ).bind ((map3@v4 (\v@v8 -> 
                  (add v@v8 4)
                )) ((
                  v0
                ).liftEffect ((Effect.Random.randomInt 1) 10)))) (\i2@v8 -> 
                  (((
                    Bind1@v2
                  ).bind (((
                    Apply0@v3
                  ).apply ((map3@v4 Data.Semiring.intAdd) ((
                    v0
                  ).liftEffect ((Effect.Random.randomInt 1) 10)))) ((
                    v0
                  ).liftEffect ((Effect.Random.randomInt 1) 10)))) (\i3@v9 -> 
                    (((
                      Bind1@v2
                    ).bind let v10 =
                      ((
                        Snapshot.TransformerExceptT01.monadThrowExceptT
                      ).throwError "error");
                    if (< (add i1@v7 i2@v8) i3@v9) then
                      v10
                    else
                      ((
                        Applicative0@v5
                      ).pure <PrimUndefined>)) (\$__unused@v10 -> 
                      ((
                        Applicative0@v5
                      ).pure (add (add (add 1 i1@v7) i2@v8) i3@v9))
                    ))
                  ))
                ))
              ))
            ));
          v6;
        v5
      ]];
    v4
  ]]
---------------
Snapshot.TransformerExceptT01.test3 (Step 6)
  let v0 =
    (Control.Monad.Except.Trans.monadEffectExceptT Effect.Class.monadEffectEffect);
  let Monad0@v1 =
    ((
      v0
    ).Monad0 <PrimUndefined>);
  let Bind1@v2 =
    ((
      Monad0@v1
    ).Bind1 <PrimUndefined>);
  let Apply0@v3 =
    ((
      Bind1@v2
    ).Apply0 <PrimUndefined>);
  let map3@v4 =
    (
      ((
        Apply0@v3
      ).Functor0 <PrimUndefined>)
    ).map;
  [[ LetAssoc
    let Applicative0@v5 =
      ((
        Monad0@v1
      ).Applicative0 <PrimUndefined>);
    let v5 =
      {#- Rewrite - Inline -#}
      let v6 =
        (((
          Bind1@v2
        ).bind ((
          v0
        ).liftEffect (Effect.Console.log "foo"))) (\$__unused@v6 -> 
          (((
            Bind1@v2
          ).bind ((
            v0
          ).liftEffect ((Effect.Random.randomInt 1) 10))) (\i1@v7 -> 
            (((
              Bind1@v2
            ).bind ((map3@v4 (\v@v8 -> 
              (add v@v8 4)
            )) ((
              v0
            ).liftEffect ((Effect.Random.randomInt 1) 10)))) (\i2@v8 -> 
              (((
                Bind1@v2
              ).bind (((
                Apply0@v3
              ).apply ((map3@v4 Data.Semiring.intAdd) ((
                v0
              ).liftEffect ((Effect.Random.randomInt 1) 10)))) ((
                v0
              ).liftEffect ((Effect.Random.randomInt 1) 10)))) (\i3@v9 -> 
                (((
                  Bind1@v2
                ).bind let v10 =
                  ((
                    Snapshot.TransformerExceptT01.monadThrowExceptT
                  ).throwError "error");
                if (< (add i1@v7 i2@v8) i3@v9) then
                  v10
                else
                  ((
                    Applicative0@v5
                  ).pure <PrimUndefined>)) (\$__unused@v10 -> 
                  ((
                    Applicative0@v5
                  ).pure (add (add (add 1 i1@v7) i2@v8) i3@v9))
                ))
              ))
            ))
          ))
        ));
      v6;
    v5
  ]]
---------------
Snapshot.TransformerExceptT01.test3 (Step 7)
  let v0 =
    (Control.Monad.Except.Trans.monadEffectExceptT Effect.Class.monadEffectEffect);
  let Monad0@v1 =
    ((
      v0
    ).Monad0 <PrimUndefined>);
  let Bind1@v2 =
    ((
      Monad0@v1
    ).Bind1 <PrimUndefined>);
  let Apply0@v3 =
    ((
      Bind1@v2
    ).Apply0 <PrimUndefined>);
  let map3@v4 =
    (
      ((
        Apply0@v3
      ).Functor0 <PrimUndefined>)
    ).map;
  let Applicative0@v5 =
    ((
      Monad0@v1
    ).Applicative0 <PrimUndefined>);
  {#- Rewrite - Inline -#}
  let v6 =
    (((
      Bind1@v2
    ).bind ((
      v0
    ).liftEffect (Effect.Console.log "foo"))) (\$__unused@v6 -> 
      (((
        Bind1@v2
      ).bind ((
        v0
      ).liftEffect ((Effect.Random.randomInt 1) 10))) (\i1@v7 -> 
        (((
          Bind1@v2
        ).bind ((map3@v4 (\v@v8 -> 
          (add v@v8 4)
        )) ((
          v0
        ).liftEffect ((Effect.Random.randomInt 1) 10)))) (\i2@v8 -> 
          (((
            Bind1@v2
          ).bind (((
            Apply0@v3
          ).apply ((map3@v4 Data.Semiring.intAdd) ((
            v0
          ).liftEffect ((Effect.Random.randomInt 1) 10)))) ((
            v0
          ).liftEffect ((Effect.Random.randomInt 1) 10)))) (\i3@v9 -> 
            (((
              Bind1@v2
            ).bind let v10 =
              ((
                Snapshot.TransformerExceptT01.monadThrowExceptT
              ).throwError "error");
            if (< (add i1@v7 i2@v8) i3@v9) then
              v10
            else
              ((
                Applicative0@v5
              ).pure <PrimUndefined>)) (\$__unused@v10 -> 
              ((
                Applicative0@v5
              ).pure (add (add (add 1 i1@v7) i2@v8) i3@v9))
            ))
          ))
        ))
      ))
    ));
  v6
---------------
Snapshot.TransformerExceptT01.test3 (Step 8; Final)
  let v0 =
    (Control.Monad.Except.Trans.monadEffectExceptT Effect.Class.monadEffectEffect);
  let Monad0@v1 =
    ((
      v0
    ).Monad0 <PrimUndefined>);
  let Bind1@v2 =
    ((
      Monad0@v1
    ).Bind1 <PrimUndefined>);
  let Apply0@v3 =
    ((
      Bind1@v2
    ).Apply0 <PrimUndefined>);
  let map3@v4 =
    (
      ((
        Apply0@v3
      ).Functor0 <PrimUndefined>)
    ).map;
  let Applicative0@v5 =
    ((
      Monad0@v1
    ).Applicative0 <PrimUndefined>);
  (((
    Bind1@v2
  ).bind ((
    v0
  ).liftEffect (Effect.Console.log "foo"))) (\$__unused@v6 -> 
    (((
      Bind1@v2
    ).bind ((
      v0
    ).liftEffect ((Effect.Random.randomInt 1) 10))) (\i1@v7 -> 
      (((
        Bind1@v2
      ).bind ((map3@v4 (\v@v8 -> 
        (add v@v8 4)
      )) ((
        v0
      ).liftEffect ((Effect.Random.randomInt 1) 10)))) (\i2@v8 -> 
        (((
          Bind1@v2
        ).bind (((
          Apply0@v3
        ).apply ((map3@v4 Data.Semiring.intAdd) ((
          v0
        ).liftEffect ((Effect.Random.randomInt 1) 10)))) ((
          v0
        ).liftEffect ((Effect.Random.randomInt 1) 10)))) (\i3@v9 -> 
          (((
            Bind1@v2
          ).bind let v10 =
            ((
              Snapshot.TransformerExceptT01.monadThrowExceptT
            ).throwError "error");
          if (< (add i1@v7 i2@v8) i3@v9) then
            v10
          else
            ((
              Applicative0@v5
            ).pure <PrimUndefined>)) (\$__unused@v10 -> 
            ((
              Applicative0@v5
            ).pure (add (add (add 1 i1@v7) i2@v8) i3@v9))
          ))
        ))
      ))
    ))
  ))
===============
Snapshot.TransformerExceptT01.throwError (Step 0; Original)
  (Control.Monad.Error.Class.throwError Snapshot.TransformerExceptT01.monadThrowExceptT)
---------------
Snapshot.TransformerExceptT01.throwError (Step 1; Final)
  (
    Snapshot.TransformerExceptT01.monadThrowExceptT
  ).throwError
===============
Snapshot.TransformerExceptT01.when (Step 0; Original)
  (Control.Applicative.when Snapshot.TransformerExceptT01.applicativeExceptT)
---------------
Snapshot.TransformerExceptT01.when (Step 1; Final)
  (\v@v0 -> \v1@v1 -> 
    if v@v0 then
      v1@v1
    else
      ((
        Snapshot.TransformerExceptT01.applicativeExceptT
      ).pure <PrimUndefined>)
  )
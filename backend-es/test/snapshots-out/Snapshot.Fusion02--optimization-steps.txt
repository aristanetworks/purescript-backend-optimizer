Snapshot.Fusion02.Unfold (Step 0; Original)
  letCtor Unfold =
    (\value0 value1 -> { tag: "Unfold", value0: value0, value1: value1 });
---------------
Snapshot.Fusion02.Unfold (Step 1; Final)
  letCtor Unfold =
    (\value0 value1 -> { tag: "Unfold", value0: value0, value1: value1 });

===============

Snapshot.Fusion02.add (Step 0; Original)
  (Data.Semiring.add Data.Semiring.semiringInt)
---------------
Snapshot.Fusion02.add (Step 1; Final)
  Data.Semiring.intAdd

===============

Snapshot.Fusion02.append (Step 0; Original)
  (Data.Semigroup.append Data.Semigroup.semigroupString)
---------------
Snapshot.Fusion02.append (Step 1; Final)
  Data.Semigroup.concatString

===============

Snapshot.Fusion02.compose (Step 0; Original)
  (Control.Semigroupoid.compose Control.Semigroupoid.semigroupoidFn)
---------------
Snapshot.Fusion02.compose (Step 1; Final)
  Control.Semigroupoid.semigroupoidFn.compose

===============

Snapshot.Fusion02.composeFlipped (Step 0; Original)
  (Control.Semigroupoid.composeFlipped Control.Semigroupoid.semigroupoidFn)
---------------
Snapshot.Fusion02.composeFlipped (Step 1; Final)
  (\f@v0 -> \g@v1 -> \x@v2 -> (g@v1 (f@v0 x@v2)))

===============

Snapshot.Fusion02.eq (Step 0; Original)
  (Data.Eq.eq Data.Eq.eqInt)
---------------
Snapshot.Fusion02.eq (Step 1; Final)
  Data.Eq.eqIntImpl

===============

Snapshot.Fusion02.filterMapU (Step 0; Original)
  (\f@v0 ->
    (Data.Exists.runExists
      (\v@v1 ->
        -- Inline v2
        let v2 = v@v1;
        -- Inline v3
        let v3 =
          (\s1@v3 step@v4 ->
            (Data.Exists.mkExists
              (Snapshot.Fusion02.Unfold
                s1@v3
                (\s2@v5 -> \nothing@v6 -> \just@v7 ->
                  letRec-8 loop@v8 =
                    (\s3@v9 ->
                      (step@v4
                        s3@v9
                        nothing@v6
                        (\s4@v10 -> \a@v11 ->
                          let v1@v12 = (f@v0 a@v11);
                          -- Inline v13
                          let v13 = v1@v12;
                          -- Inline v14
                          let v14 = (\-> (loop@v8 s4@v10));
                          -- Inline v15
                          let v15 = (\b@v15 -> ((just@v7 s4@v10) b@v15));
                          if (isTag Data.Maybe.Nothing v13) then
                            (v14!)
                          else if (isTag Data.Maybe.Just v13) then
                            -- Inline v16
                            let v16 = v13#value0;
                            (v15 b@v16)
                          else
                            <PatternMatchFailure>
                        )
                      )
                    );
                  (loop@v8 s2@v5)
                )
              )
            )
          );
        -- Inline v4
        let v4 = v2#value0;
        -- Inline v5
        let v5 = v2#value1;
        (v3 s1@v4 step@v5)
      )
    )
  )
---------------
Snapshot.Fusion02.filterMapU (Step 1)
  (\f@v0 -> \v@v1 ->
    -- Inline v2
    let v2 = v@v1#value0;
    -- Inline v3
    let v3 = v@v1#value1;
    (Snapshot.Fusion02.Unfold.Unfold'
      v2
      (\s2@v4 -> \nothing@v5 -> \just@v6 ->
        letRec-7 loop@v7 =
          (\s3@v8 ->
            (v3
              s3@v8
              nothing@v5
              (\s4@v9 -> \a@v10 ->
                let v1@v11 = (f@v0 a@v10);
                if (isTag Data.Maybe.Nothing v1@v11) then
                  (loop@v7 s4@v9)
                else if (isTag Data.Maybe.Just v1@v11) then
                  -- Inline v12
                  let v12 = v1@v11#value0;
                  ((just@v6 s4@v9) v12)
                else
                  <PatternMatchFailure>
              )
            )
          );
        (loop@v7 s2@v4)
      )
    )
  )
---------------
Snapshot.Fusion02.filterMapU (Step 2; Final)
  (\f@v0 -> \v@v1 ->
    (Snapshot.Fusion02.Unfold.Unfold'
      v@v1#value0
      (\s2@v2 -> \nothing@v3 -> \just@v4 ->
        letRec-5 loop@v5 =
          (\s3@v6 ->
            (v@v1#value1
              s3@v6
              nothing@v3
              (\s4@v7 -> \a@v8 ->
                let v1@v9 = (f@v0 a@v8);
                if (isTag Data.Maybe.Nothing v1@v9) then
                  (loop@v5 s4@v7)
                else if (isTag Data.Maybe.Just v1@v9) then
                  ((just@v4 s4@v7) v1@v9#value0)
                else
                  <PatternMatchFailure>
              )
            )
          );
        (loop@v5 s2@v2)
      )
    )
  )

===============

Snapshot.Fusion02.filterU (Step 0; Original)
  (\p@v0 ->
    (Snapshot.Fusion02.filterMapU
      (\a@v1 ->
        -- Inline v2
        let v2 = (p@v0 a@v1);
        -- Inline v3
        let v3 = (\-> (Data.Maybe.Just a@v1));
        -- Inline v4
        let v4 = (\-> Data.Maybe.Nothing);
        if ((eq v2) true) then (v3!) else (v4!)
      )
    )
  )
---------------
Snapshot.Fusion02.filterU (Step 1)
  (\p@v0 ->
    -- Inline v1
    let v1 =
      (\a@v1 ->
        if (p@v0 a@v1) then (Data.Maybe.Just.Maybe a@v1) else Data.Maybe.Nothing
      );
    -- Inline v2
    let v2 =
      (\v@v2 ->
        (Snapshot.Fusion02.Unfold.Unfold'
          v@v2#value0
          (\s2@v3 -> \nothing@v4 -> \just@v5 ->
            letRec-6 loop@v6 =
              (\s3@v7 ->
                (v@v2#value1
                  s3@v7
                  nothing@v4
                  (\s4@v8 -> \a@v9 ->
                    let v1@v10 = (v1 a@v9);
                    if (isTag Data.Maybe.Nothing v1@v10) then
                      (loop@v6 s4@v8)
                    else if (isTag Data.Maybe.Just v1@v10) then
                      ((just@v5 s4@v8) v1@v10#value0)
                    else
                      <PatternMatchFailure>
                  )
                )
              );
            (loop@v6 s2@v3)
          )
        )
      );
    v2
  )
---------------
Snapshot.Fusion02.filterU (Step 2)
  (\p@v0 -> \v@v1 ->
    (Snapshot.Fusion02.Unfold.Unfold'
      v@v1#value0
      (\s2@v2 -> \nothing@v3 -> \just@v4 ->
        letRec-5 loop@v5 =
          (\s3@v6 ->
            (v@v1#value1
              s3@v6
              nothing@v3
              (\s4@v7 -> \a@v8 ->
                -- DistBranchesLet v1@v9
                let v1@v9 =
                  if (p@v0 a@v8) then
                    (Data.Maybe.Just.Maybe a@v8)
                  else
                    Data.Maybe.Nothing;
                if (isTag Data.Maybe.Nothing v1@v9) then
                  (loop@v5 s4@v7)
                else if (isTag Data.Maybe.Just v1@v9) then
                  ((just@v4 s4@v7) v1@v9#value0)
                else
                  <PatternMatchFailure>
              )
            )
          );
        (loop@v5 s2@v2)
      )
    )
  )
---------------
Snapshot.Fusion02.filterU (Step 3; Final)
  (\p@v0 -> \v@v1 ->
    (Snapshot.Fusion02.Unfold.Unfold'
      v@v1#value0
      (\s2@v2 -> \nothing@v3 -> \just@v4 ->
        letRec-5 loop@v5 =
          (\s3@v6 ->
            (v@v1#value1
              s3@v6
              nothing@v3
              (\s4@v7 -> \a@v8 ->
                if (p@v0 a@v8) then ((just@v4 s4@v7) a@v8) else (loop@v5 s4@v7)
              )
            )
          );
        (loop@v5 s2@v2)
      )
    )
  )

===============

Snapshot.Fusion02.fromArray (Step 0; Original)
  (\arr@v0 ->
    (Data.Exists.mkExists
      (Snapshot.Fusion02.Unfold
        0
        (\ix@v1 -> \nothing@v2 -> \just@v3 ->
          -- Inline v4
          let v4 = ((Snapshot.Fusion02.eq ix@v1) (Data.Array.length arr@v0));
          -- Inline v5
          let v5 = (\-> (nothing@v2 Data.Unit.unit));
          -- Inline v6
          let v6 =
            (\->
              (just@v3
                ((Snapshot.Fusion02.add ix@v1) 1)
                (Partial.Unsafe.unsafePartial
                  (\$__unused@v6 -> Snapshot.Fusion02.unsafeIndex)
                  arr@v0
                  ix@v1
                )
              )
            );
          if ((eq v4) true) then (v5!) else (v6!)
        )
      )
    )
  )
---------------
Snapshot.Fusion02.fromArray (Step 1)
  (\arr@v0 ->
    (Snapshot.Fusion02.Unfold.Unfold'
      0
      (\ix@v1 -> \nothing@v2 -> \just@v3 ->
        if -- Inline v4
        let v4 = (arrayLength arr@v0);
        ((eq ix@v1) v4) then
          (nothing@v2 <PrimUndefined>)
        else
          (just@v3
            -- Inline v4
            let v4 = 1;
            ((add ix@v1) v4)
            ((arrayIndex arr@v0) ix@v1)
          )
      )
    )
  )
---------------
Snapshot.Fusion02.fromArray (Step 2; Final)
  (\arr@v0 ->
    (Snapshot.Fusion02.Unfold.Unfold'
      0
      (\ix@v1 -> \nothing@v2 -> \just@v3 ->
        if ((eq ix@v1) (arrayLength arr@v0)) then
          (nothing@v2 <PrimUndefined>)
        else
          ((just@v3 ((add ix@v1) 1)) ((arrayIndex arr@v0) ix@v1))
      )
    )
  )

===============

Snapshot.Fusion02.mapU (Step 0; Original)
  (\f@v0 ->
    (Data.Exists.runExists
      (\v@v1 ->
        -- Inline v2
        let v2 = v@v1;
        -- Inline v3
        let v3 =
          (\s1@v3 step@v4 ->
            (Data.Exists.mkExists
              (Snapshot.Fusion02.Unfold
                s1@v3
                (\s2@v5 -> \nothing@v6 -> \just@v7 ->
                  (step@v4
                    s2@v5
                    nothing@v6
                    (\s3@v8 -> \a@v9 -> ((just@v7 s3@v8) (f@v0 a@v9)))
                  )
                )
              )
            )
          );
        -- Inline v4
        let v4 = v2#value0;
        -- Inline v5
        let v5 = v2#value1;
        (v3 s1@v4 step@v5)
      )
    )
  )
---------------
Snapshot.Fusion02.mapU (Step 1)
  (\f@v0 -> \v@v1 ->
    -- Inline v2
    let v2 = v@v1#value0;
    -- Inline v3
    let v3 = v@v1#value1;
    (Snapshot.Fusion02.Unfold.Unfold'
      v2
      (\s2@v4 -> \nothing@v5 -> \just@v6 ->
        (v3
          s2@v4
          nothing@v5
          (\s3@v7 -> \a@v8 -> ((just@v6 s3@v7) (f@v0 a@v8)))
        )
      )
    )
  )
---------------
Snapshot.Fusion02.mapU (Step 2; Final)
  (\f@v0 -> \v@v1 ->
    (Snapshot.Fusion02.Unfold.Unfold'
      v@v1#value0
      (\s2@v2 -> \nothing@v3 -> \just@v4 ->
        (v@v1#value1
          s2@v2
          nothing@v3
          (\s3@v5 -> \a@v6 -> ((just@v4 s3@v5) (f@v0 a@v6)))
        )
      )
    )
  )

===============

Snapshot.Fusion02.notEq (Step 0; Original)
  (Data.Eq.notEq Data.Eq.eqString)
---------------
Snapshot.Fusion02.notEq (Step 1; Final)
  (\x@v0 -> \y@v1 -> ((notEq x@v0) y@v1))

===============

Snapshot.Fusion02.overArray (Step 0; Original)
  (\unfold@v0 ->
    (Snapshot.Fusion02.compose
      Snapshot.Fusion02.toArray
      ((Snapshot.Fusion02.compose unfold@v0) Snapshot.Fusion02.fromArray)
    )
  )
---------------
Snapshot.Fusion02.overArray (Step 1)
  (\unfold@v0 ->
    -- Inline v1
    let v1 =
      (\x@v1 ->
        (unfold@v0
          (Snapshot.Fusion02.Unfold.Unfold'
            0
            (\ix@v2 -> \nothing@v3 -> \just@v4 ->
              if ((eq ix@v2) (arrayLength x@v1)) then
                (nothing@v3 <PrimUndefined>)
              else
                ((just@v4 ((add ix@v2) 1)) ((arrayIndex x@v1) ix@v2))
            )
          )
        )
      );
    -- Inline v2
    let v2 =
      (\x@v2 ->
        let v3 = (v1 x@v2);
        -- Inline v4
        let v4 =
          letRec-4 loop@v4 =
            (\s2@v5 -> \acc@v6 ->
              (v3#value1
                s2@v5
                (\v1@v7 ->
                  (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v6))
                )
                (\s3@v7 -> \a@v8 ->
                  ((loop@v4 s3@v7) (Data.List.Types.Cons.List a@v8 acc@v6))
                )
              )
            );
          -- Inline v5
          let v5 = ((loop@v4 v3#value0) Data.List.Types.Nil);
          v5;
        v4
      );
    v2
  )
---------------
Snapshot.Fusion02.overArray (Step 2; Final)
  (\unfold@v0 -> \x@v1 ->
    let v2 =
      (unfold@v0
        (Snapshot.Fusion02.Unfold.Unfold'
          0
          (\ix@v2 -> \nothing@v3 -> \just@v4 ->
            if ((eq ix@v2) (arrayLength x@v1)) then
              (nothing@v3 <PrimUndefined>)
            else
              ((just@v4 ((add ix@v2) 1)) ((arrayIndex x@v1) ix@v2))
          )
        )
      );
    letRec-3 loop@v3 =
      (\s2@v4 -> \acc@v5 ->
        (v2#value1
          s2@v4
          (\v1@v6 ->
            (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v5))
          )
          (\s3@v6 -> \a@v7 ->
            ((loop@v3 s3@v6) (Data.List.Types.Cons.List a@v7 acc@v5))
          )
        )
      );
    ((loop@v3 v2#value0) Data.List.Types.Nil)
  )

===============

Snapshot.Fusion02.test (Step 0; Original)
  (Snapshot.Fusion02.overArray
    (Snapshot.Fusion02.composeFlipped
      (Snapshot.Fusion02.mapU (Snapshot.Fusion02.add 1))
      (Snapshot.Fusion02.composeFlipped
        (Snapshot.Fusion02.mapU (Data.Show.show Data.Show.showInt))
        (Snapshot.Fusion02.composeFlipped
          (Snapshot.Fusion02.filterMapU (Data.String.CodeUnits.stripPrefix "1"))
          (Snapshot.Fusion02.composeFlipped
            (Snapshot.Fusion02.mapU (Snapshot.Fusion02.append "2"))
            (Snapshot.Fusion02.composeFlipped
              (Snapshot.Fusion02.filterU
                (\v@v0 -> ((Snapshot.Fusion02.notEq v@v0) "wat"))
              )
              (Snapshot.Fusion02.mapU
                ((Data.Function.flip Snapshot.Fusion02.append) "1")
              )
            )
          )
        )
      )
    )
  )
---------------
Snapshot.Fusion02.test (Step 1)
  -- LetAssoc
  let v0 =
    let v0 =
      let v0 =
        -- Inline v0
        let v0 = 1;
        -- Inline v1
        let v1 = (\v1 -> ((add v0) v1));
        v1;
      -- Inline v1
      let v1 =
        (\v@v1 ->
          (Snapshot.Fusion02.Unfold.Unfold'
            v@v1#value0
            (\s2@v2 -> \nothing@v3 -> \just@v4 ->
              (v@v1#value1
                s2@v2
                nothing@v3
                (\s3@v5 -> \a@v6 -> ((just@v4 s3@v5) (v0 a@v6)))
              )
            )
          )
        );
      v1;
    let v1 =
      -- Inline v1
      let v1 =
        (\v@v1 ->
          (Snapshot.Fusion02.Unfold.Unfold'
            v@v1#value0
            (\s2@v2 -> \nothing@v3 -> \just@v4 ->
              (v@v1#value1
                s2@v2
                nothing@v3
                (\s3@v5 -> \a@v6 ->
                  ((just@v4 s3@v5) (Data.Show.showIntImpl a@v6))
                )
              )
            )
          )
        );
      -- LetAssoc
      let v2 =
        let v2 =
          -- Inline v2
          let v2 = (Data.String.CodeUnits.stripPrefix "1");
          -- Inline v3
          let v3 =
            (\v@v3 ->
              (Snapshot.Fusion02.Unfold.Unfold'
                v@v3#value0
                (\s2@v4 -> \nothing@v5 -> \just@v6 ->
                  letRec-7 loop@v7 =
                    (\s3@v8 ->
                      (v@v3#value1
                        s3@v8
                        nothing@v5
                        (\s4@v9 -> \a@v10 ->
                          let v1@v11 = (v2 a@v10);
                          if (isTag Data.Maybe.Nothing v1@v11) then
                            (loop@v7 s4@v9)
                          else if (isTag Data.Maybe.Just v1@v11) then
                            ((just@v6 s4@v9) v1@v11#value0)
                          else
                            <PatternMatchFailure>
                        )
                      )
                    );
                  (loop@v7 s2@v4)
                )
              )
            );
          v3;
        -- LetAssoc
        let v3 =
          let v3 =
            let v3 =
              -- Inline v3
              let v3 = "2";
              -- Inline v4
              let v4 = (\v4 -> ((stringAppend v3) v4));
              v4;
            -- Inline v4
            let v4 =
              (\v@v4 ->
                (Snapshot.Fusion02.Unfold.Unfold'
                  v@v4#value0
                  (\s2@v5 -> \nothing@v6 -> \just@v7 ->
                    (v@v4#value1
                      s2@v5
                      nothing@v6
                      (\s3@v8 -> \a@v9 -> ((just@v7 s3@v8) (v3 a@v9)))
                    )
                  )
                )
              );
            v4;
          -- LetAssoc
          let v4 =
            let v4 =
              -- Inline v4
              let v4 =
                (\v@v4 ->
                  -- Inline v5
                  let v5 = "wat";
                  ((notEq v@v4) v5)
                );
              -- Inline v5
              let v5 =
                (\v@v5 ->
                  (Snapshot.Fusion02.Unfold.Unfold'
                    v@v5#value0
                    (\s2@v6 -> \nothing@v7 -> \just@v8 ->
                      letRec-9 loop@v9 =
                        (\s3@v10 ->
                          (v@v5#value1
                            s3@v10
                            nothing@v7
                            (\s4@v11 -> \a@v12 ->
                              if (v4 a@v12) then
                                ((just@v8 s4@v11) a@v12)
                              else
                                (loop@v9 s4@v11)
                            )
                          )
                        );
                      (loop@v9 s2@v6)
                    )
                  )
                );
              v5;
            -- LetAssoc
            let v5 =
              let v5 =
                -- Inline v5
                let v5 = "1";
                (\a@v6 -> ((stringAppend a@v6) v5));
              -- Inline v6
              let v6 =
                (\v@v6 ->
                  (Snapshot.Fusion02.Unfold.Unfold'
                    v@v6#value0
                    (\s2@v7 -> \nothing@v8 -> \just@v9 ->
                      (v@v6#value1
                        s2@v7
                        nothing@v8
                        (\s3@v10 -> \a@v11 -> ((just@v9 s3@v10) (v5 a@v11)))
                      )
                    )
                  )
                );
              v6;
            (\x@v6 -> (v5 (v4 x@v6)));
          (\x@v5 -> (v4 (v3 x@v5)));
        (\x@v4 -> (v3 (v2 x@v4)));
      (\x@v3 -> (v2 (v1 x@v3)));
    (\x@v2 -> (v1 (v0 x@v2)));
  -- Inline v1
  let v1 =
    (\x@v1 ->
      let v2 =
        (v0
          (Snapshot.Fusion02.Unfold.Unfold'
            0
            (\ix@v2 -> \nothing@v3 -> \just@v4 ->
              if ((eq ix@v2) (arrayLength x@v1)) then
                (nothing@v3 <PrimUndefined>)
              else
                ((just@v4 ((add ix@v2) 1)) ((arrayIndex x@v1) ix@v2))
            )
          )
        );
      letRec-3 loop@v3 =
        (\s2@v4 -> \acc@v5 ->
          (v2#value1
            s2@v4
            (\v1@v6 ->
              (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v5))
            )
            (\s3@v6 -> \a@v7 ->
              ((loop@v3 s3@v6) (Data.List.Types.Cons.List a@v7 acc@v5))
            )
          )
        );
      ((loop@v3 v2#value0) Data.List.Types.Nil)
    );
  v1
---------------
Snapshot.Fusion02.test (Step 2)
  -- Inline v0
  let v0 = (\v0 -> ((add 1) v0));
  -- Inline v1
  let v1 =
    (\v@v1 ->
      (Snapshot.Fusion02.Unfold.Unfold'
        v@v1#value0
        (\s2@v2 -> \nothing@v3 -> \just@v4 ->
          (v@v1#value1
            s2@v2
            nothing@v3
            (\s3@v5 -> \a@v6 -> ((just@v4 s3@v5) (v0 a@v6)))
          )
        )
      )
    );
  -- LetAssoc
  let v2 =
    let v2 =
      -- Inline v2
      let v2 =
        (\v@v2 ->
          (Snapshot.Fusion02.Unfold.Unfold'
            v@v2#value0
            (\s2@v3 -> \nothing@v4 -> \just@v5 ->
              letRec-6 loop@v6 =
                (\s3@v7 ->
                  (v@v2#value1
                    s3@v7
                    nothing@v4
                    (\s4@v8 -> \a@v9 ->
                      let v1@v10 =
                        ((Data.String.CodeUnits.stripPrefix "1") a@v9);
                      if (isTag Data.Maybe.Nothing v1@v10) then
                        (loop@v6 s4@v8)
                      else if (isTag Data.Maybe.Just v1@v10) then
                        ((just@v5 s4@v8) v1@v10#value0)
                      else
                        <PatternMatchFailure>
                    )
                  )
                );
              (loop@v6 s2@v3)
            )
          )
        );
      let v3 =
        -- Inline v3
        let v3 = (\v3 -> ((stringAppend "2") v3));
        -- Inline v4
        let v4 =
          (\v@v4 ->
            (Snapshot.Fusion02.Unfold.Unfold'
              v@v4#value0
              (\s2@v5 -> \nothing@v6 -> \just@v7 ->
                (v@v4#value1
                  s2@v5
                  nothing@v6
                  (\s3@v8 -> \a@v9 -> ((just@v7 s3@v8) (v3 a@v9)))
                )
              )
            )
          );
        let v5 =
          -- Inline v5
          let v5 =
            (\v@v5 ->
              (Snapshot.Fusion02.Unfold.Unfold'
                v@v5#value0
                (\s2@v6 -> \nothing@v7 -> \just@v8 ->
                  letRec-9 loop@v9 =
                    (\s3@v10 ->
                      (v@v5#value1
                        s3@v10
                        nothing@v7
                        (\s4@v11 -> \a@v12 ->
                          if ((notEq a@v12) "wat") then
                            ((just@v8 s4@v11) a@v12)
                          else
                            (loop@v9 s4@v11)
                        )
                      )
                    );
                  (loop@v9 s2@v6)
                )
              )
            );
          let v6 =
            -- Inline v6
            let v6 = (\a@v6 -> ((stringAppend a@v6) "1"));
            -- Inline v7
            let v7 =
              (\v@v7 ->
                (Snapshot.Fusion02.Unfold.Unfold'
                  v@v7#value0
                  (\s2@v8 -> \nothing@v9 -> \just@v10 ->
                    (v@v7#value1
                      s2@v8
                      nothing@v9
                      (\s3@v11 -> \a@v12 -> ((just@v10 s3@v11) (v6 a@v12)))
                    )
                  )
                )
              );
            (\x@v8 -> (v7 (v5 x@v8)));
          (\x@v7 -> (v6 (v4 x@v7)));
        (\x@v6 -> (v5 (v2 x@v6)));
      (\x@v4 ->
        (v3
          (Snapshot.Fusion02.Unfold.Unfold'
            x@v4#value0
            (\s2@v5 -> \nothing@v6 -> \just@v7 ->
              (x@v4#value1
                s2@v5
                nothing@v6
                (\s3@v8 -> \a@v9 ->
                  ((just@v7 s3@v8) (Data.Show.showIntImpl a@v9))
                )
              )
            )
          )
        )
      );
    (\x@v3 -> (v2 (v1 x@v3)));
  (\x@v3 ->
    let v4 =
      (v2
        (Snapshot.Fusion02.Unfold.Unfold'
          0
          (\ix@v4 -> \nothing@v5 -> \just@v6 ->
            if ((eq ix@v4) (arrayLength x@v3)) then
              (nothing@v5 <PrimUndefined>)
            else
              ((just@v6 ((add ix@v4) 1)) ((arrayIndex x@v3) ix@v4))
          )
        )
      );
    letRec-5 loop@v5 =
      (\s2@v6 -> \acc@v7 ->
        (v4#value1
          s2@v6
          (\v1@v8 ->
            (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v7))
          )
          (\s3@v8 -> \a@v9 ->
            ((loop@v5 s3@v8) (Data.List.Types.Cons.List a@v9 acc@v7))
          )
        )
      );
    ((loop@v5 v4#value0) Data.List.Types.Nil)
  )
---------------
Snapshot.Fusion02.test (Step 3)
  -- LetAssoc
  let v0 =
    let v0 =
      let v0 =
        -- Inline v0
        let v0 =
          (\x@v0 ->
            -- UnpackOp v1 Data Unfold'
            let v1 =
              (Snapshot.Fusion02.Unfold.Unfold'
                x@v0#value0
                (\s2@v1 -> \nothing@v2 -> \just@v3 ->
                  letRec-4 loop@v4 =
                    (\s3@v5 ->
                      (x@v0#value1
                        s3@v5
                        nothing@v2
                        (\s4@v6 -> \a@v7 ->
                          if ((notEq a@v7) "wat") then
                            ((just@v3 s4@v6) a@v7)
                          else
                            (loop@v4 s4@v6)
                        )
                      )
                    );
                  (loop@v4 s2@v1)
                )
              );
            (Snapshot.Fusion02.Unfold.Unfold'
              v1#value0
              (\s2@v2 -> \nothing@v3 -> \just@v4 ->
                (v1#value1
                  s2@v2
                  nothing@v3
                  (\s3@v5 -> \a@v6 ->
                    ((just@v4 s3@v5) ((stringAppend a@v6) "1"))
                  )
                )
              )
            )
          );
        (\x@v1 ->
          (v0
            (Snapshot.Fusion02.Unfold.Unfold'
              x@v1#value0
              (\s2@v2 -> \nothing@v3 -> \just@v4 ->
                (x@v1#value1
                  s2@v2
                  nothing@v3
                  (\s3@v5 -> \a@v6 ->
                    ((just@v4 s3@v5) ((stringAppend "2") a@v6))
                  )
                )
              )
            )
          )
        );
      (\x@v1 ->
        (v0
          (Snapshot.Fusion02.Unfold.Unfold'
            x@v1#value0
            (\s2@v2 -> \nothing@v3 -> \just@v4 ->
              letRec-5 loop@v5 =
                (\s3@v6 ->
                  (x@v1#value1
                    s3@v6
                    nothing@v3
                    (\s4@v7 -> \a@v8 ->
                      let v1@v9 =
                        ((Data.String.CodeUnits.stripPrefix "1") a@v8);
                      if (isTag Data.Maybe.Nothing v1@v9) then
                        (loop@v5 s4@v7)
                      else if (isTag Data.Maybe.Just v1@v9) then
                        ((just@v4 s4@v7) v1@v9#value0)
                      else
                        <PatternMatchFailure>
                    )
                  )
                );
              (loop@v5 s2@v2)
            )
          )
        )
      );
    (\x@v1 ->
      (v0
        (Snapshot.Fusion02.Unfold.Unfold'
          x@v1#value0
          (\s2@v2 -> \nothing@v3 -> \just@v4 ->
            (x@v1#value1
              s2@v2
              nothing@v3
              (\s3@v5 -> \a@v6 ->
                ((just@v4 s3@v5) (Data.Show.showIntImpl a@v6))
              )
            )
          )
        )
      )
    );
  -- Inline v1
  let v1 =
    (\x@v1 ->
      (v0
        (Snapshot.Fusion02.Unfold.Unfold'
          x@v1#value0
          (\s2@v2 -> \nothing@v3 -> \just@v4 ->
            (x@v1#value1
              s2@v2
              nothing@v3
              (\s3@v5 -> \a@v6 -> ((just@v4 s3@v5) ((add 1) a@v6)))
            )
          )
        )
      )
    );
  (\x@v2 ->
    let v3 =
      (v1
        (Snapshot.Fusion02.Unfold.Unfold'
          0
          (\ix@v3 -> \nothing@v4 -> \just@v5 ->
            if ((eq ix@v3) (arrayLength x@v2)) then
              (nothing@v4 <PrimUndefined>)
            else
              ((just@v5 ((add ix@v3) 1)) ((arrayIndex x@v2) ix@v3))
          )
        )
      );
    letRec-4 loop@v4 =
      (\s2@v5 -> \acc@v6 ->
        (v3#value1
          s2@v5
          (\v1@v7 ->
            (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v6))
          )
          (\s3@v7 -> \a@v8 ->
            ((loop@v4 s3@v7) (Data.List.Types.Cons.List a@v8 acc@v6))
          )
        )
      );
    ((loop@v4 v3#value0) Data.List.Types.Nil)
  )
---------------
Snapshot.Fusion02.test (Step 4)
  -- Inline v0
  let v0 =
    (\x@v0 ->
      -- UnpackOp v1 Data Unfold'
      let v1 =
        (Snapshot.Fusion02.Unfold.Unfold'
          x@v0#value0
          (\s2@v1 -> \nothing@v2 -> \just@v3 ->
            (x@v0#value1
              s2@v1
              nothing@v2
              (\s3@v4 -> \a@v5 -> ((just@v3 s3@v4) ((stringAppend "2") a@v5)))
            )
          )
        );
      -- Inline v2
      let v2 = v1#value0;
      -- Inline v3
      let v3 =
        -- Inline v3
        let v3 =
          (\s2@v3 -> \nothing@v4 -> \just@v5 ->
            letRec-6 loop@v6 =
              (\s3@v7 ->
                (v1#value1
                  s3@v7
                  nothing@v4
                  (\s4@v8 -> \a@v9 ->
                    if ((notEq a@v9) "wat") then
                      ((just@v5 s4@v8) a@v9)
                    else
                      (loop@v6 s4@v8)
                  )
                )
              );
            (loop@v6 s2@v3)
          );
        (Snapshot.Fusion02.Unfold.Unfold'
          v2
          (\s2@v4 -> \nothing@v5 -> \just@v6 ->
            (v3
              s2@v4
              nothing@v5
              (\s3@v7 -> \a@v8 -> ((just@v6 s3@v7) ((stringAppend a@v8) "1")))
            )
          )
        );
      v3
    );
  -- Inline v1
  let v1 =
    (\x@v1 ->
      (v0
        (Snapshot.Fusion02.Unfold.Unfold'
          x@v1#value0
          (\s2@v2 -> \nothing@v3 -> \just@v4 ->
            letRec-5 loop@v5 =
              (\s3@v6 ->
                (x@v1#value1
                  s3@v6
                  nothing@v3
                  (\s4@v7 -> \a@v8 ->
                    let v1@v9 = ((Data.String.CodeUnits.stripPrefix "1") a@v8);
                    if (isTag Data.Maybe.Nothing v1@v9) then
                      (loop@v5 s4@v7)
                    else if (isTag Data.Maybe.Just v1@v9) then
                      ((just@v4 s4@v7) v1@v9#value0)
                    else
                      <PatternMatchFailure>
                  )
                )
              );
            (loop@v5 s2@v2)
          )
        )
      )
    );
  -- Inline v2
  let v2 =
    (\x@v2 ->
      (v1
        (Snapshot.Fusion02.Unfold.Unfold'
          x@v2#value0
          (\s2@v3 -> \nothing@v4 -> \just@v5 ->
            (x@v2#value1
              s2@v3
              nothing@v4
              (\s3@v6 -> \a@v7 ->
                ((just@v5 s3@v6) (Data.Show.showIntImpl a@v7))
              )
            )
          )
        )
      )
    );
  (\x@v3 ->
    let v4 =
      -- UnpackOp v4 Data Unfold'
      let v4 =
        (Snapshot.Fusion02.Unfold.Unfold'
          0
          (\ix@v4 -> \nothing@v5 -> \just@v6 ->
            if ((eq ix@v4) (arrayLength x@v3)) then
              (nothing@v5 <PrimUndefined>)
            else
              ((just@v6 ((add ix@v4) 1)) ((arrayIndex x@v3) ix@v4))
          )
        );
      (v2
        (Snapshot.Fusion02.Unfold.Unfold'
          v4#value0
          (\s2@v5 -> \nothing@v6 -> \just@v7 ->
            (v4#value1
              s2@v5
              nothing@v6
              (\s3@v8 -> \a@v9 -> ((just@v7 s3@v8) ((add 1) a@v9)))
            )
          )
        )
      );
    letRec-5 loop@v5 =
      (\s2@v6 -> \acc@v7 ->
        (v4#value1
          s2@v6
          (\v1@v8 ->
            (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v7))
          )
          (\s3@v8 -> \a@v9 ->
            ((loop@v5 s3@v8) (Data.List.Types.Cons.List a@v9 acc@v7))
          )
        )
      );
    ((loop@v5 v4#value0) Data.List.Types.Nil)
  )
---------------
Snapshot.Fusion02.test (Step 5)
  (\x@v0 ->
    let v1 =
      -- Inline v1
      let v1 = 0;
      -- Inline v2
      let v2 =
        (\ix@v2 -> \nothing@v3 -> \just@v4 ->
          if ((eq ix@v2) (arrayLength x@v0)) then
            (nothing@v3 <PrimUndefined>)
          else
            ((just@v4 ((add ix@v2) 1)) ((arrayIndex x@v0) ix@v2))
        );
      -- UnpackOp v3 Data Unfold'
      let v3 =
        (Snapshot.Fusion02.Unfold.Unfold'
          v1
          (\s2@v3 -> \nothing@v4 -> \just@v5 ->
            (v2
              s2@v3
              nothing@v4
              (\s3@v6 -> \a@v7 -> ((just@v5 s3@v6) ((add 1) a@v7)))
            )
          )
        );
      -- UnpackOp v4 Data Unfold'
      let v4 =
        (Snapshot.Fusion02.Unfold.Unfold'
          v3#value0
          (\s2@v4 -> \nothing@v5 -> \just@v6 ->
            (v3#value1
              s2@v4
              nothing@v5
              (\s3@v7 -> \a@v8 ->
                ((just@v6 s3@v7) (Data.Show.showIntImpl a@v8))
              )
            )
          )
        );
      -- Inline v5
      let v5 =
        -- UnpackOp v5 Data Unfold'
        let v5 =
          (Snapshot.Fusion02.Unfold.Unfold'
            v4#value0
            (\s2@v5 -> \nothing@v6 -> \just@v7 ->
              letRec-8 loop@v8 =
                (\s3@v9 ->
                  (v4#value1
                    s3@v9
                    nothing@v6
                    (\s4@v10 -> \a@v11 ->
                      let v1@v12 =
                        ((Data.String.CodeUnits.stripPrefix "1") a@v11);
                      if (isTag Data.Maybe.Nothing v1@v12) then
                        (loop@v8 s4@v10)
                      else if (isTag Data.Maybe.Just v1@v12) then
                        ((just@v7 s4@v10) v1@v12#value0)
                      else
                        <PatternMatchFailure>
                    )
                  )
                );
              (loop@v8 s2@v5)
            )
          );
        -- Inline v6
        let v6 =
          -- Inline v6
          let v6 = v5#value0;
          -- Inline v7
          let v7 =
            -- Inline v7
            let v7 =
              (\s2@v7 -> \nothing@v8 -> \just@v9 ->
                (v5#value1
                  s2@v7
                  nothing@v8
                  (\s3@v10 -> \a@v11 ->
                    ((just@v9 s3@v10) ((stringAppend "2") a@v11))
                  )
                )
              );
            (Snapshot.Fusion02.Unfold.Unfold'
              v6
              (\s2@v8 -> \nothing@v9 -> \just@v10 ->
                -- Inline v11
                let v11 =
                  (\s3@v11 -> \a@v12 ->
                    ((just@v10 s3@v11) ((stringAppend a@v12) "1"))
                  );
                letRec-12 loop@v12 =
                  (\s3@v13 ->
                    (v7
                      s3@v13
                      nothing@v9
                      (\s4@v14 -> \a@v15 ->
                        if ((notEq a@v15) "wat") then
                          ((v11 s4@v14) a@v15)
                        else
                          (loop@v12 s4@v14)
                      )
                    )
                  );
                -- Inline v13
                let v13 = (loop@v12 s2@v8);
                v13
              )
            );
          v7;
        v6;
      v5;
    letRec-2 loop@v2 =
      (\s2@v3 -> \acc@v4 ->
        (v1#value1
          s2@v3
          (\v1@v5 ->
            (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v4))
          )
          (\s3@v5 -> \a@v6 ->
            ((loop@v2 s3@v5) (Data.List.Types.Cons.List a@v6 acc@v4))
          )
        )
      );
    ((loop@v2 v1#value0) Data.List.Types.Nil)
  )
---------------
Snapshot.Fusion02.test (Step 6)
  (\x@v0 ->
    let v1 =
      -- Inline v1
      let v1 = 0;
      -- Inline v2
      let v2 =
        (\s2@v2 -> \nothing@v3 -> \just@v4 ->
          -- Inline v5
          let v5 = (\s3@v5 -> \a@v6 -> ((just@v4 s3@v5) ((add 1) a@v6)));
          if ((eq s2@v2) (arrayLength x@v0)) then
            (nothing@v3 <PrimUndefined>)
          else
            ((v5 ((add s2@v2) 1)) ((arrayIndex x@v0) s2@v2))
        );
      -- Inline v3
      let v3 =
        (\s2@v3 -> \nothing@v4 -> \just@v5 ->
          (v2
            s2@v3
            nothing@v4
            (\s3@v6 -> \a@v7 -> ((just@v5 s3@v6) (Data.Show.showIntImpl a@v7)))
          )
        );
      -- Inline v4
      let v4 =
        (\s2@v4 -> \nothing@v5 -> \just@v6 ->
          letRec-7 loop@v7 =
            (\s3@v8 ->
              (v3
                s3@v8
                nothing@v5
                (\s4@v9 -> \a@v10 ->
                  let v1@v11 = ((Data.String.CodeUnits.stripPrefix "1") a@v10);
                  if (isTag Data.Maybe.Nothing v1@v11) then
                    (loop@v7 s4@v9)
                  else if (isTag Data.Maybe.Just v1@v11) then
                    ((just@v6 s4@v9) v1@v11#value0)
                  else
                    <PatternMatchFailure>
                )
              )
            );
          (loop@v7 s2@v4)
        );
      (Snapshot.Fusion02.Unfold.Unfold'
        v1
        (\s2@v5 -> \nothing@v6 -> \just@v7 ->
          letRec-8 loop@v8 =
            (\s3@v9 ->
              -- Inline v10
              let v10 =
                (\s4@v10 -> \a@v11 ->
                  if ((notEq a@v11) "wat") then
                    ((just@v7 s4@v10) ((stringAppend a@v11) "1"))
                  else
                    (loop@v8 s4@v10)
                );
              (v4
                s3@v9
                nothing@v6
                (\s3@v11 -> \a@v12 -> ((v10 s3@v11) ((stringAppend "2") a@v12)))
              )
            );
          (loop@v8 s2@v5)
        )
      );
    letRec-2 loop@v2 =
      (\s2@v3 -> \acc@v4 ->
        (v1#value1
          s2@v3
          (\v1@v5 ->
            (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v4))
          )
          (\s3@v5 -> \a@v6 ->
            ((loop@v2 s3@v5) (Data.List.Types.Cons.List a@v6 acc@v4))
          )
        )
      );
    ((loop@v2 v1#value0) Data.List.Types.Nil)
  )
---------------
Snapshot.Fusion02.test (Step 7)
  (\x@v0 ->
    -- UnpackOp v1 Data Unfold'
    let v1 =
      (Snapshot.Fusion02.Unfold.Unfold'
        0
        (\s2@v1 -> \nothing@v2 -> \just@v3 ->
          letRec-4 loop@v4 =
            (\s3@v5 ->
              -- Inline v6
              let v6 =
                (\s3@v6 -> \a@v7 ->
                  let v8 = ((stringAppend "2") a@v7);
                  if ((notEq v8) "wat") then
                    ((just@v3 s3@v6) ((stringAppend v8) "1"))
                  else
                    (loop@v4 s3@v6)
                );
              letRec-7 loop@v7 =
                (\s3@v8 ->
                  -- Inline v9
                  let v9 =
                    (\s4@v9 -> \a@v10 ->
                      let v1@v11 =
                        ((Data.String.CodeUnits.stripPrefix "1") a@v10);
                      if (isTag Data.Maybe.Nothing v1@v11) then
                        (loop@v7 s4@v9)
                      else if (isTag Data.Maybe.Just v1@v11) then
                        ((v6 s4@v9) v1@v11#value0)
                      else
                        <PatternMatchFailure>
                    );
                  -- Inline v10
                  let v10 =
                    (\s3@v10 -> \a@v11 ->
                      ((v9 s3@v10) (Data.Show.showIntImpl a@v11))
                    );
                  -- Inline v11
                  let v11 =
                    if ((eq s3@v8) (arrayLength x@v0)) then
                      (nothing@v2 <PrimUndefined>)
                    else
                      -- Inline v11
                      let v11 = ((add s3@v8) 1);
                      -- Inline v12
                      let v12 = ((arrayIndex x@v0) s3@v8);
                      ((v10 v11) ((add 1) v12));
                  v11
                );
              -- Inline v8
              let v8 = (loop@v7 s3@v5);
              v8
            );
          (loop@v4 s2@v1)
        )
      );
    letRec-2 loop@v2 =
      (\s2@v3 -> \acc@v4 ->
        (v1#value1
          s2@v3
          (\v1@v5 ->
            (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v4))
          )
          (\s3@v5 -> \a@v6 ->
            ((loop@v2 s3@v5) (Data.List.Types.Cons.List a@v6 acc@v4))
          )
        )
      );
    ((loop@v2 v1#value0) Data.List.Types.Nil)
  )
---------------
Snapshot.Fusion02.test (Step 8)
  (\x@v0 ->
    -- Inline v1
    let v1 = 0;
    -- Inline v2
    let v2 =
      (\s2@v2 -> \nothing@v3 -> \just@v4 ->
        letRec-5 loop@v5 =
          (\s3@v6 ->
            letRec-7 loop@v7 =
              (\s3@v8 ->
                if ((eq s3@v8) (arrayLength x@v0)) then
                  (nothing@v3 <PrimUndefined>)
                else
                  let v9 = ((add s3@v8) 1);
                  -- Inline v10
                  let v10 = ((add 1) ((arrayIndex x@v0) s3@v8));
                  -- Inline v11
                  let v11 = (Data.Show.showIntImpl v10);
                  -- LetAssoc
                  let v12 =
                    let v1@v12 = ((Data.String.CodeUnits.stripPrefix "1") v11);
                    -- Inline v13
                    let v13 =
                      if (isTag Data.Maybe.Nothing v1@v12) then
                        (loop@v7 v9)
                      else if (isTag Data.Maybe.Just v1@v12) then
                        -- Inline v13
                        let v13 = v1@v12#value0;
                        let v14 = ((stringAppend "2") v13);
                        -- Inline v15
                        let v15 =
                          if ((notEq v14) "wat") then
                            ((just@v4 v9) ((stringAppend v14) "1"))
                          else
                            (loop@v5 v9);
                        v15
                      else
                        <PatternMatchFailure>;
                    v13;
                  v12
              );
            (loop@v7 s3@v6)
          );
        (loop@v5 s2@v2)
      );
    letRec-3 loop@v3 =
      (\s2@v4 -> \acc@v5 ->
        (v2
          s2@v4
          (\v1@v6 ->
            (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v5))
          )
          (\s3@v6 -> \a@v7 ->
            ((loop@v3 s3@v6) (Data.List.Types.Cons.List a@v7 acc@v5))
          )
        )
      );
    ((loop@v3 v1) Data.List.Types.Nil)
  )
---------------
Snapshot.Fusion02.test (Step 9)
  (\x@v0 ->
    letRec-1 loop@v1 =
      (\s2@v2 -> \acc@v3 ->
        -- Inline v4
        let v4 =
          (\v1@v4 ->
            (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v3))
          );
        -- Inline v5
        let v5 =
          (\s3@v5 -> \a@v6 ->
            ((loop@v1 s3@v5) (Data.List.Types.Cons.List a@v6 acc@v3))
          );
        letRec-6 loop@v6 =
          (\s3@v7 ->
            letRec-8 loop@v8 =
              (\s3@v9 ->
                if ((eq s3@v9) (arrayLength x@v0)) then
                  (v4 <PrimUndefined>)
                else
                  let v10 = ((add s3@v9) 1);
                  let v1@v11 =
                    (Data.String.CodeUnits.stripPrefix
                      "1"
                      (Data.Show.showIntImpl
                        ((add 1) ((arrayIndex x@v0) s3@v9))
                      )
                    );
                  -- Inline v12
                  let v12 =
                    if (isTag Data.Maybe.Nothing v1@v11) then
                      (loop@v8 v10)
                    else if (isTag Data.Maybe.Just v1@v11) then
                      let v12 = ((stringAppend "2") v1@v11#value0);
                      if ((notEq v12) "wat") then
                        ((v5 v10) ((stringAppend v12) "1"))
                      else
                        (loop@v6 v10)
                    else
                      <PatternMatchFailure>;
                  v12
              );
            (loop@v8 s3@v7)
          );
        -- Inline v7
        let v7 = (loop@v6 s2@v2);
        v7
      );
    ((loop@v1 0) Data.List.Types.Nil)
  )
---------------
Snapshot.Fusion02.test (Step 10)
  (\x@v0 ->
    letRec-1 loop@v1 =
      (\s2@v2 -> \acc@v3 ->
        letRec-4 loop@v4 =
          (\s3@v5 ->
            letRec-6 loop@v6 =
              (\s3@v7 ->
                if ((eq s3@v7) (arrayLength x@v0)) then
                  -- Inline v8
                  let v8 = <PrimUndefined>;
                  (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v3))
                else
                  let v8 = ((add s3@v7) 1);
                  let v1@v9 =
                    (Data.String.CodeUnits.stripPrefix
                      "1"
                      (Data.Show.showIntImpl
                        ((add 1) ((arrayIndex x@v0) s3@v7))
                      )
                    );
                  if (isTag Data.Maybe.Nothing v1@v9) then
                    (loop@v6 v8)
                  else if (isTag Data.Maybe.Just v1@v9) then
                    let v10 = ((stringAppend "2") v1@v9#value0);
                    if ((notEq v10) "wat") then
                      -- Inline v11
                      let v11 = ((stringAppend v10) "1");
                      ((loop@v1 v8) (Data.List.Types.Cons.List v11 acc@v3))
                    else
                      (loop@v4 v8)
                  else
                    <PatternMatchFailure>
              );
            (loop@v6 s3@v5)
          );
        (loop@v4 s2@v2)
      );
    ((loop@v1 0) Data.List.Types.Nil)
  )
---------------
Snapshot.Fusion02.test (Step 11; Final)
  (\x@v0 ->
    letRec-1 loop@v1 =
      (\s2@v2 -> \acc@v3 ->
        letRec-4 loop@v4 =
          (\s3@v5 ->
            letRec-6 loop@v6 =
              (\s3@v7 ->
                if ((eq s3@v7) (arrayLength x@v0)) then
                  (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v3))
                else
                  let v8 = ((add s3@v7) 1);
                  let v1@v9 =
                    (Data.String.CodeUnits.stripPrefix
                      "1"
                      (Data.Show.showIntImpl
                        ((add 1) ((arrayIndex x@v0) s3@v7))
                      )
                    );
                  if (isTag Data.Maybe.Nothing v1@v9) then
                    (loop@v6 v8)
                  else if (isTag Data.Maybe.Just v1@v9) then
                    let v10 = ((stringAppend "2") v1@v9#value0);
                    if ((notEq v10) "wat") then
                      (loop@v1
                        v8
                        (Data.List.Types.Cons.List
                          ((stringAppend v10) "1")
                          acc@v3
                        )
                      )
                    else
                      (loop@v4 v8)
                  else
                    <PatternMatchFailure>
              );
            (loop@v6 s3@v5)
          );
        (loop@v4 s2@v2)
      );
    ((loop@v1 0) Data.List.Types.Nil)
  )

===============

Snapshot.Fusion02.toArray (Step 0; Original)
  (Data.Exists.runExists
    (\v@v0 ->
      -- Inline v1
      let v1 = v@v0;
      -- Inline v2
      let v2 =
        (\s1@v2 step@v3 ->
          letRec-4 loop@v4 =
            (\s2@v5 -> \acc@v6 ->
              (step@v3
                s2@v5
                (\v1@v7 ->
                  (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v6))
                )
                (\s3@v7 -> \a@v8 ->
                  ((loop@v4 s3@v7) ((Data.List.Types.Cons a@v8) acc@v6))
                )
              )
            );
          ((loop@v4 s1@v2) Data.List.Types.Nil)
        );
      -- Inline v3
      let v3 = v1#value0;
      -- Inline v4
      let v4 = v1#value1;
      (v2 s1@v3 step@v4)
    )
  )
---------------
Snapshot.Fusion02.toArray (Step 1)
  (\v@v0 ->
    -- Inline v1
    let v1 = v@v0#value0;
    -- Inline v2
    let v2 = v@v0#value1;
    letRec-3 loop@v3 =
      (\s2@v4 -> \acc@v5 ->
        (v2
          s2@v4
          (\v1@v6 ->
            (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v5))
          )
          (\s3@v6 -> \a@v7 ->
            ((loop@v3 s3@v6) (Data.List.Types.Cons.List a@v7 acc@v5))
          )
        )
      );
    ((loop@v3 v1) Data.List.Types.Nil)
  )
---------------
Snapshot.Fusion02.toArray (Step 2; Final)
  (\v@v0 ->
    letRec-1 loop@v1 =
      (\s2@v2 -> \acc@v3 ->
        (v@v0#value1
          s2@v2
          (\v1@v4 ->
            (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v3))
          )
          (\s3@v4 -> \a@v5 ->
            ((loop@v1 s3@v4) (Data.List.Types.Cons.List a@v5 acc@v3))
          )
        )
      );
    ((loop@v1 v@v0#value0) Data.List.Types.Nil)
  )

===============

Snapshot.Fusion02.toUnfoldable (Step 0; Original)
  (Data.List.toUnfoldable Data.Unfoldable.unfoldableArray)
---------------
Snapshot.Fusion02.toUnfoldable (Step 1; Final)
  (Data.List.toUnfoldable Data.Unfoldable.unfoldableArray)

===============

Snapshot.Fusion02.unsafeIndex (Step 0; Original)
  (Data.Array.unsafeIndex <PrimUndefined>)
---------------
Snapshot.Fusion02.unsafeIndex (Step 1)
  -- Inline v0
  let v0 = <PrimUndefined>;
  Data.Array.unsafeIndexImpl
---------------
Snapshot.Fusion02.unsafeIndex (Step 2; Final)
  Data.Array.unsafeIndexImpl
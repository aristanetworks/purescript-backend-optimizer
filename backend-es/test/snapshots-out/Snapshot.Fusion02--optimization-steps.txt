Snapshot.Fusion02.Unfold (Step 0; Original)
  let Unfold =
    (\ value0 value1 ->
      { tag =
          "Unfold"
      , value0 =
          value0
      , value1 =
          value1
      }
    );
---------------
Snapshot.Fusion02.Unfold (Step 1; Final)
  let Unfold =
    (\ value0 value1 ->
      { tag =
          "Unfold"
      , value0 =
          value0
      , value1 =
          value1
      }
    );

===============

Snapshot.Fusion02.add (Step 0; Original)
  (Data.Semiring.add Data.Semiring.semiringInt)
---------------
Snapshot.Fusion02.add (Step 1; Final)
  Data.Semiring.intAdd

===============

Snapshot.Fusion02.append (Step 0; Original)
  (Data.Semigroup.append Data.Semigroup.semigroupString)
---------------
Snapshot.Fusion02.append (Step 1; Final)
  Data.Semigroup.concatString

===============

Snapshot.Fusion02.compose (Step 0; Original)
  (Control.Semigroupoid.compose Control.Semigroupoid.semigroupoidFn)
---------------
Snapshot.Fusion02.compose (Step 1; Final)
  (
    Control.Semigroupoid.semigroupoidFn
  ).compose

===============

Snapshot.Fusion02.composeFlipped (Step 0; Original)
  (Control.Semigroupoid.composeFlipped Control.Semigroupoid.semigroupoidFn)
---------------
Snapshot.Fusion02.composeFlipped (Step 1; Final)
  (\f@v0 -> \g@v1 -> \x@v2 -> 
    (g@v1 (f@v0 x@v2))
  )

===============

Snapshot.Fusion02.eq (Step 0; Original)
  (Data.Eq.eq Data.Eq.eqInt)
---------------
Snapshot.Fusion02.eq (Step 1; Final)
  Data.Eq.eqIntImpl

===============

Snapshot.Fusion02.filterMapU (Step 0; Original)
  (\f@v0 -> 
    (Data.Exists.runExists (\v@v1 -> 
      {#- Rewrite - Inline -#}
      let v2 =
        v@v1;
      {#- Rewrite - Inline -#}
      let v3 =
        (\s1@v3 step@v4 ->
          (Data.Exists.mkExists ((Snapshot.Fusion02.Unfold s1@v3) (\s2@v5 -> \nothing@v6 -> \just@v7 -> 
            letrec
              let loop@v8 =
                (\s3@v9 -> 
                  (((step@v4 s3@v9) nothing@v6) (\s4@v10 -> \a@v11 -> 
                    let v1@v12 =
                      (f@v0 a@v11);
                    {#- Rewrite - Inline -#}
                    let v13 =
                      v1@v12;
                    {#- Rewrite - Inline -#}
                    let v14 =
                      (\ ->
                        (loop@v8 s4@v10)
                      );
                    {#- Rewrite - Inline -#}
                    let v15 =
                      (\b@v15 ->
                        ((just@v7 s4@v10) b@v15)
                      );
                    if (isTag Data.Maybe.Nothing v13) then
                      (v14)
                    else if (isTag Data.Maybe.Just v13) then
                      {#- Rewrite - Inline -#}
                      let v16 =
                        (
                          v13
                        )#value0;
                      (v15 b@v16)
                    else
                      <PatternMatchFailure>
                  ))
                );
            (loop@v8 s2@v5)
          )))
        );
      {#- Rewrite - Inline -#}
      let v4 =
        (
          v2
        )#value0;
      {#- Rewrite - Inline -#}
      let v5 =
        (
          v2
        )#value1;
      (v3 s1@v4 step@v5)
    ))
  )
---------------
Snapshot.Fusion02.filterMapU (Step 1)
  (\f@v0 -> \v@v1 -> 
    {#- Rewrite - Inline -#}
    let v2 =
      (
        v@v1
      )#value0;
    {#- Rewrite - Inline -#}
    let v3 =
      (
        v@v1
      )#value1;
    (Snapshot.Fusion02.Unfold.Unfold' v2 (\s2@v4 -> \nothing@v5 -> \just@v6 -> 
      letrec
        let loop@v7 =
          (\s3@v8 -> 
            (((v3 s3@v8) nothing@v5) (\s4@v9 -> \a@v10 -> 
              let v1@v11 =
                (f@v0 a@v10);
              if (isTag Data.Maybe.Nothing v1@v11) then
                (loop@v7 s4@v9)
              else if (isTag Data.Maybe.Just v1@v11) then
                {#- Rewrite - Inline -#}
                let v12 =
                  (
                    v1@v11
                  )#value0;
                ((just@v6 s4@v9) v12)
              else
                <PatternMatchFailure>
            ))
          );
      (loop@v7 s2@v4)
    ))
  )
---------------
Snapshot.Fusion02.filterMapU (Step 2; Final)
  (\f@v0 -> \v@v1 -> 
    (Snapshot.Fusion02.Unfold.Unfold' (
      v@v1
    )#value0 (\s2@v2 -> \nothing@v3 -> \just@v4 -> 
      letrec
        let loop@v5 =
          (\s3@v6 -> 
            ((((
              v@v1
            )#value1 s3@v6) nothing@v3) (\s4@v7 -> \a@v8 -> 
              let v1@v9 =
                (f@v0 a@v8);
              if (isTag Data.Maybe.Nothing v1@v9) then
                (loop@v5 s4@v7)
              else if (isTag Data.Maybe.Just v1@v9) then
                ((just@v4 s4@v7) (
                  v1@v9
                )#value0)
              else
                <PatternMatchFailure>
            ))
          );
      (loop@v5 s2@v2)
    ))
  )

===============

Snapshot.Fusion02.filterU (Step 0; Original)
  (\p@v0 -> 
    (Snapshot.Fusion02.filterMapU (\a@v1 -> 
      {#- Rewrite - Inline -#}
      let v2 =
        (p@v0 a@v1);
      {#- Rewrite - Inline -#}
      let v3 =
        (\ ->
          (Data.Maybe.Just a@v1)
        );
      {#- Rewrite - Inline -#}
      let v4 =
        (\ ->
          Data.Maybe.Nothing
        );
      if (== v2 true) then
        (v3)
      else
        (v4)
    ))
  )
---------------
Snapshot.Fusion02.filterU (Step 1)
  (\p@v0 -> 
    {#- Rewrite - Inline -#}
    let v1 =
      (\a@v1 -> 
        if (p@v0 a@v1) then
          (Data.Maybe.Just.Maybe a@v1)
        else
          Data.Maybe.Nothing
      );
    {#- Rewrite - Inline -#}
    let v2 =
      (\v@v2 -> 
        (Snapshot.Fusion02.Unfold.Unfold' (
          v@v2
        )#value0 (\s2@v3 -> \nothing@v4 -> \just@v5 -> 
          letrec
            let loop@v6 =
              (\s3@v7 -> 
                ((((
                  v@v2
                )#value1 s3@v7) nothing@v4) (\s4@v8 -> \a@v9 -> 
                  let v1@v10 =
                    (v1 a@v9);
                  if (isTag Data.Maybe.Nothing v1@v10) then
                    (loop@v6 s4@v8)
                  else if (isTag Data.Maybe.Just v1@v10) then
                    ((just@v5 s4@v8) (
                      v1@v10
                    )#value0)
                  else
                    <PatternMatchFailure>
                ))
              );
          (loop@v6 s2@v3)
        ))
      );
    v2
  )
---------------
Snapshot.Fusion02.filterU (Step 2)
  (\p@v0 -> \v@v1 -> 
    (Snapshot.Fusion02.Unfold.Unfold' (
      v@v1
    )#value0 (\s2@v2 -> \nothing@v3 -> \just@v4 -> 
      letrec
        let loop@v5 =
          (\s3@v6 -> 
            ((((
              v@v1
            )#value1 s3@v6) nothing@v3) (\s4@v7 -> \a@v8 -> 
              [[ DistBranchesLet
                let v1@v9 =
                  if (p@v0 a@v8) then
                    (Data.Maybe.Just.Maybe a@v8)
                  else
                    Data.Maybe.Nothing;
                if (isTag Data.Maybe.Nothing v1@v9) then
                  (loop@v5 s4@v7)
                else if (isTag Data.Maybe.Just v1@v9) then
                  ((just@v4 s4@v7) (
                    v1@v9
                  )#value0)
                else
                  <PatternMatchFailure>
              ]]
            ))
          );
      (loop@v5 s2@v2)
    ))
  )
---------------
Snapshot.Fusion02.filterU (Step 3; Final)
  (\p@v0 -> \v@v1 -> 
    (Snapshot.Fusion02.Unfold.Unfold' (
      v@v1
    )#value0 (\s2@v2 -> \nothing@v3 -> \just@v4 -> 
      letrec
        let loop@v5 =
          (\s3@v6 -> 
            ((((
              v@v1
            )#value1 s3@v6) nothing@v3) (\s4@v7 -> \a@v8 -> 
              if (p@v0 a@v8) then
                ((just@v4 s4@v7) a@v8)
              else
                (loop@v5 s4@v7)
            ))
          );
      (loop@v5 s2@v2)
    ))
  )

===============

Snapshot.Fusion02.fromArray (Step 0; Original)
  (\arr@v0 -> 
    (Data.Exists.mkExists ((Snapshot.Fusion02.Unfold 0) (\ix@v1 -> \nothing@v2 -> \just@v3 -> 
      {#- Rewrite - Inline -#}
      let v4 =
        ((Snapshot.Fusion02.eq ix@v1) (Data.Array.length arr@v0));
      {#- Rewrite - Inline -#}
      let v5 =
        (\ ->
          (nothing@v2 Data.Unit.unit)
        );
      {#- Rewrite - Inline -#}
      let v6 =
        (\ ->
          ((just@v3 ((Snapshot.Fusion02.add ix@v1) 1)) (((Partial.Unsafe.unsafePartial (\$__unused@v6 -> 
            Snapshot.Fusion02.unsafeIndex
          )) arr@v0) ix@v1))
        );
      if (== v4 true) then
        (v5)
      else
        (v6)
    )))
  )
---------------
Snapshot.Fusion02.fromArray (Step 1)
  (\arr@v0 -> 
    (Snapshot.Fusion02.Unfold.Unfold' 0 (\ix@v1 -> \nothing@v2 -> \just@v3 -> 
      if {#- Rewrite - Inline -#}
        let v4 =
          (arrayLength arr@v0);
        (== ix@v1 v4) then
        (nothing@v2 <PrimUndefined>)
      else
        ((just@v3 {#- Rewrite - Inline -#}
        let v4 =
          1;
        (add ix@v1 v4)) (arrayIndex arr@v0 ix@v1))
    ))
  )
---------------
Snapshot.Fusion02.fromArray (Step 2; Final)
  (\arr@v0 -> 
    (Snapshot.Fusion02.Unfold.Unfold' 0 (\ix@v1 -> \nothing@v2 -> \just@v3 -> 
      if (== ix@v1 (arrayLength arr@v0)) then
        (nothing@v2 <PrimUndefined>)
      else
        ((just@v3 (add ix@v1 1)) (arrayIndex arr@v0 ix@v1))
    ))
  )

===============

Snapshot.Fusion02.mapU (Step 0; Original)
  (\f@v0 -> 
    (Data.Exists.runExists (\v@v1 -> 
      {#- Rewrite - Inline -#}
      let v2 =
        v@v1;
      {#- Rewrite - Inline -#}
      let v3 =
        (\s1@v3 step@v4 ->
          (Data.Exists.mkExists ((Snapshot.Fusion02.Unfold s1@v3) (\s2@v5 -> \nothing@v6 -> \just@v7 -> 
            (((step@v4 s2@v5) nothing@v6) (\s3@v8 -> \a@v9 -> 
              ((just@v7 s3@v8) (f@v0 a@v9))
            ))
          )))
        );
      {#- Rewrite - Inline -#}
      let v4 =
        (
          v2
        )#value0;
      {#- Rewrite - Inline -#}
      let v5 =
        (
          v2
        )#value1;
      (v3 s1@v4 step@v5)
    ))
  )
---------------
Snapshot.Fusion02.mapU (Step 1)
  (\f@v0 -> \v@v1 -> 
    {#- Rewrite - Inline -#}
    let v2 =
      (
        v@v1
      )#value0;
    {#- Rewrite - Inline -#}
    let v3 =
      (
        v@v1
      )#value1;
    (Snapshot.Fusion02.Unfold.Unfold' v2 (\s2@v4 -> \nothing@v5 -> \just@v6 -> 
      (((v3 s2@v4) nothing@v5) (\s3@v7 -> \a@v8 -> 
        ((just@v6 s3@v7) (f@v0 a@v8))
      ))
    ))
  )
---------------
Snapshot.Fusion02.mapU (Step 2; Final)
  (\f@v0 -> \v@v1 -> 
    (Snapshot.Fusion02.Unfold.Unfold' (
      v@v1
    )#value0 (\s2@v2 -> \nothing@v3 -> \just@v4 -> 
      ((((
        v@v1
      )#value1 s2@v2) nothing@v3) (\s3@v5 -> \a@v6 -> 
        ((just@v4 s3@v5) (f@v0 a@v6))
      ))
    ))
  )

===============

Snapshot.Fusion02.notEq (Step 0; Original)
  (Data.Eq.notEq Data.Eq.eqString)
---------------
Snapshot.Fusion02.notEq (Step 1; Final)
  (\x@v0 -> \y@v1 -> 
    (/= x@v0 y@v1)
  )

===============

Snapshot.Fusion02.overArray (Step 0; Original)
  (\unfold@v0 -> 
    ((Snapshot.Fusion02.compose Snapshot.Fusion02.toArray) ((Snapshot.Fusion02.compose unfold@v0) Snapshot.Fusion02.fromArray))
  )
---------------
Snapshot.Fusion02.overArray (Step 1)
  (\unfold@v0 -> 
    {#- Rewrite - Inline -#}
    let v1 =
      (\x@v1 -> 
        (unfold@v0 (Snapshot.Fusion02.Unfold.Unfold' 0 (\ix@v2 -> \nothing@v3 -> \just@v4 -> 
          if (== ix@v2 (arrayLength x@v1)) then
            (nothing@v3 <PrimUndefined>)
          else
            ((just@v4 (add ix@v2 1)) (arrayIndex x@v1 ix@v2))
        )))
      );
    {#- Rewrite - Inline -#}
    let v2 =
      (\x@v2 -> 
        let v3 =
          (v1 x@v2);
        {#- Rewrite - Inline -#}
        let v4 =
          letrec
            let loop@v4 =
              (\s2@v5 -> \acc@v6 -> 
                ((((
                  v3
                )#value1 s2@v5) (\v1@v7 -> 
                  (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v6))
                )) (\s3@v7 -> \a@v8 -> 
                  ((loop@v4 s3@v7) (Data.List.Types.Cons.List a@v8 acc@v6))
                ))
              );
          {#- Rewrite - Inline -#}
          let v5 =
            ((loop@v4 (
              v3
            )#value0) Data.List.Types.Nil);
          v5;
        v4
      );
    v2
  )
---------------
Snapshot.Fusion02.overArray (Step 2; Final)
  (\unfold@v0 -> \x@v1 -> 
    let v2 =
      (unfold@v0 (Snapshot.Fusion02.Unfold.Unfold' 0 (\ix@v2 -> \nothing@v3 -> \just@v4 -> 
        if (== ix@v2 (arrayLength x@v1)) then
          (nothing@v3 <PrimUndefined>)
        else
          ((just@v4 (add ix@v2 1)) (arrayIndex x@v1 ix@v2))
      )));
    letrec
      let loop@v3 =
        (\s2@v4 -> \acc@v5 -> 
          ((((
            v2
          )#value1 s2@v4) (\v1@v6 -> 
            (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v5))
          )) (\s3@v6 -> \a@v7 -> 
            ((loop@v3 s3@v6) (Data.List.Types.Cons.List a@v7 acc@v5))
          ))
        );
    ((loop@v3 (
      v2
    )#value0) Data.List.Types.Nil)
  )

===============

Snapshot.Fusion02.test (Step 0; Original)
  (Snapshot.Fusion02.overArray ((Snapshot.Fusion02.composeFlipped (Snapshot.Fusion02.mapU (Snapshot.Fusion02.add 1))) ((Snapshot.Fusion02.composeFlipped (Snapshot.Fusion02.mapU (Data.Show.show Data.Show.showInt))) ((Snapshot.Fusion02.composeFlipped (Snapshot.Fusion02.filterMapU (Data.String.CodeUnits.stripPrefix "1"))) ((Snapshot.Fusion02.composeFlipped (Snapshot.Fusion02.mapU (Snapshot.Fusion02.append "2"))) ((Snapshot.Fusion02.composeFlipped (Snapshot.Fusion02.filterU (\v@v0 -> 
    ((Snapshot.Fusion02.notEq v@v0) "wat")
  ))) (Snapshot.Fusion02.mapU ((Data.Function.flip Snapshot.Fusion02.append) "1"))))))))
---------------
Snapshot.Fusion02.test (Step 1)
  [[ LetAssoc
    let v0 =
      {#- Rewrite - Inline -#}
      let v0 =
        1;
      {#- Rewrite - Inline -#}
      let v1 =
        (\v1 -> 
          (add v0 v1)
        );
      v1;
    let v0 =
      {#- Rewrite - Inline -#}
      let v1 =
        (\v@v1 -> 
          (Snapshot.Fusion02.Unfold.Unfold' (
            v@v1
          )#value0 (\s2@v2 -> \nothing@v3 -> \just@v4 -> 
            ((((
              v@v1
            )#value1 s2@v2) nothing@v3) (\s3@v5 -> \a@v6 -> 
              ((just@v4 s3@v5) (v0 a@v6))
            ))
          ))
        );
      v1;
    let v0 =
      let v1 =
        {#- Rewrite - Inline -#}
        let v1 =
          (\v@v1 -> 
            (Snapshot.Fusion02.Unfold.Unfold' (
              v@v1
            )#value0 (\s2@v2 -> \nothing@v3 -> \just@v4 -> 
              ((((
                v@v1
              )#value1 s2@v2) nothing@v3) (\s3@v5 -> \a@v6 -> 
                ((just@v4 s3@v5) (Data.Show.showIntImpl a@v6))
              ))
            ))
          );
        [[ LetAssoc
          let v2 =
            {#- Rewrite - Inline -#}
            let v2 =
              (Data.String.CodeUnits.stripPrefix "1");
            {#- Rewrite - Inline -#}
            let v3 =
              (\v@v3 -> 
                (Snapshot.Fusion02.Unfold.Unfold' (
                  v@v3
                )#value0 (\s2@v4 -> \nothing@v5 -> \just@v6 -> 
                  letrec
                    let loop@v7 =
                      (\s3@v8 -> 
                        ((((
                          v@v3
                        )#value1 s3@v8) nothing@v5) (\s4@v9 -> \a@v10 -> 
                          let v1@v11 =
                            (v2 a@v10);
                          if (isTag Data.Maybe.Nothing v1@v11) then
                            (loop@v7 s4@v9)
                          else if (isTag Data.Maybe.Just v1@v11) then
                            ((just@v6 s4@v9) (
                              v1@v11
                            )#value0)
                          else
                            <PatternMatchFailure>
                        ))
                      );
                  (loop@v7 s2@v4)
                ))
              );
            v3;
          let v2 =
            [[ LetAssoc
              let v3 =
                {#- Rewrite - Inline -#}
                let v3 =
                  "2";
                {#- Rewrite - Inline -#}
                let v4 =
                  (\v4 -> 
                    (stringAppend v3 v4)
                  );
                v4;
              let v3 =
                {#- Rewrite - Inline -#}
                let v4 =
                  (\v@v4 -> 
                    (Snapshot.Fusion02.Unfold.Unfold' (
                      v@v4
                    )#value0 (\s2@v5 -> \nothing@v6 -> \just@v7 -> 
                      ((((
                        v@v4
                      )#value1 s2@v5) nothing@v6) (\s3@v8 -> \a@v9 -> 
                        ((just@v7 s3@v8) (v3 a@v9))
                      ))
                    ))
                  );
                v4;
              let v3 =
                [[ LetAssoc
                  let v4 =
                    {#- Rewrite - Inline -#}
                    let v4 =
                      (\v@v4 -> 
                        {#- Rewrite - Inline -#}
                        let v5 =
                          "wat";
                        (/= v@v4 v5)
                      );
                    {#- Rewrite - Inline -#}
                    let v5 =
                      (\v@v5 -> 
                        (Snapshot.Fusion02.Unfold.Unfold' (
                          v@v5
                        )#value0 (\s2@v6 -> \nothing@v7 -> \just@v8 -> 
                          letrec
                            let loop@v9 =
                              (\s3@v10 -> 
                                ((((
                                  v@v5
                                )#value1 s3@v10) nothing@v7) (\s4@v11 -> \a@v12 -> 
                                  if (v4 a@v12) then
                                    ((just@v8 s4@v11) a@v12)
                                  else
                                    (loop@v9 s4@v11)
                                ))
                              );
                          (loop@v9 s2@v6)
                        ))
                      );
                    v5;
                  let v4 =
                    [[ LetAssoc
                      let v5 =
                        {#- Rewrite - Inline -#}
                        let v5 =
                          "1";
                        (\a@v6 -> 
                          (stringAppend a@v6 v5)
                        );
                      let v5 =
                        {#- Rewrite - Inline -#}
                        let v6 =
                          (\v@v6 -> 
                            (Snapshot.Fusion02.Unfold.Unfold' (
                              v@v6
                            )#value0 (\s2@v7 -> \nothing@v8 -> \just@v9 -> 
                              ((((
                                v@v6
                              )#value1 s2@v7) nothing@v8) (\s3@v10 -> \a@v11 -> 
                                ((just@v9 s3@v10) (v5 a@v11))
                              ))
                            ))
                          );
                        v6;
                      (\x@v6 -> 
                        (v5 (v4 x@v6))
                      )
                    ]];
                  (\x@v5 -> 
                    (v4 (v3 x@v5))
                  )
                ]];
              (\x@v4 -> 
                (v3 (v2 x@v4))
              )
            ]];
          (\x@v3 -> 
            (v2 (v1 x@v3))
          )
        ]];
      (\x@v2 -> 
        (v1 (v0 x@v2))
      );
    {#- Rewrite - Inline -#}
    let v1 =
      (\x@v1 -> 
        let v2 =
          (v0 (Snapshot.Fusion02.Unfold.Unfold' 0 (\ix@v2 -> \nothing@v3 -> \just@v4 -> 
            if (== ix@v2 (arrayLength x@v1)) then
              (nothing@v3 <PrimUndefined>)
            else
              ((just@v4 (add ix@v2 1)) (arrayIndex x@v1 ix@v2))
          )));
        letrec
          let loop@v3 =
            (\s2@v4 -> \acc@v5 -> 
              ((((
                v2
              )#value1 s2@v4) (\v1@v6 -> 
                (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v5))
              )) (\s3@v6 -> \a@v7 -> 
                ((loop@v3 s3@v6) (Data.List.Types.Cons.List a@v7 acc@v5))
              ))
            );
        ((loop@v3 (
          v2
        )#value0) Data.List.Types.Nil)
      );
    v1
  ]]
---------------
Snapshot.Fusion02.test (Step 2)
  {#- Rewrite - Inline -#}
  let v0 =
    (\v0 -> 
      (add 1 v0)
    );
  {#- Rewrite - Inline -#}
  let v1 =
    (\v@v1 -> 
      (Snapshot.Fusion02.Unfold.Unfold' (
        v@v1
      )#value0 (\s2@v2 -> \nothing@v3 -> \just@v4 -> 
        ((((
          v@v1
        )#value1 s2@v2) nothing@v3) (\s3@v5 -> \a@v6 -> 
          ((just@v4 s3@v5) (v0 a@v6))
        ))
      ))
    );
  [[ LetAssoc
    let v2 =
      {#- Rewrite - Inline -#}
      let v2 =
        (\v@v2 -> 
          (Snapshot.Fusion02.Unfold.Unfold' (
            v@v2
          )#value0 (\s2@v3 -> \nothing@v4 -> \just@v5 -> 
            letrec
              let loop@v6 =
                (\s3@v7 -> 
                  ((((
                    v@v2
                  )#value1 s3@v7) nothing@v4) (\s4@v8 -> \a@v9 -> 
                    let v1@v10 =
                      ((Data.String.CodeUnits.stripPrefix "1") a@v9);
                    if (isTag Data.Maybe.Nothing v1@v10) then
                      (loop@v6 s4@v8)
                    else if (isTag Data.Maybe.Just v1@v10) then
                      ((just@v5 s4@v8) (
                        v1@v10
                      )#value0)
                    else
                      <PatternMatchFailure>
                  ))
                );
            (loop@v6 s2@v3)
          ))
        );
      let v3 =
        {#- Rewrite - Inline -#}
        let v3 =
          (\v3 -> 
            (stringAppend "2" v3)
          );
        {#- Rewrite - Inline -#}
        let v4 =
          (\v@v4 -> 
            (Snapshot.Fusion02.Unfold.Unfold' (
              v@v4
            )#value0 (\s2@v5 -> \nothing@v6 -> \just@v7 -> 
              ((((
                v@v4
              )#value1 s2@v5) nothing@v6) (\s3@v8 -> \a@v9 -> 
                ((just@v7 s3@v8) (v3 a@v9))
              ))
            ))
          );
        let v5 =
          {#- Rewrite - Inline -#}
          let v5 =
            (\v@v5 -> 
              (Snapshot.Fusion02.Unfold.Unfold' (
                v@v5
              )#value0 (\s2@v6 -> \nothing@v7 -> \just@v8 -> 
                letrec
                  let loop@v9 =
                    (\s3@v10 -> 
                      ((((
                        v@v5
                      )#value1 s3@v10) nothing@v7) (\s4@v11 -> \a@v12 -> 
                        if (/= a@v12 "wat") then
                          ((just@v8 s4@v11) a@v12)
                        else
                          (loop@v9 s4@v11)
                      ))
                    );
                (loop@v9 s2@v6)
              ))
            );
          let v6 =
            {#- Rewrite - Inline -#}
            let v6 =
              (\a@v6 -> 
                (stringAppend a@v6 "1")
              );
            {#- Rewrite - Inline -#}
            let v7 =
              (\v@v7 -> 
                (Snapshot.Fusion02.Unfold.Unfold' (
                  v@v7
                )#value0 (\s2@v8 -> \nothing@v9 -> \just@v10 -> 
                  ((((
                    v@v7
                  )#value1 s2@v8) nothing@v9) (\s3@v11 -> \a@v12 -> 
                    ((just@v10 s3@v11) (v6 a@v12))
                  ))
                ))
              );
            (\x@v8 -> 
              (v7 (v5 x@v8))
            );
          (\x@v7 -> 
            (v6 (v4 x@v7))
          );
        (\x@v6 -> 
          (v5 (v2 x@v6))
        );
      (\x@v4 -> 
        (v3 (Snapshot.Fusion02.Unfold.Unfold' (
          x@v4
        )#value0 (\s2@v5 -> \nothing@v6 -> \just@v7 -> 
          ((((
            x@v4
          )#value1 s2@v5) nothing@v6) (\s3@v8 -> \a@v9 -> 
            ((just@v7 s3@v8) (Data.Show.showIntImpl a@v9))
          ))
        )))
      );
    let v2 =
      (\x@v3 -> 
        (v2 (v1 x@v3))
      );
    (\x@v3 -> 
      let v4 =
        (v2 (Snapshot.Fusion02.Unfold.Unfold' 0 (\ix@v4 -> \nothing@v5 -> \just@v6 -> 
          if (== ix@v4 (arrayLength x@v3)) then
            (nothing@v5 <PrimUndefined>)
          else
            ((just@v6 (add ix@v4 1)) (arrayIndex x@v3 ix@v4))
        )));
      letrec
        let loop@v5 =
          (\s2@v6 -> \acc@v7 -> 
            ((((
              v4
            )#value1 s2@v6) (\v1@v8 -> 
              (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v7))
            )) (\s3@v8 -> \a@v9 -> 
              ((loop@v5 s3@v8) (Data.List.Types.Cons.List a@v9 acc@v7))
            ))
          );
      ((loop@v5 (
        v4
      )#value0) Data.List.Types.Nil)
    )
  ]]
---------------
Snapshot.Fusion02.test (Step 3)
  [[ LetAssoc
    let v0 =
      {#- Rewrite - Inline -#}
      let v0 =
        (\x@v0 -> 
          [[ UnpackOp
            For identifier v1
              Unpack Data
                qualified ident = Snapshot.Fusion02.Unfold
                tyName = Unfold'
            inside
              (Snapshot.Fusion02.Unfold.Unfold' (
                v1
              )#value0 (\s2@v2 -> \nothing@v3 -> \just@v4 -> 
                ((((
                  v1
                )#value1 s2@v2) nothing@v3) (\s3@v5 -> \a@v6 -> 
                  ((just@v4 s3@v5) (stringAppend a@v6 "1"))
                ))
              ))
          ]]
        );
      (\x@v1 -> 
        (v0 (Snapshot.Fusion02.Unfold.Unfold' (
          x@v1
        )#value0 (\s2@v2 -> \nothing@v3 -> \just@v4 -> 
          ((((
            x@v1
          )#value1 s2@v2) nothing@v3) (\s3@v5 -> \a@v6 -> 
            ((just@v4 s3@v5) (stringAppend "2" a@v6))
          ))
        )))
      );
    let v0 =
      (\x@v1 -> 
        (v0 (Snapshot.Fusion02.Unfold.Unfold' (
          x@v1
        )#value0 (\s2@v2 -> \nothing@v3 -> \just@v4 -> 
          letrec
            let loop@v5 =
              (\s3@v6 -> 
                ((((
                  x@v1
                )#value1 s3@v6) nothing@v3) (\s4@v7 -> \a@v8 -> 
                  let v1@v9 =
                    ((Data.String.CodeUnits.stripPrefix "1") a@v8);
                  if (isTag Data.Maybe.Nothing v1@v9) then
                    (loop@v5 s4@v7)
                  else if (isTag Data.Maybe.Just v1@v9) then
                    ((just@v4 s4@v7) (
                      v1@v9
                    )#value0)
                  else
                    <PatternMatchFailure>
                ))
              );
          (loop@v5 s2@v2)
        )))
      );
    let v0 =
      (\x@v1 -> 
        (v0 (Snapshot.Fusion02.Unfold.Unfold' (
          x@v1
        )#value0 (\s2@v2 -> \nothing@v3 -> \just@v4 -> 
          ((((
            x@v1
          )#value1 s2@v2) nothing@v3) (\s3@v5 -> \a@v6 -> 
            ((just@v4 s3@v5) (Data.Show.showIntImpl a@v6))
          ))
        )))
      );
    {#- Rewrite - Inline -#}
    let v1 =
      (\x@v1 -> 
        (v0 (Snapshot.Fusion02.Unfold.Unfold' (
          x@v1
        )#value0 (\s2@v2 -> \nothing@v3 -> \just@v4 -> 
          ((((
            x@v1
          )#value1 s2@v2) nothing@v3) (\s3@v5 -> \a@v6 -> 
            ((just@v4 s3@v5) (add 1 a@v6))
          ))
        )))
      );
    (\x@v2 -> 
      let v3 =
        (v1 (Snapshot.Fusion02.Unfold.Unfold' 0 (\ix@v3 -> \nothing@v4 -> \just@v5 -> 
          if (== ix@v3 (arrayLength x@v2)) then
            (nothing@v4 <PrimUndefined>)
          else
            ((just@v5 (add ix@v3 1)) (arrayIndex x@v2 ix@v3))
        )));
      letrec
        let loop@v4 =
          (\s2@v5 -> \acc@v6 -> 
            ((((
              v3
            )#value1 s2@v5) (\v1@v7 -> 
              (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v6))
            )) (\s3@v7 -> \a@v8 -> 
              ((loop@v4 s3@v7) (Data.List.Types.Cons.List a@v8 acc@v6))
            ))
          );
      ((loop@v4 (
        v3
      )#value0) Data.List.Types.Nil)
    )
  ]]
---------------
Snapshot.Fusion02.test (Step 4)
  {#- Rewrite - Inline -#}
  let v0 =
    (\x@v0 -> 
      [[ UnpackOp
        For identifier v1
          Unpack Data
            qualified ident = Snapshot.Fusion02.Unfold
            tyName = Unfold'
        inside
          {#- Rewrite - Inline -#}
          let v2 =
            (
              v1
            )#value0;
          {#- Rewrite - Inline -#}
          let v3 =
            {#- Rewrite - Inline -#}
            let v3 =
              (\s2@v3 -> \nothing@v4 -> \just@v5 -> 
                letrec
                  let loop@v6 =
                    (\s3@v7 -> 
                      ((((
                        v1
                      )#value1 s3@v7) nothing@v4) (\s4@v8 -> \a@v9 -> 
                        if (/= a@v9 "wat") then
                          ((just@v5 s4@v8) a@v9)
                        else
                          (loop@v6 s4@v8)
                      ))
                    );
                (loop@v6 s2@v3)
              );
            (Snapshot.Fusion02.Unfold.Unfold' v2 (\s2@v4 -> \nothing@v5 -> \just@v6 -> 
              (((v3 s2@v4) nothing@v5) (\s3@v7 -> \a@v8 -> 
                ((just@v6 s3@v7) (stringAppend a@v8 "1"))
              ))
            ));
          v3
      ]]
    );
  {#- Rewrite - Inline -#}
  let v1 =
    (\x@v1 -> 
      (v0 (Snapshot.Fusion02.Unfold.Unfold' (
        x@v1
      )#value0 (\s2@v2 -> \nothing@v3 -> \just@v4 -> 
        letrec
          let loop@v5 =
            (\s3@v6 -> 
              ((((
                x@v1
              )#value1 s3@v6) nothing@v3) (\s4@v7 -> \a@v8 -> 
                let v1@v9 =
                  ((Data.String.CodeUnits.stripPrefix "1") a@v8);
                if (isTag Data.Maybe.Nothing v1@v9) then
                  (loop@v5 s4@v7)
                else if (isTag Data.Maybe.Just v1@v9) then
                  ((just@v4 s4@v7) (
                    v1@v9
                  )#value0)
                else
                  <PatternMatchFailure>
              ))
            );
        (loop@v5 s2@v2)
      )))
    );
  {#- Rewrite - Inline -#}
  let v2 =
    (\x@v2 -> 
      (v1 (Snapshot.Fusion02.Unfold.Unfold' (
        x@v2
      )#value0 (\s2@v3 -> \nothing@v4 -> \just@v5 -> 
        ((((
          x@v2
        )#value1 s2@v3) nothing@v4) (\s3@v6 -> \a@v7 -> 
          ((just@v5 s3@v6) (Data.Show.showIntImpl a@v7))
        ))
      )))
    );
  (\x@v3 -> 
    let v4 =
      [[ UnpackOp
        For identifier v4
          Unpack Data
            qualified ident = Snapshot.Fusion02.Unfold
            tyName = Unfold'
        inside
          (v2 (Snapshot.Fusion02.Unfold.Unfold' (
            v4
          )#value0 (\s2@v5 -> \nothing@v6 -> \just@v7 -> 
            ((((
              v4
            )#value1 s2@v5) nothing@v6) (\s3@v8 -> \a@v9 -> 
              ((just@v7 s3@v8) (add 1 a@v9))
            ))
          )))
      ]];
    letrec
      let loop@v5 =
        (\s2@v6 -> \acc@v7 -> 
          ((((
            v4
          )#value1 s2@v6) (\v1@v8 -> 
            (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v7))
          )) (\s3@v8 -> \a@v9 -> 
            ((loop@v5 s3@v8) (Data.List.Types.Cons.List a@v9 acc@v7))
          ))
        );
    ((loop@v5 (
      v4
    )#value0) Data.List.Types.Nil)
  )
---------------
Snapshot.Fusion02.test (Step 5)
  (\x@v0 -> 
    let v1 =
      {#- Rewrite - Inline -#}
      let v1 =
        0;
      {#- Rewrite - Inline -#}
      let v2 =
        (\ix@v2 -> \nothing@v3 -> \just@v4 -> 
          if (== ix@v2 (arrayLength x@v0)) then
            (nothing@v3 <PrimUndefined>)
          else
            ((just@v4 (add ix@v2 1)) (arrayIndex x@v0 ix@v2))
        );
      [[ UnpackOp
        For identifier v3
          Unpack Data
            qualified ident = Snapshot.Fusion02.Unfold
            tyName = Unfold'
        inside
          [[ UnpackOp
            For identifier v4
              Unpack Data
                qualified ident = Snapshot.Fusion02.Unfold
                tyName = Unfold'
            inside
              {#- Rewrite - Inline -#}
              let v5 =
                [[ UnpackOp
                  For identifier v5
                    Unpack Data
                      qualified ident = Snapshot.Fusion02.Unfold
                      tyName = Unfold'
                  inside
                    {#- Rewrite - Inline -#}
                    let v6 =
                      {#- Rewrite - Inline -#}
                      let v6 =
                        (
                          v5
                        )#value0;
                      {#- Rewrite - Inline -#}
                      let v7 =
                        {#- Rewrite - Inline -#}
                        let v7 =
                          (\s2@v7 -> \nothing@v8 -> \just@v9 -> 
                            ((((
                              v5
                            )#value1 s2@v7) nothing@v8) (\s3@v10 -> \a@v11 -> 
                              ((just@v9 s3@v10) (stringAppend "2" a@v11))
                            ))
                          );
                        (Snapshot.Fusion02.Unfold.Unfold' v6 (\s2@v8 -> \nothing@v9 -> \just@v10 -> 
                          {#- Rewrite - Inline -#}
                          let v11 =
                            (\s3@v11 -> \a@v12 -> 
                              ((just@v10 s3@v11) (stringAppend a@v12 "1"))
                            );
                          letrec
                            let loop@v12 =
                              (\s3@v13 -> 
                                (((v7 s3@v13) nothing@v9) (\s4@v14 -> \a@v15 -> 
                                  if (/= a@v15 "wat") then
                                    ((v11 s4@v14) a@v15)
                                  else
                                    (loop@v12 s4@v14)
                                ))
                              );
                          {#- Rewrite - Inline -#}
                          let v13 =
                            (loop@v12 s2@v8);
                          v13
                        ));
                      v7;
                    v6
                ]];
              v5
          ]]
      ]];
    letrec
      let loop@v2 =
        (\s2@v3 -> \acc@v4 -> 
          ((((
            v1
          )#value1 s2@v3) (\v1@v5 -> 
            (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v4))
          )) (\s3@v5 -> \a@v6 -> 
            ((loop@v2 s3@v5) (Data.List.Types.Cons.List a@v6 acc@v4))
          ))
        );
    ((loop@v2 (
      v1
    )#value0) Data.List.Types.Nil)
  )
---------------
Snapshot.Fusion02.test (Step 6)
  (\x@v0 -> 
    let v1 =
      {#- Rewrite - Inline -#}
      let v1 =
        0;
      {#- Rewrite - Inline -#}
      let v2 =
        (\s2@v2 -> \nothing@v3 -> \just@v4 -> 
          {#- Rewrite - Inline -#}
          let v5 =
            (\s3@v5 -> \a@v6 -> 
              ((just@v4 s3@v5) (add 1 a@v6))
            );
          if (== s2@v2 (arrayLength x@v0)) then
            (nothing@v3 <PrimUndefined>)
          else
            ((v5 (add s2@v2 1)) (arrayIndex x@v0 s2@v2))
        );
      {#- Rewrite - Inline -#}
      let v3 =
        (\s2@v3 -> \nothing@v4 -> \just@v5 -> 
          (((v2 s2@v3) nothing@v4) (\s3@v6 -> \a@v7 -> 
            ((just@v5 s3@v6) (Data.Show.showIntImpl a@v7))
          ))
        );
      {#- Rewrite - Inline -#}
      let v4 =
        (\s2@v4 -> \nothing@v5 -> \just@v6 -> 
          letrec
            let loop@v7 =
              (\s3@v8 -> 
                (((v3 s3@v8) nothing@v5) (\s4@v9 -> \a@v10 -> 
                  let v1@v11 =
                    ((Data.String.CodeUnits.stripPrefix "1") a@v10);
                  if (isTag Data.Maybe.Nothing v1@v11) then
                    (loop@v7 s4@v9)
                  else if (isTag Data.Maybe.Just v1@v11) then
                    ((just@v6 s4@v9) (
                      v1@v11
                    )#value0)
                  else
                    <PatternMatchFailure>
                ))
              );
          (loop@v7 s2@v4)
        );
      (Snapshot.Fusion02.Unfold.Unfold' v1 (\s2@v5 -> \nothing@v6 -> \just@v7 -> 
        letrec
          let loop@v8 =
            (\s3@v9 -> 
              {#- Rewrite - Inline -#}
              let v10 =
                (\s4@v10 -> \a@v11 -> 
                  if (/= a@v11 "wat") then
                    ((just@v7 s4@v10) (stringAppend a@v11 "1"))
                  else
                    (loop@v8 s4@v10)
                );
              (((v4 s3@v9) nothing@v6) (\s3@v11 -> \a@v12 -> 
                ((v10 s3@v11) (stringAppend "2" a@v12))
              ))
            );
        (loop@v8 s2@v5)
      ));
    letrec
      let loop@v2 =
        (\s2@v3 -> \acc@v4 -> 
          ((((
            v1
          )#value1 s2@v3) (\v1@v5 -> 
            (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v4))
          )) (\s3@v5 -> \a@v6 -> 
            ((loop@v2 s3@v5) (Data.List.Types.Cons.List a@v6 acc@v4))
          ))
        );
    ((loop@v2 (
      v1
    )#value0) Data.List.Types.Nil)
  )
---------------
Snapshot.Fusion02.test (Step 7)
  (\x@v0 -> 
    [[ UnpackOp
      For identifier v1
        Unpack Data
          qualified ident = Snapshot.Fusion02.Unfold
          tyName = Unfold'
      inside
        letrec
          let loop@v2 =
            (\s2@v3 -> \acc@v4 -> 
              ((((
                v1
              )#value1 s2@v3) (\v1@v5 -> 
                (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v4))
              )) (\s3@v5 -> \a@v6 -> 
                ((loop@v2 s3@v5) (Data.List.Types.Cons.List a@v6 acc@v4))
              ))
            );
        ((loop@v2 (
          v1
        )#value0) Data.List.Types.Nil)
    ]]
  )
---------------
Snapshot.Fusion02.test (Step 8)
  (\x@v0 -> 
    {#- Rewrite - Inline -#}
    let v1 =
      0;
    {#- Rewrite - Inline -#}
    let v2 =
      (\s2@v2 -> \nothing@v3 -> \just@v4 -> 
        letrec
          let loop@v5 =
            (\s3@v6 -> 
              letrec
                let loop@v7 =
                  (\s3@v8 -> 
                    if (== s3@v8 (arrayLength x@v0)) then
                      (nothing@v3 <PrimUndefined>)
                    else
                      let v9 =
                        (add s3@v8 1);
                      {#- Rewrite - Inline -#}
                      let v10 =
                        (add 1 (arrayIndex x@v0 s3@v8));
                      {#- Rewrite - Inline -#}
                      let v11 =
                        (Data.Show.showIntImpl v10);
                      [[ LetAssoc
                        let v1@v12 =
                          ((Data.String.CodeUnits.stripPrefix "1") v11);
                        let v12 =
                          {#- Rewrite - Inline -#}
                          let v13 =
                            if (isTag Data.Maybe.Nothing v1@v12) then
                              (loop@v7 v9)
                            else if (isTag Data.Maybe.Just v1@v12) then
                              {#- Rewrite - Inline -#}
                              let v13 =
                                (
                                  v1@v12
                                )#value0;
                              let v14 =
                                (stringAppend "2" v13);
                              {#- Rewrite - Inline -#}
                              let v15 =
                                if (/= v14 "wat") then
                                  ((just@v4 v9) (stringAppend v14 "1"))
                                else
                                  (loop@v5 v9);
                              v15
                            else
                              <PatternMatchFailure>;
                          v13;
                        v12
                      ]]
                  );
              (loop@v7 s3@v6)
            );
        (loop@v5 s2@v2)
      );
    letrec
      let loop@v3 =
        (\s2@v4 -> \acc@v5 -> 
          (((v2 s2@v4) (\v1@v6 -> 
            (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v5))
          )) (\s3@v6 -> \a@v7 -> 
            ((loop@v3 s3@v6) (Data.List.Types.Cons.List a@v7 acc@v5))
          ))
        );
    ((loop@v3 v1) Data.List.Types.Nil)
  )
---------------
Snapshot.Fusion02.test (Step 9)
  (\x@v0 -> 
    letrec
      let loop@v1 =
        (\s2@v2 -> \acc@v3 -> 
          {#- Rewrite - Inline -#}
          let v4 =
            (\v1@v4 -> 
              (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v3))
            );
          {#- Rewrite - Inline -#}
          let v5 =
            (\s3@v5 -> \a@v6 -> 
              ((loop@v1 s3@v5) (Data.List.Types.Cons.List a@v6 acc@v3))
            );
          letrec
            let loop@v6 =
              (\s3@v7 -> 
                letrec
                  let loop@v8 =
                    (\s3@v9 -> 
                      if (== s3@v9 (arrayLength x@v0)) then
                        (v4 <PrimUndefined>)
                      else
                        let v10 =
                          (add s3@v9 1);
                        let v1@v11 =
                          ((Data.String.CodeUnits.stripPrefix "1") (Data.Show.showIntImpl (add 1 (arrayIndex x@v0 s3@v9))));
                        {#- Rewrite - Inline -#}
                        let v12 =
                          if (isTag Data.Maybe.Nothing v1@v11) then
                            (loop@v8 v10)
                          else if (isTag Data.Maybe.Just v1@v11) then
                            let v12 =
                              (stringAppend "2" (
                                v1@v11
                              )#value0);
                            if (/= v12 "wat") then
                              ((v5 v10) (stringAppend v12 "1"))
                            else
                              (loop@v6 v10)
                          else
                            <PatternMatchFailure>;
                        v12
                    );
                (loop@v8 s3@v7)
              );
          {#- Rewrite - Inline -#}
          let v7 =
            (loop@v6 s2@v2);
          v7
        );
    ((loop@v1 0) Data.List.Types.Nil)
  )
---------------
Snapshot.Fusion02.test (Step 10)
  (\x@v0 -> 
    letrec
      let loop@v1 =
        (\s2@v2 -> \acc@v3 -> 
          letrec
            let loop@v4 =
              (\s3@v5 -> 
                letrec
                  let loop@v6 =
                    (\s3@v7 -> 
                      if (== s3@v7 (arrayLength x@v0)) then
                        {#- Rewrite - Inline -#}
                        let v8 =
                          <PrimUndefined>;
                        (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v3))
                      else
                        let v8 =
                          (add s3@v7 1);
                        let v1@v9 =
                          ((Data.String.CodeUnits.stripPrefix "1") (Data.Show.showIntImpl (add 1 (arrayIndex x@v0 s3@v7))));
                        if (isTag Data.Maybe.Nothing v1@v9) then
                          (loop@v6 v8)
                        else if (isTag Data.Maybe.Just v1@v9) then
                          let v10 =
                            (stringAppend "2" (
                              v1@v9
                            )#value0);
                          if (/= v10 "wat") then
                            {#- Rewrite - Inline -#}
                            let v11 =
                              (stringAppend v10 "1");
                            ((loop@v1 v8) (Data.List.Types.Cons.List v11 acc@v3))
                          else
                            (loop@v4 v8)
                        else
                          <PatternMatchFailure>
                    );
                (loop@v6 s3@v5)
              );
          (loop@v4 s2@v2)
        );
    ((loop@v1 0) Data.List.Types.Nil)
  )
---------------
Snapshot.Fusion02.test (Step 11; Final)
  (\x@v0 -> 
    letrec
      let loop@v1 =
        (\s2@v2 -> \acc@v3 -> 
          letrec
            let loop@v4 =
              (\s3@v5 -> 
                letrec
                  let loop@v6 =
                    (\s3@v7 -> 
                      if (== s3@v7 (arrayLength x@v0)) then
                        (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v3))
                      else
                        let v8 =
                          (add s3@v7 1);
                        let v1@v9 =
                          ((Data.String.CodeUnits.stripPrefix "1") (Data.Show.showIntImpl (add 1 (arrayIndex x@v0 s3@v7))));
                        if (isTag Data.Maybe.Nothing v1@v9) then
                          (loop@v6 v8)
                        else if (isTag Data.Maybe.Just v1@v9) then
                          let v10 =
                            (stringAppend "2" (
                              v1@v9
                            )#value0);
                          if (/= v10 "wat") then
                            ((loop@v1 v8) (Data.List.Types.Cons.List (stringAppend v10 "1") acc@v3))
                          else
                            (loop@v4 v8)
                        else
                          <PatternMatchFailure>
                    );
                (loop@v6 s3@v5)
              );
          (loop@v4 s2@v2)
        );
    ((loop@v1 0) Data.List.Types.Nil)
  )

===============

Snapshot.Fusion02.toArray (Step 0; Original)
  (Data.Exists.runExists (\v@v0 -> 
    {#- Rewrite - Inline -#}
    let v1 =
      v@v0;
    {#- Rewrite - Inline -#}
    let v2 =
      (\s1@v2 step@v3 ->
        letrec
          let loop@v4 =
            (\s2@v5 -> \acc@v6 -> 
              (((step@v3 s2@v5) (\v1@v7 -> 
                (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v6))
              )) (\s3@v7 -> \a@v8 -> 
                ((loop@v4 s3@v7) ((Data.List.Types.Cons a@v8) acc@v6))
              ))
            );
        ((loop@v4 s1@v2) Data.List.Types.Nil)
      );
    {#- Rewrite - Inline -#}
    let v3 =
      (
        v1
      )#value0;
    {#- Rewrite - Inline -#}
    let v4 =
      (
        v1
      )#value1;
    (v2 s1@v3 step@v4)
  ))
---------------
Snapshot.Fusion02.toArray (Step 1)
  (\v@v0 -> 
    {#- Rewrite - Inline -#}
    let v1 =
      (
        v@v0
      )#value0;
    {#- Rewrite - Inline -#}
    let v2 =
      (
        v@v0
      )#value1;
    letrec
      let loop@v3 =
        (\s2@v4 -> \acc@v5 -> 
          (((v2 s2@v4) (\v1@v6 -> 
            (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v5))
          )) (\s3@v6 -> \a@v7 -> 
            ((loop@v3 s3@v6) (Data.List.Types.Cons.List a@v7 acc@v5))
          ))
        );
    ((loop@v3 v1) Data.List.Types.Nil)
  )
---------------
Snapshot.Fusion02.toArray (Step 2; Final)
  (\v@v0 -> 
    letrec
      let loop@v1 =
        (\s2@v2 -> \acc@v3 -> 
          ((((
            v@v0
          )#value1 s2@v2) (\v1@v4 -> 
            (Data.Array.reverse (Snapshot.Fusion02.toUnfoldable acc@v3))
          )) (\s3@v4 -> \a@v5 -> 
            ((loop@v1 s3@v4) (Data.List.Types.Cons.List a@v5 acc@v3))
          ))
        );
    ((loop@v1 (
      v@v0
    )#value0) Data.List.Types.Nil)
  )

===============

Snapshot.Fusion02.toUnfoldable (Step 0; Original)
  (Data.List.toUnfoldable Data.Unfoldable.unfoldableArray)
---------------
Snapshot.Fusion02.toUnfoldable (Step 1; Final)
  (Data.List.toUnfoldable Data.Unfoldable.unfoldableArray)

===============

Snapshot.Fusion02.unsafeIndex (Step 0; Original)
  (Data.Array.unsafeIndex <PrimUndefined>)
---------------
Snapshot.Fusion02.unsafeIndex (Step 1)
  {#- Rewrite - Inline -#}
  let v0 =
    <PrimUndefined>;
  Data.Array.unsafeIndexImpl
---------------
Snapshot.Fusion02.unsafeIndex (Step 2; Final)
  Data.Array.unsafeIndexImpl
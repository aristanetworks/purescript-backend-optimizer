Snapshot.VanLaarhovenTraversals01.Abs (Step 0; Original)
  letCtor Abs =
    (\value0 value1 -> { tag: "Abs", value0: value0, value1: value1 });
---------------
Snapshot.VanLaarhovenTraversals01.Abs (Step 1; Final)
  letCtor Abs =
    (\value0 value1 -> { tag: "Abs", value0: value0, value1: value1 });

===============

Snapshot.VanLaarhovenTraversals01.App (Step 0; Original)
  letCtor App =
    (\value0 value1 -> { tag: "App", value0: value0, value1: value1 });
---------------
Snapshot.VanLaarhovenTraversals01.App (Step 1; Final)
  letCtor App =
    (\value0 value1 -> { tag: "App", value0: value0, value1: value1 });

===============

Snapshot.VanLaarhovenTraversals01.rewriteBottomUp (Step 0; Original)
  (Safe.Coerce.coerce
    <PrimUndefined>
    (Snapshot.VanLaarhovenTraversals01.rewriteBottomUpM
      Data.Identity.monadIdentity
    )
  )
---------------
Snapshot.VanLaarhovenTraversals01.rewriteBottomUp (Step 1)
  -- Inline v0
  let v0 = <PrimUndefined>;
  let Apply0@v1 =
    -- Inline v1
    let v1 = <PrimUndefined>;
    -- Inline v2
    let v2 = Data.Identity.applicativeIdentity.Apply0;
    (v2 <PrimUndefined>);
  -- LetAssoc
  let v2 =
    let v2 =
      let v2 =
        let map@v2 = (Apply0@v1.Functor0 <PrimUndefined>).map;
        -- Inline v3
        let v3 =
          -- Inline v3
          let v3 = <PrimUndefined>;
          Data.Identity.bindIdentity;
        (\k@v4 ->
          letRec-5 go@v5 =
            (\a@v6 ->
              if (isTag Snapshot.VanLaarhovenTraversals01.Abs a@v6) then
                (map@v2
                  (Snapshot.VanLaarhovenTraversals01.Abs a@v6#value0)
                  ((v3.bind (go@v5 a@v6#value1)) k@v4)
                )
              else if (isTag Snapshot.VanLaarhovenTraversals01.App a@v6) then
                (Apply0@v1.apply
                  (map@v2
                    Snapshot.VanLaarhovenTraversals01.App
                    ((v3.bind (go@v5 a@v6#value0)) k@v4)
                  )
                  ((v3.bind (go@v5 a@v6#value1)) k@v4)
                )
              else
                <PatternMatchFailure>
            );
          (\a@v6 -> ((v3.bind (go@v5 a@v6)) k@v4))
        );
      v2;
    v2;
  v2
---------------
Snapshot.VanLaarhovenTraversals01.rewriteBottomUp (Step 2)
  -- Inline Apply0@v0
  let Apply0@v0 =
    -- Inline v0
    let v0 = <PrimUndefined>;
    Data.Identity.applyIdentity;
  let map@v1 = (Apply0@v0.Functor0 <PrimUndefined>).map;
  -- Inline v2
  let v2 =
    (\k@v2 ->
      letRec-3 go@v3 =
        (\a@v4 ->
          if (isTag Snapshot.VanLaarhovenTraversals01.Abs a@v4) then
            (map@v1
              (Snapshot.VanLaarhovenTraversals01.Abs a@v4#value0)
              let v5 = (go@v3 a@v4#value1);
              -- Inline v6
              let v6 = (\f@v6 -> (f@v6 v5));
              (v6 k@v2)
            )
          else if (isTag Snapshot.VanLaarhovenTraversals01.App a@v4) then
            (Apply0@v0.apply
              (map@v1
                Snapshot.VanLaarhovenTraversals01.App
                let v5 = (go@v3 a@v4#value0);
                -- Inline v6
                let v6 = (\f@v6 -> (f@v6 v5));
                (v6 k@v2)
              )
              let v5 = (go@v3 a@v4#value1);
              -- Inline v6
              let v6 = (\f@v6 -> (f@v6 v5));
              (v6 k@v2)
            )
          else
            <PatternMatchFailure>
        );
      (\a@v4 ->
        let v5 = (go@v3 a@v4);
        -- Inline v6
        let v6 = (\f@v6 -> (f@v6 v5));
        (v6 k@v2)
      )
    );
  v2
---------------
Snapshot.VanLaarhovenTraversals01.rewriteBottomUp (Step 3)
  -- Inline map@v0
  let map@v0 =
    -- Inline v0
    let v0 = <PrimUndefined>;
    Data.Identity.functorIdentity.map;
  (\k@v1 ->
    letRec-2 go@v2 =
      (\a@v3 ->
        if (isTag Snapshot.VanLaarhovenTraversals01.Abs a@v3) then
          (map@v0
            (Snapshot.VanLaarhovenTraversals01.Abs a@v3#value0)
            -- Inline v4
            let v4 = (go@v2 a@v3#value1);
            (k@v1 v4)
          )
        else if (isTag Snapshot.VanLaarhovenTraversals01.App a@v3) then
          let v4 =
            (map@v0
              Snapshot.VanLaarhovenTraversals01.App
              -- Inline v4
              let v4 = (go@v2 a@v3#value0);
              (k@v1 v4)
            );
          -- Inline v5
          let v5 = (\v1@v5 -> (v4 v1@v5));
          (v5
            -- Inline v6
            let v6 = (go@v2 a@v3#value1);
            (k@v1 v6)
          )
        else
          <PatternMatchFailure>
      );
    (\a@v3 ->
      -- Inline v4
      let v4 = (go@v2 a@v3);
      (k@v1 v4)
    )
  )
---------------
Snapshot.VanLaarhovenTraversals01.rewriteBottomUp (Step 4)
  (\k@v0 ->
    letRec-1 go@v1 =
      (\a@v2 ->
        if (isTag Snapshot.VanLaarhovenTraversals01.Abs a@v2) then
          let v3 = (Snapshot.VanLaarhovenTraversals01.Abs a@v2#value0);
          -- Inline v4
          let v4 = (\m@v4 -> (v3 m@v4));
          (v4 (k@v0 (go@v1 a@v2#value1)))
        else if (isTag Snapshot.VanLaarhovenTraversals01.App a@v2) then
          -- Inline v3
          let v3 =
            -- Inline v3
            let v3 = (k@v0 (go@v1 a@v2#value0));
            (Snapshot.VanLaarhovenTraversals01.App v3);
          -- Inline v4
          let v4 = (k@v0 (go@v1 a@v2#value1));
          (v3 v4)
        else
          <PatternMatchFailure>
      );
    (\a@v2 -> (k@v0 (go@v1 a@v2)))
  )
---------------
Snapshot.VanLaarhovenTraversals01.rewriteBottomUp (Step 5)
  (\k@v0 ->
    letRec-1 go@v1 =
      (\a@v2 ->
        if (isTag Snapshot.VanLaarhovenTraversals01.Abs a@v2) then
          -- Inline v3
          let v3 = (Snapshot.VanLaarhovenTraversals01.Abs a@v2#value0);
          -- Inline v4
          let v4 = (k@v0 (go@v1 a@v2#value1));
          (v3 v4)
        else if (isTag Snapshot.VanLaarhovenTraversals01.App a@v2) then
          (Snapshot.VanLaarhovenTraversals01.App.Fun
            (k@v0 (go@v1 a@v2#value0))
            (k@v0 (go@v1 a@v2#value1))
          )
        else
          <PatternMatchFailure>
      );
    (\a@v2 -> (k@v0 (go@v1 a@v2)))
  )
---------------
Snapshot.VanLaarhovenTraversals01.rewriteBottomUp (Step 6; Final)
  (\k@v0 ->
    letRec-1 go@v1 =
      (\a@v2 ->
        if (isTag Snapshot.VanLaarhovenTraversals01.Abs a@v2) then
          (Snapshot.VanLaarhovenTraversals01.Abs.Fun
            a@v2#value0
            (k@v0 (go@v1 a@v2#value1))
          )
        else if (isTag Snapshot.VanLaarhovenTraversals01.App a@v2) then
          (Snapshot.VanLaarhovenTraversals01.App.Fun
            (k@v0 (go@v1 a@v2#value0))
            (k@v0 (go@v1 a@v2#value1))
          )
        else
          <PatternMatchFailure>
      );
    (\a@v2 -> (k@v0 (go@v1 a@v2)))
  )

===============

Snapshot.VanLaarhovenTraversals01.rewriteBottomUpM (Step 0; Original)
  (\dictMonad@v0 ->
    let traverseFun11@v1 =
      (Snapshot.VanLaarhovenTraversals01.traverseFun1
        (dictMonad@v0.Applicative0 <PrimUndefined>)
      );
    let composeKleisliFlipped@v2 =
      (Control.Bind.composeKleisliFlipped (dictMonad@v0.Bind1 <PrimUndefined>));
    (\k@v3 ->
      letRec-4 go@v4 =
        (\a@v5 ->
          ((traverseFun11@v1 ((composeKleisliFlipped@v2 k@v3) go@v4)) a@v5)
        );
      ((composeKleisliFlipped@v2 k@v3) go@v4)
    )
  )
---------------
Snapshot.VanLaarhovenTraversals01.rewriteBottomUpM (Step 1)
  (\dictMonad@v0 ->
    let traverseFun11@v1 =
      -- Inline v1
      let v1 = (dictMonad@v0.Applicative0 <PrimUndefined>);
      -- LetAssoc
      let v2 =
        let Apply0@v2 = (v1.Apply0 <PrimUndefined>);
        -- LetAssoc
        let v3 =
          let map@v3 = (Apply0@v2.Functor0 <PrimUndefined>).map;
          (\k@v4 -> \v@v5 ->
            if (isTag Snapshot.VanLaarhovenTraversals01.Abs v@v5) then
              (map@v3
                (Snapshot.VanLaarhovenTraversals01.Abs v@v5#value0)
                (k@v4 v@v5#value1)
              )
            else if (isTag Snapshot.VanLaarhovenTraversals01.App v@v5) then
              (Apply0@v2.apply
                (map@v3
                  Snapshot.VanLaarhovenTraversals01.App
                  (k@v4 v@v5#value0)
                )
                (k@v4 v@v5#value1)
              )
            else
              <PatternMatchFailure>
          );
        v3;
      v2;
    -- LetAssoc
    let composeKleisliFlipped@v2 =
      let v2 = (dictMonad@v0.Bind1 <PrimUndefined>);
      -- Inline v3
      let v3 = (\f@v3 -> \g@v4 -> \a@v5 -> ((v2.bind (g@v4 a@v5)) f@v3));
      v3;
    (\k@v3 ->
      letRec-4 go@v4 =
        (\a@v5 ->
          ((traverseFun11@v1 ((composeKleisliFlipped@v2 k@v3) go@v4)) a@v5)
        );
      ((composeKleisliFlipped@v2 k@v3) go@v4)
    )
  )
---------------
Snapshot.VanLaarhovenTraversals01.rewriteBottomUpM (Step 2)
  (\dictMonad@v0 ->
    -- LetAssoc
    let traverseFun11@v1 =
      let Apply0@v1 =
        ((dictMonad@v0.Applicative0 <PrimUndefined>).Apply0 <PrimUndefined>);
      -- LetAssoc
      let v2 =
        let map@v2 = (Apply0@v1.Functor0 <PrimUndefined>).map;
        -- Inline v3
        let v3 =
          (\k@v3 -> \v@v4 ->
            if (isTag Snapshot.VanLaarhovenTraversals01.Abs v@v4) then
              (map@v2
                (Snapshot.VanLaarhovenTraversals01.Abs v@v4#value0)
                (k@v3 v@v4#value1)
              )
            else if (isTag Snapshot.VanLaarhovenTraversals01.App v@v4) then
              (Apply0@v1.apply
                (map@v2
                  Snapshot.VanLaarhovenTraversals01.App
                  (k@v3 v@v4#value0)
                )
                (k@v3 v@v4#value1)
              )
            else
              <PatternMatchFailure>
          );
        v3;
      v2;
    let v2 = (dictMonad@v0.Bind1 <PrimUndefined>);
    -- Inline composeKleisliFlipped@v3
    let composeKleisliFlipped@v3 =
      (\f@v3 -> \g@v4 -> \a@v5 -> ((v2.bind (g@v4 a@v5)) f@v3));
    (\k@v4 ->
      letRec-5 go@v5 =
        (\a@v6 ->
          ((traverseFun11@v1 ((composeKleisliFlipped@v3 k@v4) go@v5)) a@v6)
        );
      ((composeKleisliFlipped@v3 k@v4) go@v5)
    )
  )
---------------
Snapshot.VanLaarhovenTraversals01.rewriteBottomUpM (Step 3)
  (\dictMonad@v0 ->
    let Apply0@v1 =
      ((dictMonad@v0.Applicative0 <PrimUndefined>).Apply0 <PrimUndefined>);
    -- LetAssoc
    let traverseFun11@v2 =
      let map@v2 = (Apply0@v1.Functor0 <PrimUndefined>).map;
      -- Inline v3
      let v3 =
        (\k@v3 -> \v@v4 ->
          if (isTag Snapshot.VanLaarhovenTraversals01.Abs v@v4) then
            (map@v2
              (Snapshot.VanLaarhovenTraversals01.Abs v@v4#value0)
              (k@v3 v@v4#value1)
            )
          else if (isTag Snapshot.VanLaarhovenTraversals01.App v@v4) then
            (Apply0@v1.apply
              (map@v2
                Snapshot.VanLaarhovenTraversals01.App
                (k@v3 v@v4#value0)
              )
              (k@v3 v@v4#value1)
            )
          else
            <PatternMatchFailure>
        );
      v3;
    let v3 = (dictMonad@v0.Bind1 <PrimUndefined>);
    (\k@v4 ->
      letRec-5 go@v5 =
        (\a@v6 ->
          ((traverseFun11@v2 (\a@v7 -> ((v3.bind (go@v5 a@v7)) k@v4))) a@v6)
        );
      (\a@v6 -> ((v3.bind (go@v5 a@v6)) k@v4))
    )
  )
---------------
Snapshot.VanLaarhovenTraversals01.rewriteBottomUpM (Step 4)
  (\dictMonad@v0 ->
    let Apply0@v1 =
      ((dictMonad@v0.Applicative0 <PrimUndefined>).Apply0 <PrimUndefined>);
    let map@v2 = (Apply0@v1.Functor0 <PrimUndefined>).map;
    -- Inline traverseFun11@v3
    let traverseFun11@v3 =
      (\k@v3 -> \v@v4 ->
        if (isTag Snapshot.VanLaarhovenTraversals01.Abs v@v4) then
          (map@v2
            (Snapshot.VanLaarhovenTraversals01.Abs v@v4#value0)
            (k@v3 v@v4#value1)
          )
        else if (isTag Snapshot.VanLaarhovenTraversals01.App v@v4) then
          (Apply0@v1.apply
            ((map@v2 Snapshot.VanLaarhovenTraversals01.App) (k@v3 v@v4#value0))
            (k@v3 v@v4#value1)
          )
        else
          <PatternMatchFailure>
      );
    let v4 = (dictMonad@v0.Bind1 <PrimUndefined>);
    (\k@v5 ->
      letRec-6 go@v6 =
        (\a@v7 ->
          ((traverseFun11@v3 (\a@v8 -> ((v4.bind (go@v6 a@v8)) k@v5))) a@v7)
        );
      (\a@v7 -> ((v4.bind (go@v6 a@v7)) k@v5))
    )
  )
---------------
Snapshot.VanLaarhovenTraversals01.rewriteBottomUpM (Step 5)
  (\dictMonad@v0 ->
    let Apply0@v1 =
      ((dictMonad@v0.Applicative0 <PrimUndefined>).Apply0 <PrimUndefined>);
    let map@v2 = (Apply0@v1.Functor0 <PrimUndefined>).map;
    let v3 = (dictMonad@v0.Bind1 <PrimUndefined>);
    (\k@v4 ->
      letRec-5 go@v5 =
        (\a@v6 ->
          -- Inline v7
          let v7 = (\a@v7 -> ((v3.bind (go@v5 a@v7)) k@v4));
          if (isTag Snapshot.VanLaarhovenTraversals01.Abs a@v6) then
            (map@v2
              (Snapshot.VanLaarhovenTraversals01.Abs a@v6#value0)
              (v7 a@v6#value1)
            )
          else if (isTag Snapshot.VanLaarhovenTraversals01.App a@v6) then
            (Apply0@v1.apply
              ((map@v2 Snapshot.VanLaarhovenTraversals01.App) (v7 a@v6#value0))
              (v7 a@v6#value1)
            )
          else
            <PatternMatchFailure>
        );
      (\a@v6 -> ((v3.bind (go@v5 a@v6)) k@v4))
    )
  )
---------------
Snapshot.VanLaarhovenTraversals01.rewriteBottomUpM (Step 6)
  (\dictMonad@v0 ->
    let Apply0@v1 =
      ((dictMonad@v0.Applicative0 <PrimUndefined>).Apply0 <PrimUndefined>);
    let map@v2 = (Apply0@v1.Functor0 <PrimUndefined>).map;
    let v3 = (dictMonad@v0.Bind1 <PrimUndefined>);
    (\k@v4 ->
      letRec-5 go@v5 =
        (\a@v6 ->
          if (isTag Snapshot.VanLaarhovenTraversals01.Abs a@v6) then
            (map@v2
              (Snapshot.VanLaarhovenTraversals01.Abs a@v6#value0)
              -- Inline v7
              let v7 = a@v6#value1;
              ((v3.bind (go@v5 v7)) k@v4)
            )
          else if (isTag Snapshot.VanLaarhovenTraversals01.App a@v6) then
            (Apply0@v1.apply
              (map@v2
                Snapshot.VanLaarhovenTraversals01.App
                -- Inline v7
                let v7 = a@v6#value0;
                ((v3.bind (go@v5 v7)) k@v4)
              )
              -- Inline v7
              let v7 = a@v6#value1;
              ((v3.bind (go@v5 v7)) k@v4)
            )
          else
            <PatternMatchFailure>
        );
      (\a@v6 -> ((v3.bind (go@v5 a@v6)) k@v4))
    )
  )
---------------
Snapshot.VanLaarhovenTraversals01.rewriteBottomUpM (Step 7; Final)
  (\dictMonad@v0 ->
    let Apply0@v1 =
      ((dictMonad@v0.Applicative0 <PrimUndefined>).Apply0 <PrimUndefined>);
    let map@v2 = (Apply0@v1.Functor0 <PrimUndefined>).map;
    let v3 = (dictMonad@v0.Bind1 <PrimUndefined>);
    (\k@v4 ->
      letRec-5 go@v5 =
        (\a@v6 ->
          if (isTag Snapshot.VanLaarhovenTraversals01.Abs a@v6) then
            (map@v2
              (Snapshot.VanLaarhovenTraversals01.Abs a@v6#value0)
              ((v3.bind (go@v5 a@v6#value1)) k@v4)
            )
          else if (isTag Snapshot.VanLaarhovenTraversals01.App a@v6) then
            (Apply0@v1.apply
              (map@v2
                Snapshot.VanLaarhovenTraversals01.App
                ((v3.bind (go@v5 a@v6#value0)) k@v4)
              )
              ((v3.bind (go@v5 a@v6#value1)) k@v4)
            )
          else
            <PatternMatchFailure>
        );
      (\a@v6 -> ((v3.bind (go@v5 a@v6)) k@v4))
    )
  )

===============

Snapshot.VanLaarhovenTraversals01.traverseFun1 (Step 0; Original)
  (\dictApplicative@v0 ->
    let Apply0@v1 = (dictApplicative@v0.Apply0 <PrimUndefined>);
    let map@v2 = (Data.Functor.map (Apply0@v1.Functor0 <PrimUndefined>));
    let apply@v3 = (Control.Apply.apply Apply0@v1);
    (\k@v4 -> \v@v5 ->
      -- Inline v6
      let v6 = v@v5;
      -- Inline v7
      let v7 =
        (\a@v7 id@v8 ->
          ((map@v2 (Snapshot.VanLaarhovenTraversals01.Abs id@v8)) (k@v4 a@v7))
        );
      -- Inline v8
      let v8 =
        (\a@v8 b@v9 ->
          (apply@v3
            ((map@v2 Snapshot.VanLaarhovenTraversals01.App) (k@v4 a@v8))
            (k@v4 b@v9)
          )
        );
      if (isTag Snapshot.VanLaarhovenTraversals01.Abs v6) then
        -- Inline v9
        let v9 = v6#value0;
        -- Inline v10
        let v10 = v6#value1;
        (v7 a@v10 id@v9)
      else if (isTag Snapshot.VanLaarhovenTraversals01.App v6) then
        -- Inline v9
        let v9 = v6#value0;
        -- Inline v10
        let v10 = v6#value1;
        (v8 a@v9 b@v10)
      else
        <PatternMatchFailure>
    )
  )
---------------
Snapshot.VanLaarhovenTraversals01.traverseFun1 (Step 1)
  (\dictApplicative@v0 ->
    let Apply0@v1 = (dictApplicative@v0.Apply0 <PrimUndefined>);
    let map@v2 =
      -- Inline v2
      let v2 = (Apply0@v1.Functor0 <PrimUndefined>);
      -- Inline v3
      let v3 = v2.map;
      v3;
    -- Inline apply@v3
    let apply@v3 = Apply0@v1.apply;
    (\k@v4 -> \v@v5 ->
      if (isTag Snapshot.VanLaarhovenTraversals01.Abs v@v5) then
        -- Inline v6
        let v6 = v@v5#value1;
        -- Inline v7
        let v7 = v@v5#value0;
        ((map@v2 (Snapshot.VanLaarhovenTraversals01.Abs v7)) (k@v4 v6))
      else if (isTag Snapshot.VanLaarhovenTraversals01.App v@v5) then
        -- Inline v6
        let v6 = v@v5#value0;
        -- Inline v7
        let v7 = v@v5#value1;
        (apply@v3
          ((map@v2 Snapshot.VanLaarhovenTraversals01.App) (k@v4 v6))
          (k@v4 v7)
        )
      else
        <PatternMatchFailure>
    )
  )
---------------
Snapshot.VanLaarhovenTraversals01.traverseFun1 (Step 2; Final)
  (\dictApplicative@v0 ->
    let Apply0@v1 = (dictApplicative@v0.Apply0 <PrimUndefined>);
    let map@v2 = (Apply0@v1.Functor0 <PrimUndefined>).map;
    (\k@v3 -> \v@v4 ->
      if (isTag Snapshot.VanLaarhovenTraversals01.Abs v@v4) then
        (map@v2
          (Snapshot.VanLaarhovenTraversals01.Abs v@v4#value0)
          (k@v3 v@v4#value1)
        )
      else if (isTag Snapshot.VanLaarhovenTraversals01.App v@v4) then
        (Apply0@v1.apply
          ((map@v2 Snapshot.VanLaarhovenTraversals01.App) (k@v3 v@v4#value0))
          (k@v3 v@v4#value1)
        )
      else
        <PatternMatchFailure>
    )
  )
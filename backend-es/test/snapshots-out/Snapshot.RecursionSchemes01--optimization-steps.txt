Snapshot.RecursionSchemes01.Add (Step 0; Original)
  let Add =
    (\ value0 value1 ->
      { tag =
          "Add"
      , value0 =
          value0
      , value1 =
          value1
      }
    );
---------------
Snapshot.RecursionSchemes01.Add (Step 1; Final)
  let Add =
    (\ value0 value1 ->
      { tag =
          "Add"
      , value0 =
          value0
      , value1 =
          value1
      }
    );

===============

Snapshot.RecursionSchemes01.Fix (Step 0; Original)
  (\x@v0 -> 
    x@v0
  )
---------------
Snapshot.RecursionSchemes01.Fix (Step 1; Final)
  (\x@v0 -> 
    x@v0
  )

===============

Snapshot.RecursionSchemes01.Lit (Step 0; Original)
  let Lit =
    (\ value0 ->
      { tag =
          "Lit"
      , value0 =
          value0
      }
    );
---------------
Snapshot.RecursionSchemes01.Lit (Step 1; Final)
  let Lit =
    (\ value0 ->
      { tag =
          "Lit"
      , value0 =
          value0
      }
    );

===============

Snapshot.RecursionSchemes01.Mul (Step 0; Original)
  let Mul =
    (\ value0 value1 ->
      { tag =
          "Mul"
      , value0 =
          value0
      , value1 =
          value1
      }
    );
---------------
Snapshot.RecursionSchemes01.Mul (Step 1; Final)
  let Mul =
    (\ value0 value1 ->
      { tag =
          "Mul"
      , value0 =
          value0
      , value1 =
          value1
      }
    );

===============

Snapshot.RecursionSchemes01.add (Step 0; Original)
  (Data.Semiring.add Data.Semiring.semiringInt)
---------------
Snapshot.RecursionSchemes01.add (Step 1; Final)
  Data.Semiring.intAdd

===============

Snapshot.RecursionSchemes01.bump (Step 0; Original)
  (\v@v0 -> 
    {#- Rewrite - Inline -#}
    let v1 =
      v@v0;
    {#- Rewrite - Inline -#}
    let v2 =
      (\a@v2 ->
        (Snapshot.RecursionSchemes01.Lit ((Snapshot.RecursionSchemes01.add a@v2) 1))
      );
    {#- Rewrite - Inline -#}
    let v3 =
      (\other@v3 ->
        other@v3
      );
    if (isTag Snapshot.RecursionSchemes01.Lit v1) then
      {#- Rewrite - Inline -#}
      let v4 =
        (
          v1
        )#value0;
      (v2 a@v4)
    else
      (v3 other@v1)
  )
---------------
Snapshot.RecursionSchemes01.bump (Step 1)
  (\v@v0 -> 
    if (isTag Snapshot.RecursionSchemes01.Lit v@v0) then
      {#- Rewrite - Inline -#}
      let v1 =
        (
          v@v0
        )#value0;
      (Snapshot.RecursionSchemes01.Lit.ExprF {#- Rewrite - Inline -#}
      let v2 =
        1;
      (add v1 v2))
    else
      v@v0
  )
---------------
Snapshot.RecursionSchemes01.bump (Step 2; Final)
  (\v@v0 -> 
    if (isTag Snapshot.RecursionSchemes01.Lit v@v0) then
      (Snapshot.RecursionSchemes01.Lit.ExprF (add (
        v@v0
      )#value0 1))
    else
      v@v0
  )

===============

Snapshot.RecursionSchemes01.cata (Step 0; Original)
  (\dictFunctor@v0 -> 
    let map@v1 =
      (Data.Functor.map dictFunctor@v0);
    (\alg@v2 -> 
      letrec
        let go@v3 =
          (\v@v4 -> 
            {#- Rewrite - Inline -#}
            let v5 =
              v@v4;
            {#- Rewrite - Inline -#}
            let v6 =
              (\f@v6 ->
                (alg@v2 ((map@v1 go@v3) f@v6))
              );
            (v6 f@v5)
          );
      go@v3
    )
  )
---------------
Snapshot.RecursionSchemes01.cata (Step 1)
  (\dictFunctor@v0 -> 
    {#- Rewrite - Inline -#}
    let map@v1 =
      (
        dictFunctor@v0
      ).map;
    (\alg@v2 -> 
      letrec
        let go@v3 =
          (\v@v4 -> 
            (alg@v2 ((map@v1 go@v3) v@v4))
          );
      go@v3
    )
  )
---------------
Snapshot.RecursionSchemes01.cata (Step 2; Final)
  (\dictFunctor@v0 -> \alg@v1 -> 
    letrec
      let go@v2 =
        (\v@v3 -> 
          (alg@v1 (((
            dictFunctor@v0
          ).map go@v2) v@v3))
        );
    go@v2
  )

===============

Snapshot.RecursionSchemes01.cata1 (Step 0; Original)
  (Snapshot.RecursionSchemes01.cata Snapshot.RecursionSchemes01.functorExprF)
---------------
Snapshot.RecursionSchemes01.cata1 (Step 1; Final)
  (Snapshot.RecursionSchemes01.cata Snapshot.RecursionSchemes01.functorExprF)

===============

Snapshot.RecursionSchemes01.eval (Step 0; Original)
  (\v@v0 -> 
    {#- Rewrite - Inline -#}
    let v1 =
      v@v0;
    {#- Rewrite - Inline -#}
    let v2 =
      (\a@v2 b@v3 ->
        ((Snapshot.RecursionSchemes01.add a@v2) b@v3)
      );
    {#- Rewrite - Inline -#}
    let v3 =
      (\a@v3 b@v4 ->
        ((Snapshot.RecursionSchemes01.mul a@v3) b@v4)
      );
    {#- Rewrite - Inline -#}
    let v4 =
      (\a@v4 ->
        a@v4
      );
    if (isTag Snapshot.RecursionSchemes01.Add v1) then
      {#- Rewrite - Inline -#}
      let v5 =
        (
          v1
        )#value0;
      {#- Rewrite - Inline -#}
      let v6 =
        (
          v1
        )#value1;
      (v2 a@v5 b@v6)
    else if (isTag Snapshot.RecursionSchemes01.Mul v1) then
      {#- Rewrite - Inline -#}
      let v5 =
        (
          v1
        )#value0;
      {#- Rewrite - Inline -#}
      let v6 =
        (
          v1
        )#value1;
      (v3 a@v5 b@v6)
    else if (isTag Snapshot.RecursionSchemes01.Lit v1) then
      {#- Rewrite - Inline -#}
      let v5 =
        (
          v1
        )#value0;
      (v4 a@v5)
    else
      <PatternMatchFailure>
  )
---------------
Snapshot.RecursionSchemes01.eval (Step 1)
  (\v@v0 -> 
    if (isTag Snapshot.RecursionSchemes01.Add v@v0) then
      {#- Rewrite - Inline -#}
      let v1 =
        (
          v@v0
        )#value0;
      {#- Rewrite - Inline -#}
      let v2 =
        (
          v@v0
        )#value1;
      (add v1 v2)
    else if (isTag Snapshot.RecursionSchemes01.Mul v@v0) then
      {#- Rewrite - Inline -#}
      let v1 =
        (
          v@v0
        )#value0;
      {#- Rewrite - Inline -#}
      let v2 =
        (
          v@v0
        )#value1;
      (multiply v1 v2)
    else if (isTag Snapshot.RecursionSchemes01.Lit v@v0) then
      {#- Rewrite - Inline -#}
      let v1 =
        (
          v@v0
        )#value0;
      v1
    else
      <PatternMatchFailure>
  )
---------------
Snapshot.RecursionSchemes01.eval (Step 2; Final)
  (\v@v0 -> 
    if (isTag Snapshot.RecursionSchemes01.Add v@v0) then
      (add (
        v@v0
      )#value0 (
        v@v0
      )#value1)
    else if (isTag Snapshot.RecursionSchemes01.Mul v@v0) then
      (multiply (
        v@v0
      )#value0 (
        v@v0
      )#value1)
    else if (isTag Snapshot.RecursionSchemes01.Lit v@v0) then
      (
        v@v0
      )#value0
    else
      <PatternMatchFailure>
  )

===============

Snapshot.RecursionSchemes01.functorExprF (Step 0; Original)
  { map =
      (\f@v0 -> \m@v1 -> 
        {#- Rewrite - Inline -#}
        let v2 =
          m@v1;
        {#- Rewrite - Inline -#}
        let v3 =
          (\v@v3 v1@v4 ->
            ((Snapshot.RecursionSchemes01.Add (f@v0 v@v3)) (f@v0 v1@v4))
          );
        {#- Rewrite - Inline -#}
        let v4 =
          (\v@v4 v1@v5 ->
            ((Snapshot.RecursionSchemes01.Mul (f@v0 v@v4)) (f@v0 v1@v5))
          );
        {#- Rewrite - Inline -#}
        let v5 =
          (\v@v5 ->
            (Snapshot.RecursionSchemes01.Lit v@v5)
          );
        if (isTag Snapshot.RecursionSchemes01.Add v2) then
          {#- Rewrite - Inline -#}
          let v6 =
            (
              v2
            )#value0;
          {#- Rewrite - Inline -#}
          let v7 =
            (
              v2
            )#value1;
          (v3 v@v6 v1@v7)
        else if (isTag Snapshot.RecursionSchemes01.Mul v2) then
          {#- Rewrite - Inline -#}
          let v6 =
            (
              v2
            )#value0;
          {#- Rewrite - Inline -#}
          let v7 =
            (
              v2
            )#value1;
          (v4 v@v6 v1@v7)
        else if (isTag Snapshot.RecursionSchemes01.Lit v2) then
          {#- Rewrite - Inline -#}
          let v6 =
            (
              v2
            )#value0;
          (v5 v@v6)
        else
          <PatternMatchFailure>
      )
  }
---------------
Snapshot.RecursionSchemes01.functorExprF (Step 1)
  { map =
      (\f@v0 -> \m@v1 -> 
        if (isTag Snapshot.RecursionSchemes01.Add m@v1) then
          {#- Rewrite - Inline -#}
          let v2 =
            (
              m@v1
            )#value0;
          {#- Rewrite - Inline -#}
          let v3 =
            (
              m@v1
            )#value1;
          (Snapshot.RecursionSchemes01.Add.ExprF (f@v0 v2) (f@v0 v3))
        else if (isTag Snapshot.RecursionSchemes01.Mul m@v1) then
          {#- Rewrite - Inline -#}
          let v2 =
            (
              m@v1
            )#value0;
          {#- Rewrite - Inline -#}
          let v3 =
            (
              m@v1
            )#value1;
          (Snapshot.RecursionSchemes01.Mul.ExprF (f@v0 v2) (f@v0 v3))
        else if (isTag Snapshot.RecursionSchemes01.Lit m@v1) then
          {#- Rewrite - Inline -#}
          let v2 =
            (
              m@v1
            )#value0;
          (Snapshot.RecursionSchemes01.Lit.ExprF v2)
        else
          <PatternMatchFailure>
      )
  }
---------------
Snapshot.RecursionSchemes01.functorExprF (Step 2; Final)
  { map =
      (\f@v0 -> \m@v1 -> 
        if (isTag Snapshot.RecursionSchemes01.Add m@v1) then
          (Snapshot.RecursionSchemes01.Add.ExprF (f@v0 (
            m@v1
          )#value0) (f@v0 (
            m@v1
          )#value1))
        else if (isTag Snapshot.RecursionSchemes01.Mul m@v1) then
          (Snapshot.RecursionSchemes01.Mul.ExprF (f@v0 (
            m@v1
          )#value0) (f@v0 (
            m@v1
          )#value1))
        else if (isTag Snapshot.RecursionSchemes01.Lit m@v1) then
          (Snapshot.RecursionSchemes01.Lit.ExprF (
            m@v1
          )#value0)
        else
          <PatternMatchFailure>
      )
  }

===============

Snapshot.RecursionSchemes01.mul (Step 0; Original)
  (Data.Semiring.mul Data.Semiring.semiringInt)
---------------
Snapshot.RecursionSchemes01.mul (Step 1; Final)
  Data.Semiring.intMul

===============

Snapshot.RecursionSchemes01.test1 (Step 0; Original)
  (Snapshot.RecursionSchemes01.cata1 Snapshot.RecursionSchemes01.eval)
---------------
Snapshot.RecursionSchemes01.test1 (Step 1)
  letrec
    let go@v0 =
      (\v@v1 -> 
        [[ DistBranchesLet
          let v2 =
            if (isTag Snapshot.RecursionSchemes01.Add v@v1) then
              (Snapshot.RecursionSchemes01.Add.ExprF (go@v0 (
                v@v1
              )#value0) (go@v0 (
                v@v1
              )#value1))
            else if (isTag Snapshot.RecursionSchemes01.Mul v@v1) then
              (Snapshot.RecursionSchemes01.Mul.ExprF (go@v0 (
                v@v1
              )#value0) (go@v0 (
                v@v1
              )#value1))
            else if (isTag Snapshot.RecursionSchemes01.Lit v@v1) then
              (Snapshot.RecursionSchemes01.Lit.ExprF (
                v@v1
              )#value0)
            else
              <PatternMatchFailure>;
          {#- Rewrite - Inline -#}
          let v3 =
            if (isTag Snapshot.RecursionSchemes01.Add v2) then
              (add (
                v2
              )#value0 (
                v2
              )#value1)
            else if (isTag Snapshot.RecursionSchemes01.Mul v2) then
              (multiply (
                v2
              )#value0 (
                v2
              )#value1)
            else if (isTag Snapshot.RecursionSchemes01.Lit v2) then
              (
                v2
              )#value0
            else
              <PatternMatchFailure>;
          v3
        ]]
      );
  go@v0
---------------
Snapshot.RecursionSchemes01.test1 (Step 2; Final)
  letrec
    let go@v0 =
      (\v@v1 -> 
        if (isTag Snapshot.RecursionSchemes01.Add v@v1) then
          (add (go@v0 (
            v@v1
          )#value0) (go@v0 (
            v@v1
          )#value1))
        else if (isTag Snapshot.RecursionSchemes01.Mul v@v1) then
          (multiply (go@v0 (
            v@v1
          )#value0) (go@v0 (
            v@v1
          )#value1))
        else if (isTag Snapshot.RecursionSchemes01.Lit v@v1) then
          (
            v@v1
          )#value0
        else
          <PatternMatchFailure>
      );
  go@v0

===============

Snapshot.RecursionSchemes01.test2 (Step 0; Original)
  (Snapshot.RecursionSchemes01.cata1 (((Control.Semigroupoid.compose Control.Semigroupoid.semigroupoidFn) Snapshot.RecursionSchemes01.eval) Snapshot.RecursionSchemes01.bump))
---------------
Snapshot.RecursionSchemes01.test2 (Step 1)
  {#- Rewrite - Inline -#}
  let v0 =
    (\x@v0 -> 
      [[ DistBranchesLet
        let v1 =
          if (isTag Snapshot.RecursionSchemes01.Lit x@v0) then
            (Snapshot.RecursionSchemes01.Lit.ExprF (add (
              x@v0
            )#value0 1))
          else
            x@v0;
        {#- Rewrite - Inline -#}
        let v2 =
          if (isTag Snapshot.RecursionSchemes01.Add v1) then
            (add (
              v1
            )#value0 (
              v1
            )#value1)
          else if (isTag Snapshot.RecursionSchemes01.Mul v1) then
            (multiply (
              v1
            )#value0 (
              v1
            )#value1)
          else if (isTag Snapshot.RecursionSchemes01.Lit v1) then
            (
              v1
            )#value0
          else
            <PatternMatchFailure>;
        v2
      ]]
    );
  {#- Rewrite - Inline -#}
  let v1 =
    {#- Rewrite - Inline -#}
    let v1 =
      letrec
        let go@v1 =
          (\v@v2 -> 
            (v0 if (isTag Snapshot.RecursionSchemes01.Add v@v2) then
              (Snapshot.RecursionSchemes01.Add.ExprF (go@v1 (
                v@v2
              )#value0) (go@v1 (
                v@v2
              )#value1))
            else if (isTag Snapshot.RecursionSchemes01.Mul v@v2) then
              (Snapshot.RecursionSchemes01.Mul.ExprF (go@v1 (
                v@v2
              )#value0) (go@v1 (
                v@v2
              )#value1))
            else if (isTag Snapshot.RecursionSchemes01.Lit v@v2) then
              (Snapshot.RecursionSchemes01.Lit.ExprF (
                v@v2
              )#value0)
            else
              <PatternMatchFailure>)
          );
      go@v1;
    v1;
  v1
---------------
Snapshot.RecursionSchemes01.test2 (Step 2)
  letrec
    let go@v0 =
      (\v@v1 -> 
        [[ DistBranchesLet
          let v2 =
            if (isTag Snapshot.RecursionSchemes01.Add v@v1) then
              (Snapshot.RecursionSchemes01.Add.ExprF (go@v0 (
                v@v1
              )#value0) (go@v0 (
                v@v1
              )#value1))
            else if (isTag Snapshot.RecursionSchemes01.Mul v@v1) then
              (Snapshot.RecursionSchemes01.Mul.ExprF (go@v0 (
                v@v1
              )#value0) (go@v0 (
                v@v1
              )#value1))
            else if (isTag Snapshot.RecursionSchemes01.Lit v@v1) then
              (Snapshot.RecursionSchemes01.Lit.ExprF (
                v@v1
              )#value0)
            else
              <PatternMatchFailure>;
          if (isTag Snapshot.RecursionSchemes01.Lit v2) then
            (add (
              v2
            )#value0 1)
          else if (isTag Snapshot.RecursionSchemes01.Add v2) then
            (add (
              v2
            )#value0 (
              v2
            )#value1)
          else if (isTag Snapshot.RecursionSchemes01.Mul v2) then
            (multiply (
              v2
            )#value0 (
              v2
            )#value1)
          else if (isTag Snapshot.RecursionSchemes01.Lit v2) then
            (
              v2
            )#value0
          else
            <PatternMatchFailure>
        ]]
      );
  go@v0
---------------
Snapshot.RecursionSchemes01.test2 (Step 3; Final)
  letrec
    let go@v0 =
      (\v@v1 -> 
        if (isTag Snapshot.RecursionSchemes01.Add v@v1) then
          (add (go@v0 (
            v@v1
          )#value0) (go@v0 (
            v@v1
          )#value1))
        else if (isTag Snapshot.RecursionSchemes01.Mul v@v1) then
          (multiply (go@v0 (
            v@v1
          )#value0) (go@v0 (
            v@v1
          )#value1))
        else if (isTag Snapshot.RecursionSchemes01.Lit v@v1) then
          (add (
            v@v1
          )#value0 1)
        else
          <PatternMatchFailure>
      );
  go@v0
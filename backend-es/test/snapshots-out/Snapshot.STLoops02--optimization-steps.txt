Snapshot.STLoops02.add (Step 0; Original)
  (Data.Semiring.add Data.Semiring.semiringInt)
---------------
Snapshot.STLoops02.add (Step 1; Final)
  Data.Semiring.intAdd

===============

Snapshot.STLoops02.compose (Step 0; Original)
  (Control.Semigroupoid.compose Control.Semigroupoid.semigroupoidFn)
---------------
Snapshot.STLoops02.compose (Step 1; Final)
  Control.Semigroupoid.semigroupoidFn.compose

===============

Snapshot.STLoops02.discard (Step 0; Original)
  (Control.Bind.discard
    Control.Bind.discardUnit
    Control.Monad.ST.Internal.bindST
  )
---------------
Snapshot.STLoops02.discard (Step 1; Final)
  Control.Monad.ST.Internal.bind_

===============

Snapshot.STLoops02.lessThan (Step 0; Original)
  (Data.Ord.lessThan Data.Ord.ordInt)
---------------
Snapshot.STLoops02.lessThan (Step 1; Final)
  (\a1@v0 -> \a2@v1 -> ((lt a1@v0) a2@v1))

===============

Snapshot.STLoops02.test1 (Step 0; Original)
  (\ref@v0 -> \lo@v1 -> \hi@v2 ->
    (Control.Monad.ST.Internal.for
      ((Snapshot.STLoops02.add lo@v1) 1)
      ((Snapshot.STLoops02.add hi@v2) 1)
      (\a@v3 ->
        (Snapshot.STLoops02.discard
          (Snapshot.STLoops02.void
            (Control.Monad.ST.Internal.modify
              (\v@v4 -> ((Snapshot.STLoops02.add v@v4) a@v3))
              ref@v0
            )
          )
          (\$__unused@v4 ->
            (Snapshot.STLoops02.void
              (Control.Monad.ST.Internal.modify
                (\v@v5 -> ((Snapshot.STLoops02.add v@v5) a@v3))
                ref@v0
              )
            )
          )
        )
      )
    )
  )
---------------
Snapshot.STLoops02.test1 (Step 1)
  (\ref@v0 -> \lo@v1 -> \hi@v2 ->
    let v3 =
      -- Inline v3
      let v3 = 1;
      ((add lo@v1) v3);
    -- LetAssoc
    let v4 =
      let v4 =
        -- Inline v4
        let v4 = 1;
        ((add hi@v2) v4);
      (# effectDefer
        (-- Stop
        Control.Monad.ST.Internal.for
          v3
          v4
          (\a@v5 ->
            (# effectDefer
              -- LetAssoc
              let v6 =
                let v6 =
                  -- Inline v6
                  let v6 = (\v@v6 -> ((add v@v6) a@v5));
                  -- Inline v7
                  let v7 =
                    letEffect v7 = (# refRead ref@v0 #);
                    (# refWrite ref@v0 (v6 v7) #);
                  v7;
                letEffect v7 = v6;
                (# effectPure <PrimUndefined> #);
              -- Inline v7
              let v7 =
                letEffect $__unused@v7 = v6;
                -- Inline v8
                let v8 =
                  -- Inline v8
                  let v8 = (\v@v8 -> ((add v@v8) a@v5));
                  -- Inline v9
                  let v9 =
                    letEffect v9 = (# refRead ref@v0 #);
                    (# refWrite ref@v0 (v8 v9) #);
                  v9;
                letEffect v9 = v8;
                (# effectPure <PrimUndefined> #);
              v7
            #)
          )
        )
      #);
    v4
  )
---------------
Snapshot.STLoops02.test1 (Step 2)
  (\ref@v0 -> \lo@v1 -> \hi@v2 ->
    let v3 = ((add lo@v1) 1);
    let v4 = ((add hi@v2) 1);
    -- Inline v5
    let v5 =
      (# effectDefer
        (-- Stop
        Control.Monad.ST.Internal.for
          v3
          v4
          (\a@v5 ->
            (# effectDefer
              -- Inline v6
              let v6 =
                letEffect v6 = (# refRead ref@v0 #);
                (# refWrite ref@v0 ((add v6) a@v5) #);
              -- Inline v7
              let v7 =
                letEffect v7 = v6;
                (# effectPure <PrimUndefined> #);
              letEffect $__unused@v8 = v7;
              -- EffectBindAssoc
              let v9 =
                letEffect v9 = (# refRead ref@v0 #);
                (# refWrite ref@v0 ((add v9) a@v5) #);
              (# effectPure <PrimUndefined> #)
            #)
          )
        )
      #);
    v5
  )
---------------
Snapshot.STLoops02.test1 (Step 3)
  (\ref@v0 -> \lo@v1 -> \hi@v2 ->
    let v3 = ((add lo@v1) 1);
    let v4 = ((add hi@v2) 1);
    (# effectDefer
      (-- Stop
      Control.Monad.ST.Internal.for
        v3
        v4
        (\a@v5 ->
          (# effectDefer
            -- EffectBindAssoc
            let $__unused@v6 =
              letEffect v6 =
                letEffect v6 = (# refRead ref@v0 #);
                (# refWrite ref@v0 ((add v6) a@v5) #);
              (# effectPure <PrimUndefined> #);
            letEffect v7 = (# refRead ref@v0 #);
            letEffect v8 = (# refWrite ref@v0 ((add v7) a@v5) #);
            (# effectPure <PrimUndefined> #)
          #)
        )
      )
    #)
  )
---------------
Snapshot.STLoops02.test1 (Step 4)
  (\ref@v0 -> \lo@v1 -> \hi@v2 ->
    let v3 = ((add lo@v1) 1);
    let v4 = ((add hi@v2) 1);
    (# effectDefer
      (-- Stop
      Control.Monad.ST.Internal.for
        v3
        v4
        (\a@v5 ->
          (# effectDefer
            letEffect v6 = (# refRead ref@v0 #);
            letEffect v7 = (# refWrite ref@v0 ((add v6) a@v5) #);
            -- Inline $__unused@v8
            let $__unused@v8 = <PrimUndefined>;
            letEffect v9 = (# refRead ref@v0 #);
            letEffect v10 = (# refWrite ref@v0 ((add v9) a@v5) #);
            (# effectPure <PrimUndefined> #)
          #)
        )
      )
    #)
  )
---------------
Snapshot.STLoops02.test1 (Step 5; Final)
  (\ref@v0 -> \lo@v1 -> \hi@v2 ->
    let v3 = ((add lo@v1) 1);
    let v4 = ((add hi@v2) 1);
    (# effectDefer
      (-- Stop
      Control.Monad.ST.Internal.for
        v3
        v4
        (\a@v5 ->
          (# effectDefer
            letEffect v6 = (# refRead ref@v0 #);
            letEffect v7 = (# refWrite ref@v0 ((add v6) a@v5) #);
            letEffect v8 = (# refRead ref@v0 #);
            letEffect v9 = (# refWrite ref@v0 ((add v8) a@v5) #);
            (# effectPure <PrimUndefined> #)
          #)
        )
      )
    #)
  )

===============

Snapshot.STLoops02.test2 (Step 0; Original)
  (\ref@v0 -> \lo@v1 -> \hi@v2 ->
    (Snapshot.STLoops02.discard
      (Control.Monad.ST.Internal.for
        ((Snapshot.STLoops02.add lo@v1) 1)
        ((Snapshot.STLoops02.add hi@v2) 1)
        (\a@v3 ->
          (Snapshot.STLoops02.void
            (Control.Monad.ST.Internal.modify
              (\v@v4 -> ((Snapshot.STLoops02.add v@v4) a@v3))
              ref@v0
            )
          )
        )
      )
      (\$__unused@v3 ->
        (Snapshot.STLoops02.discard
          (Control.Monad.ST.Internal.for
            ((Snapshot.STLoops02.add lo@v1) 1)
            ((Snapshot.STLoops02.add hi@v2) 1)
            (Snapshot.STLoops02.compose
              Snapshot.STLoops02.void
              (Snapshot.STLoops02.compose
                ((Data.Function.flip Control.Monad.ST.Internal.modify) ref@v0)
                Snapshot.STLoops02.add
              )
            )
          )
          (\$__unused@v4 ->
            (Control.Monad.ST.Internal.for
              ((Snapshot.STLoops02.add lo@v1) 1)
              ((Snapshot.STLoops02.add hi@v2) 1)
              (Data.Function.const
                (Snapshot.STLoops02.void
                  (Control.Monad.ST.Internal.modify
                    (\v@v5 -> ((Snapshot.STLoops02.add v@v5) 1))
                    ref@v0
                  )
                )
              )
            )
          )
        )
      )
    )
  )
---------------
Snapshot.STLoops02.test2 (Step 1)
  (\ref@v0 -> \lo@v1 -> \hi@v2 ->
    -- LetAssoc
    let v3 =
      let v3 =
        -- Inline v3
        let v3 = 1;
        ((add lo@v1) v3);
      -- LetAssoc
      let v4 =
        let v4 =
          -- Inline v4
          let v4 = 1;
          ((add hi@v2) v4);
        (# effectDefer
          (-- Stop
          Control.Monad.ST.Internal.for
            v3
            v4
            (\a@v5 ->
              (# effectDefer
                -- Inline v6
                let v6 =
                  -- Inline v6
                  let v6 = (\v@v6 -> ((add v@v6) a@v5));
                  -- Inline v7
                  let v7 =
                    letEffect v7 = (# refRead ref@v0 #);
                    (# refWrite ref@v0 (v6 v7) #);
                  v7;
                letEffect v7 = v6;
                (# effectPure <PrimUndefined> #)
              #)
            )
          )
        #);
      v4;
    -- Inline v4
    let v4 =
      letEffect $__unused@v4 = v3;
      -- LetAssoc
      let v5 =
        let v5 =
          -- Inline v5
          let v5 = 1;
          ((add lo@v1) v5);
        -- LetAssoc
        let v6 =
          let v6 =
            -- Inline v6
            let v6 = 1;
            ((add hi@v2) v6);
          let v7 =
            -- Inline v7
            let v7 =
              (\v7 ->
                letEffect v8 = v7;
                (# effectPure <PrimUndefined> #)
              );
            -- LetAssoc
            let v8 =
              let v8 =
                -- Inline v8
                let v8 =
                  (\a@v8 ->
                    letEffect v9 = (# refRead ref@v0 #);
                    (# refWrite ref@v0 (a@v8 v9) #)
                  );
                -- Inline v9
                let v9 = (\x@v9 -> (v8 (\v10 -> ((add x@v9) v10))));
                v9;
              (\x@v9 -> (v7 (v8 x@v9)));
            v8;
          (# effectDefer
            (-- Stop
            Control.Monad.ST.Internal.for
              v5
              v6
              (\v8 -> (# effectDefer (v7 v8) #))
            )
          #);
        v6;
      -- Inline v6
      let v6 =
        letEffect $__unused@v6 = v5;
        let v7 =
          -- Inline v7
          let v7 = 1;
          ((add lo@v1) v7);
        -- LetAssoc
        let v8 =
          let v8 =
            -- Inline v8
            let v8 = 1;
            ((add hi@v2) v8);
          -- LetAssoc
          let v9 =
            let v9 =
              let v9 =
                -- Inline v9
                let v9 =
                  (\v@v9 ->
                    -- Inline v10
                    let v10 = 1;
                    ((add v@v9) v10)
                  );
                -- Inline v10
                let v10 =
                  letEffect v10 = (# refRead ref@v0 #);
                  (# refWrite ref@v0 (v9 v10) #);
                v10;
              letEffect v10 = v9;
              (# effectPure <PrimUndefined> #);
            -- Inline v10
            let v10 = (\v@v10 -> v9);
            v10;
          (# effectDefer
            (-- Stop
            Control.Monad.ST.Internal.for
              v7
              v8
              (\v10 -> (# effectDefer (v9 v10) #))
            )
          #);
        v8;
      v6;
    v4
  )
---------------
Snapshot.STLoops02.test2 (Step 2)
  (\ref@v0 -> \lo@v1 -> \hi@v2 ->
    let v3 = ((add lo@v1) 1);
    -- LetAssoc
    let v4 =
      let v4 = ((add hi@v2) 1);
      -- Inline v5
      let v5 =
        (# effectDefer
          (-- Stop
          Control.Monad.ST.Internal.for
            v3
            v4
            (\a@v5 ->
              (# effectDefer
                -- EffectBindAssoc
                let v6 =
                  letEffect v6 = (# refRead ref@v0 #);
                  (# refWrite ref@v0 ((add v6) a@v5) #);
                (# effectPure <PrimUndefined> #)
              #)
            )
          )
        #);
      v5;
    letEffect $__unused@v5 = v4;
    let v6 = ((add lo@v1) 1);
    -- LetAssoc
    let v7 =
      let v7 = ((add hi@v2) 1);
      -- LetAssoc
      let v8 =
        let v8 =
          -- Inline v8
          let v8 =
            (\x@v8 ->
              -- Inline v9
              let v9 = (\v9 -> ((add x@v8) v9));
              letEffect v10 = (# refRead ref@v0 #);
              (# refWrite ref@v0 (v9 v10) #)
            );
          -- Inline v9
          let v9 =
            (\x@v9 ->
              let v10 = (v8 x@v9);
              letEffect v11 = v10;
              (# effectPure <PrimUndefined> #)
            );
          v9;
        (# effectDefer
          (-- Stop
          Control.Monad.ST.Internal.for
            v6
            v7
            (\v9 -> (# effectDefer (v8 v9) #))
          )
        #);
      v8;
    letEffect $__unused@v8 = v7;
    let v9 = ((add lo@v1) 1);
    let v10 = ((add hi@v2) 1);
    -- Inline v11
    let v11 =
      -- Inline v11
      let v11 =
        letEffect v11 = (# refRead ref@v0 #);
        (# refWrite ref@v0 ((add v11) 1) #);
      -- Inline v12
      let v12 =
        letEffect v12 = v11;
        (# effectPure <PrimUndefined> #);
      -- Inline v13
      let v13 = (\v@v13 -> v12);
      (# effectDefer
        (-- Stop
        Control.Monad.ST.Internal.for
          v9
          v10
          (\v14 -> (# effectDefer (v13 v14) #))
        )
      #);
    v11
  )
---------------
Snapshot.STLoops02.test2 (Step 3)
  (\ref@v0 -> \lo@v1 -> \hi@v2 ->
    let v3 = ((add lo@v1) 1);
    let v4 = ((add hi@v2) 1);
    -- Inline v5
    let v5 =
      (# effectDefer
        (-- Stop
        Control.Monad.ST.Internal.for
          v3
          v4
          (\a@v5 ->
            (# effectDefer
              letEffect v6 = (# refRead ref@v0 #);
              letEffect v7 = (# refWrite ref@v0 ((add v6) a@v5) #);
              (# effectPure <PrimUndefined> #)
            #)
          )
        )
      #);
    letEffect $__unused@v6 = v5;
    let v7 = ((add lo@v1) 1);
    let v8 = ((add hi@v2) 1);
    -- Inline v9
    let v9 =
      -- Inline v9
      let v9 =
        (\x@v9 ->
          -- Inline v10
          let v10 =
            letEffect v10 = (# refRead ref@v0 #);
            (# refWrite ref@v0 ((add x@v9) v10) #);
          letEffect v11 = v10;
          (# effectPure <PrimUndefined> #)
        );
      -- Inline v10
      let v10 =
        (# effectDefer
          (-- Stop
          Control.Monad.ST.Internal.for
            v7
            v8
            (\v10 -> (# effectDefer (v9 v10) #))
          )
        #);
      v10;
    letEffect $__unused@v10 = v9;
    -- Inline v11
    let v11 = ((add lo@v1) 1);
    -- Inline v12
    let v12 = ((add hi@v2) 1);
    (# effectDefer
      (-- Stop
      Control.Monad.ST.Internal.for
        v11
        v12
        (\v13 ->
          (# effectDefer
            -- EffectBindAssoc
            let v14 =
              letEffect v14 = (# refRead ref@v0 #);
              (# refWrite ref@v0 ((add v14) 1) #);
            (# effectPure <PrimUndefined> #)
          #)
        )
      )
    #)
  )
---------------
Snapshot.STLoops02.test2 (Step 4)
  (\ref@v0 -> \lo@v1 -> \hi@v2 ->
    let v3 = ((add lo@v1) 1);
    let v4 = ((add hi@v2) 1);
    letEffect $__unused@v5 =
      (-- Stop
      Control.Monad.ST.Internal.for
        v3
        v4
        (\a@v5 ->
          (# effectDefer
            letEffect v6 = (# refRead ref@v0 #);
            letEffect v7 = (# refWrite ref@v0 ((add v6) a@v5) #);
            (# effectPure <PrimUndefined> #)
          #)
        )
      );
    -- Inline v6
    let v6 = ((add lo@v1) 1);
    -- Inline v7
    let v7 = ((add hi@v2) 1);
    letEffect $__unused@v8 =
      (-- Stop
      Control.Monad.ST.Internal.for
        v6
        v7
        (\v8 ->
          (# effectDefer
            -- EffectBindAssoc
            let v9 =
              letEffect v9 = (# refRead ref@v0 #);
              (# refWrite ref@v0 ((add v8) v9) #);
            (# effectPure <PrimUndefined> #)
          #)
        )
      );
    (-- Stop
    Control.Monad.ST.Internal.for
      ((add lo@v1) 1)
      ((add hi@v2) 1)
      (\v9 ->
        (# effectDefer
          letEffect v10 = (# refRead ref@v0 #);
          letEffect v11 = (# refWrite ref@v0 ((add v10) 1) #);
          (# effectPure <PrimUndefined> #)
        #)
      )
    )
  )
---------------
Snapshot.STLoops02.test2 (Step 5; Final)
  (\ref@v0 -> \lo@v1 -> \hi@v2 ->
    let v3 = ((add lo@v1) 1);
    let v4 = ((add hi@v2) 1);
    letEffect $__unused@v5 =
      (-- Stop
      Control.Monad.ST.Internal.for
        v3
        v4
        (\a@v5 ->
          (# effectDefer
            letEffect v6 = (# refRead ref@v0 #);
            letEffect v7 = (# refWrite ref@v0 ((add v6) a@v5) #);
            (# effectPure <PrimUndefined> #)
          #)
        )
      );
    letEffect $__unused@v6 =
      (-- Stop
      Control.Monad.ST.Internal.for
        ((add lo@v1) 1)
        ((add hi@v2) 1)
        (\v6 ->
          (# effectDefer
            letEffect v7 = (# refRead ref@v0 #);
            letEffect v8 = (# refWrite ref@v0 ((add v6) v7) #);
            (# effectPure <PrimUndefined> #)
          #)
        )
      );
    (-- Stop
    Control.Monad.ST.Internal.for
      ((add lo@v1) 1)
      ((add hi@v2) 1)
      (\v7 ->
        (# effectDefer
          letEffect v8 = (# refRead ref@v0 #);
          letEffect v9 = (# refWrite ref@v0 ((add v8) 1) #);
          (# effectPure <PrimUndefined> #)
        #)
      )
    )
  )

===============

Snapshot.STLoops02.test3 (Step 0; Original)
  (\ref@v0 -> \lo@v1 -> \hi@v2 ->
    (Control.Monad.ST.Internal.for
      lo@v1
      hi@v2
      (\a@v3 ->
        (Snapshot.STLoops02.when
          ((Snapshot.STLoops02.lessThan a@v3) 10)
          (Snapshot.STLoops02.void
            (Control.Monad.ST.Internal.modify
              (\v@v4 -> ((Snapshot.STLoops02.add v@v4) a@v3))
              ref@v0
            )
          )
        )
      )
    )
  )
---------------
Snapshot.STLoops02.test3 (Step 1)
  (\ref@v0 -> \lo@v1 -> \hi@v2 ->
    (# effectDefer
      (-- Stop
      Control.Monad.ST.Internal.for
        lo@v1
        hi@v2
        (\a@v3 ->
          (# effectDefer
            -- Inline v4
            let v4 =
              -- Inline v4
              let v4 = 10;
              ((lt a@v3) v4);
            -- LetAssoc
            let v5 =
              let v5 =
                -- Inline v5
                let v5 = (\v@v5 -> ((add v@v5) a@v3));
                -- Inline v6
                let v6 =
                  letEffect v6 = (# refRead ref@v0 #);
                  (# refWrite ref@v0 (v5 v6) #);
                v6;
              letEffect v6 = v5;
              (# effectPure <PrimUndefined> #);
            if v4 then v5 else (# effectPure <PrimUndefined> #)
          #)
        )
      )
    #)
  )
---------------
Snapshot.STLoops02.test3 (Step 2)
  (\ref@v0 -> \lo@v1 -> \hi@v2 ->
    (# effectDefer
      (-- Stop
      Control.Monad.ST.Internal.for
        lo@v1
        hi@v2
        (\a@v3 ->
          (# effectDefer
            -- Inline v4
            let v4 =
              letEffect v4 = (# refRead ref@v0 #);
              (# refWrite ref@v0 ((add v4) a@v3) #);
            -- Inline v5
            let v5 =
              letEffect v5 = v4;
              (# effectPure <PrimUndefined> #);
            if ((lt a@v3) 10) then v5 else (# effectPure <PrimUndefined> #)
          #)
        )
      )
    #)
  )
---------------
Snapshot.STLoops02.test3 (Step 3)
  (\ref@v0 -> \lo@v1 -> \hi@v2 ->
    (# effectDefer
      (-- Stop
      Control.Monad.ST.Internal.for
        lo@v1
        hi@v2
        (\a@v3 ->
          (# effectDefer
            if ((lt a@v3) 10) then
              -- EffectBindAssoc
              let v4 =
                letEffect v4 = (# refRead ref@v0 #);
                (# refWrite ref@v0 ((add v4) a@v3) #);
              (# effectPure <PrimUndefined> #)
            else
              (# effectPure <PrimUndefined> #)
          #)
        )
      )
    #)
  )
---------------
Snapshot.STLoops02.test3 (Step 4; Final)
  (\ref@v0 -> \lo@v1 -> \hi@v2 ->
    (# effectDefer
      (-- Stop
      Control.Monad.ST.Internal.for
        lo@v1
        hi@v2
        (\a@v3 ->
          (# effectDefer
            if ((lt a@v3) 10) then
              letEffect v4 = (# refRead ref@v0 #);
              letEffect v5 = (# refWrite ref@v0 ((add v4) a@v3) #);
              (# effectPure <PrimUndefined> #)
            else
              (# effectPure <PrimUndefined> #)
          #)
        )
      )
    #)
  )

===============

Snapshot.STLoops02.test4 (Step 0; Original)
  (\ref@v0 -> \lo@v1 -> \hi@v2 ->
    (Control.Monad.ST.Internal.for
      lo@v1
      hi@v2
      (\a@v3 ->
        (Snapshot.STLoops02.void
          -- Inline v4
          let v4 = ((Snapshot.STLoops02.lessThan a@v3) 10);
          -- Inline v5
          let v5 =
            (\->
              (Control.Monad.ST.Internal.modify
                (\v@v5 -> ((Snapshot.STLoops02.add v@v5) a@v3))
                ref@v0
              )
            );
          -- Inline v6
          let v6 =
            (\->
              (Control.Monad.ST.Internal.modify
                (\v@v6 -> ((Snapshot.STLoops02.add v@v6) 1))
                ref@v0
              )
            );
          if ((eq v4) true) then (v5!) else (v6!)
        )
      )
    )
  )
---------------
Snapshot.STLoops02.test4 (Step 1)
  (\ref@v0 -> \lo@v1 -> \hi@v2 ->
    (# effectDefer
      (-- Stop
      Control.Monad.ST.Internal.for
        lo@v1
        hi@v2
        (\a@v3 ->
          (# effectDefer
            -- Inline v4
            let v4 =
              if -- Inline v4
              let v4 = 10;
              ((lt a@v3) v4) then
                -- Inline v4
                let v4 = (\v@v4 -> ((add v@v4) a@v3));
                -- Inline v5
                let v5 =
                  letEffect v5 = (# refRead ref@v0 #);
                  (# refWrite ref@v0 (v4 v5) #);
                v5
              else
                -- Inline v4
                let v4 =
                  (\v@v4 ->
                    -- Inline v5
                    let v5 = 1;
                    ((add v@v4) v5)
                  );
                -- Inline v5
                let v5 =
                  letEffect v5 = (# refRead ref@v0 #);
                  (# refWrite ref@v0 (v4 v5) #);
                v5;
            letEffect v5 = v4;
            (# effectPure <PrimUndefined> #)
          #)
        )
      )
    #)
  )
---------------
Snapshot.STLoops02.test4 (Step 2; Final)
  (\ref@v0 -> \lo@v1 -> \hi@v2 ->
    (# effectDefer
      (-- Stop
      Control.Monad.ST.Internal.for
        lo@v1
        hi@v2
        (\a@v3 ->
          (# effectDefer
            letEffect v4 =
              if ((lt a@v3) 10) then
                letEffect v4 = (# refRead ref@v0 #);
                (# refWrite ref@v0 ((add v4) a@v3) #)
              else
                letEffect v4 = (# refRead ref@v0 #);
                (# refWrite ref@v0 ((add v4) 1) #);
            (# effectPure <PrimUndefined> #)
          #)
        )
      )
    #)
  )

===============

Snapshot.STLoops02.void (Step 0; Original)
  (Data.Functor.void Control.Monad.ST.Internal.functorST)
---------------
Snapshot.STLoops02.void (Step 1)
  -- Inline v0
  let v0 = (\v@v0 -> <PrimUndefined>);
  -- Inline v1
  let v1 =
    -- Inline v1
    let v1 =
      -- Inline v1
      let v1 =
        (\v1 ->
          letEffect v2 = v1;
          (# effectPure (v0 v2) #)
        );
      v1;
    v1;
  v1
---------------
Snapshot.STLoops02.void (Step 2; Final)
  (\v0 ->
    letEffect v1 = v0;
    (# effectPure <PrimUndefined> #)
  )

===============

Snapshot.STLoops02.when (Step 0; Original)
  (Control.Applicative.when Control.Monad.ST.Internal.applicativeST)
---------------
Snapshot.STLoops02.when (Step 1)
  (\v@v0 -> \v1@v1 ->
    if v@v0 then
      v1@v1
    else
      -- Inline v2
      let v2 = <PrimUndefined>;
      -- Inline v3
      let v3 = (# effectPure v2 #);
      v3
  )
---------------
Snapshot.STLoops02.when (Step 2; Final)
  (\v@v0 -> \v1@v1 -> if v@v0 then v1@v1 else (# effectPure <PrimUndefined> #))
Snapshot.HalogenVDomST02.aIsSymbol (Step 0; Original)
  { reflectSymbol: (\$__unused@v0 -> "a") }
---------------
Snapshot.HalogenVDomST02.aIsSymbol (Step 1; Final)
  { reflectSymbol: (\$__unused@v0 -> "a") }

===============

Snapshot.HalogenVDomST02.assertEqual (Step 0; Original)
  (Assert.assertEqual
    (Data.Eq.eqArray
      (Snapshot.HalogenVDomST02.eqRec
        (Data.Eq.eqRowCons
          (Snapshot.HalogenVDomST02.eqRowCons
            Snapshot.HalogenVDomST02.bIsSymbol
            Data.Eq.eqInt
          )
          <PrimUndefined>
          Snapshot.HalogenVDomST02.aIsSymbol
          Data.Eq.eqString
        )
      )
    )
    (Data.Show.showArray
      (Snapshot.HalogenVDomST02.showRecord
        (Snapshot.HalogenVDomST02.showRecordFieldsCons
          (Data.Show.showRecordFieldsConsNil
            Snapshot.HalogenVDomST02.bIsSymbol
            Data.Show.showInt
          )
          Data.Show.showString
        )
      )
    )
  )
---------------
Snapshot.HalogenVDomST02.assertEqual (Step 1)
  (Assert.assertEqual
    -- Inline v0
    let v0 =
      -- Inline v0
      let v0 = <PrimUndefined>;
      -- LetAssoc
      let v1 =
        let v1 =
          let v1 =
            let v1 =
              -- Inline v1
              let v1 = <PrimUndefined>;
              -- Inline v2
              let v2 =
                -- Inline v2
                let v2 =
                  { eqRecord:
                      (\v@v2 -> \ra@v3 -> \rb@v4 ->
                        let get@v5 =
                          (Record.Unsafe.unsafeGet
                            -- Inline v5
                            let v5 = Type.Proxy.Proxy;
                            -- Inline v6
                            let v6 = "b";
                            v6
                          );
                        (booleanAnd
                          (let v6 = (get@v5 ra@v3);
                          -- Inline v7
                          let v7 = (\v7 -> ((eq v6) v7));
                          (v7 (get@v5 rb@v4)))
                          (-- Inline v6
                          let v6 = Type.Proxy.Proxy;
                          -- Inline v7
                          let v7 = (\v1@v7 -> \v2@v8 -> true);
                          ((v7 ra@v3) rb@v4))
                        )
                      )
                  };
                v2;
              v2;
            -- Inline v2
            let v2 =
              -- Inline v2
              let v2 = <PrimUndefined>;
              { eqRecord:
                  (\v@v3 -> \ra@v4 -> \rb@v5 ->
                    let get@v6 =
                      (Record.Unsafe.unsafeGet
                        -- Inline v6
                        let v6 = Type.Proxy.Proxy;
                        -- Inline v7
                        let v7 = "a";
                        v7
                      );
                    (booleanAnd
                      (let v7 = (get@v6 ra@v4);
                      -- Inline v8
                      let v8 = (\v8 -> ((eq v7) v8));
                      (v8 (get@v6 rb@v5)))
                      (((v1.eqRecord Type.Proxy.Proxy) ra@v4) rb@v5)
                    )
                  )
              };
            v2;
          { eq: (v1.eqRecord Type.Proxy.Proxy) };
        v1;
      v1;
    -- Inline v1
    let v1 = { eq: (Data.Eq.eqArrayImpl v0.eq) };
    v1
    -- Inline v0
    let v0 =
      -- Inline v0
      let v0 = <PrimUndefined>;
      -- Inline v1
      let v1 =
        -- Inline v1
        let v1 =
          -- Inline v1
          let v1 = <PrimUndefined>;
          let v2 =
            -- UnpackOp v2 Record ["showRecordFields"]
            let v2 =
              { showRecordFields:
                  (\v@v2 -> \record@v3 ->
                    -- Inline key@v4
                    let key@v4 =
                      -- Inline v4
                      let v4 = Type.Proxy.Proxy;
                      -- Inline v5
                      let v5 = "b";
                      v5;
                    (stringAppend
                      " "
                      (stringAppend
                        key@v4
                        (stringAppend
                          ": "
                          (stringAppend
                            (Data.Show.showIntImpl
                              ((Record.Unsafe.unsafeGet key@v4) record@v3)
                            )
                            " "
                          )
                        )
                      )
                    )
                  )
              };
            -- Inline v3
            let v3 =
              -- Inline v3
              let v3 =
                { showRecordFields:
                    (\v@v3 -> \record@v4 ->
                      -- Inline key@v5
                      let key@v5 =
                        -- Inline v5
                        let v5 = Type.Proxy.Proxy;
                        -- Inline v6
                        let v6 = "a";
                        v6;
                      (stringAppend
                        " "
                        (stringAppend
                          key@v5
                          (stringAppend
                            ": "
                            (stringAppend
                              (Data.Show.showStringImpl
                                ((Record.Unsafe.unsafeGet key@v5) record@v4)
                              )
                              (stringAppend
                                ","
                                (v2.showRecordFields
                                  Type.Proxy.Proxy
                                  record@v4
                                )
                              )
                            )
                          )
                        )
                      )
                    )
                };
              v3;
            v3;
          { show:
              (\record@v3 ->
                (stringAppend
                  "{"
                  (stringAppend
                    ((v2.showRecordFields Type.Proxy.Proxy) record@v3)
                    "}"
                  )
                )
              )
          };
        v1;
      v1;
    -- Inline v1
    let v1 = { show: (Data.Show.showArrayImpl v0.show) };
    v1
  )
---------------
Snapshot.HalogenVDomST02.assertEqual (Step 2)
  (Assert.assertEqual
    { eq:
        (Data.Eq.eqArrayImpl
          -- UnpackOp v0 Record ["eqRecord"]
          let v0 =
            { eqRecord:
                (\v@v0 -> \ra@v1 -> \rb@v2 ->
                  -- Inline get@v3
                  let get@v3 = (\v3 -> v3.b);
                  -- Inline v4
                  let v4 = (get@v3 ra@v1);
                  -- Inline v5
                  let v5 = (get@v3 rb@v2);
                  ((eq v4) v5)
                )
            };
          -- Inline v1
          let v1 =
            -- Inline v1
            let v1 =
              { eqRecord:
                  (\v@v1 -> \ra@v2 -> \rb@v3 ->
                    -- Inline get@v4
                    let get@v4 = (\v4 -> v4.a);
                    (booleanAnd
                      (-- Inline v5
                      let v5 = (get@v4 ra@v2);
                      -- Inline v6
                      let v6 = (get@v4 rb@v3);
                      ((eq v5) v6))
                      (((v0.eqRecord Type.Proxy.Proxy) ra@v2) rb@v3)
                    )
                  )
              };
            -- Inline v2
            let v2 = { eq: (v1.eqRecord Type.Proxy.Proxy) };
            v2;
          v1.eq
        )
    }
    { show:
        (Data.Show.showArrayImpl
          let v0 =
            -- Inline v0
            let v0 =
              (\v@v0 -> \record@v1 ->
                (stringAppend
                  " b: "
                  ((stringAppend (Data.Show.showIntImpl record@v1.b)) " ")
                )
              );
            { showRecordFields:
                (\v@v1 -> \record@v2 ->
                  (stringAppend
                    " a: "
                    (stringAppend
                      (Data.Show.showStringImpl record@v2.a)
                      ((stringAppend ",") ((v0 Type.Proxy.Proxy) record@v2))
                    )
                  )
                )
            };
          -- Inline v1
          let v1 =
            { show:
                (\record@v1 ->
                  (stringAppend
                    "{"
                    (stringAppend
                      ((v0.showRecordFields Type.Proxy.Proxy) record@v1)
                      "}"
                    )
                  )
                )
            };
          v1.show
        )
    }
  )
---------------
Snapshot.HalogenVDomST02.assertEqual (Step 3)
  (Assert.assertEqual
    { eq:
        (Data.Eq.eqArrayImpl
          -- Inline v0
          let v0 = (\v@v0 -> \ra@v1 -> \rb@v2 -> ((eq ra@v1.b) rb@v2.b));
          -- Inline v1
          let v1 = Type.Proxy.Proxy;
          (\ra@v2 -> \rb@v3 ->
            (booleanAnd
              ((eq ra@v2.a) rb@v3.a)
              (((v0 Type.Proxy.Proxy) ra@v2) rb@v3)
            )
          )
        )
    }
    { show:
        (Data.Show.showArrayImpl
          -- UnpackOp v0 Record ["showRecordFields"]
          let v0 =
            { showRecordFields:
                (\v@v0 -> \record@v1 ->
                  -- Inline v2
                  let v2 = Type.Proxy.Proxy;
                  -- Inline v3
                  let v3 =
                    -- Inline v3
                    let v3 =
                      -- Inline v3
                      let v3 =
                        (stringAppend
                          " b: "
                          (stringAppend
                            (Data.Show.showIntImpl record@v1.b)
                            " "
                          )
                        );
                      ((stringAppend ",") v3);
                    ((stringAppend (Data.Show.showStringImpl record@v1.a)) v3);
                  ((stringAppend " a: ") v3)
                )
            };
          (\record@v1 ->
            (stringAppend
              "{"
              (stringAppend
                ((v0.showRecordFields Type.Proxy.Proxy) record@v1)
                "}"
              )
            )
          )
        )
    }
  )
---------------
Snapshot.HalogenVDomST02.assertEqual (Step 4)
  (Assert.assertEqual
    { eq:
        (Data.Eq.eqArrayImpl
          (\ra@v0 -> \rb@v1 ->
            (booleanAnd
              ((eq ra@v0.a) rb@v1.a)
              (-- Inline v2
              let v2 = Type.Proxy.Proxy;
              ((eq ra@v0.b) rb@v1.b))
            )
          )
        )
    }
    { show:
        (Data.Show.showArrayImpl
          -- Inline v0
          let v0 =
            (\v@v0 -> \record@v1 ->
              (stringAppend
                " a: "
                (stringAppend
                  (Data.Show.showStringImpl record@v1.a)
                  (stringAppend
                    ", b: "
                    ((stringAppend (Data.Show.showIntImpl record@v1.b)) " ")
                  )
                )
              )
            );
          (\record@v1 ->
            (stringAppend
              "{"
              ((stringAppend ((v0 Type.Proxy.Proxy) record@v1)) "}")
            )
          )
        )
    }
  )
---------------
Snapshot.HalogenVDomST02.assertEqual (Step 5)
  (Assert.assertEqual
    { eq:
        (Data.Eq.eqArrayImpl
          (\ra@v0 -> \rb@v1 ->
            ((booleanAnd ((eq ra@v0.a) rb@v1.a)) ((eq ra@v0.b) rb@v1.b))
          )
        )
    }
    { show:
        (Data.Show.showArrayImpl
          (\record@v0 ->
            -- Inline v1
            let v1 = Type.Proxy.Proxy;
            -- Inline v2
            let v2 =
              -- Inline v2
              let v2 =
                (stringAppend
                  " a: "
                  (stringAppend
                    (Data.Show.showStringImpl record@v0.a)
                    (stringAppend
                      ", b: "
                      ((stringAppend (Data.Show.showIntImpl record@v0.b)) " ")
                    )
                  )
                );
              ((stringAppend v2) "}");
            ((stringAppend "{") v2)
          )
        )
    }
  )
---------------
Snapshot.HalogenVDomST02.assertEqual (Step 6; Final)
  (Assert.assertEqual
    { eq:
        (Data.Eq.eqArrayImpl
          (\ra@v0 -> \rb@v1 ->
            ((booleanAnd ((eq ra@v0.a) rb@v1.a)) ((eq ra@v0.b) rb@v1.b))
          )
        )
    }
    { show:
        (Data.Show.showArrayImpl
          (\record@v0 ->
            (stringAppend
              (stringAppend
                "{ a: "
                (stringAppend
                  (Data.Show.showStringImpl record@v0.a)
                  (stringAppend
                    ", b: "
                    ((stringAppend (Data.Show.showIntImpl record@v0.b)) " ")
                  )
                )
              )
              "}"
            )
          )
        )
    }
  )

===============

Snapshot.HalogenVDomST02.assertEqual1 (Step 0; Original)
  (Assert.assertEqual
    (Data.Eq.eqArray Data.Eq.eqInt)
    (Data.Show.showArray Data.Show.showInt)
  )
---------------
Snapshot.HalogenVDomST02.assertEqual1 (Step 1; Final)
  (Assert.assertEqual
    { eq: (Data.Eq.eqArrayImpl Data.Eq.eqIntImpl) }
    { show: (Data.Show.showArrayImpl Data.Show.showIntImpl) }
  )

===============

Snapshot.HalogenVDomST02.assertEqual2 (Step 0; Original)
  (Assert.assertEqual
    (Data.Eq.eqArray Data.Eq.eqString)
    (Data.Show.showArray Data.Show.showString)
  )
---------------
Snapshot.HalogenVDomST02.assertEqual2 (Step 1; Final)
  (Assert.assertEqual
    { eq: (Data.Eq.eqArrayImpl Data.Eq.eqStringImpl) }
    { show: (Data.Show.showArrayImpl Data.Show.showStringImpl) }
  )

===============

Snapshot.HalogenVDomST02.assertEqual3 (Step 0; Original)
  (Assert.assertEqual
    (Data.Eq.eqArray
      (Snapshot.HalogenVDomST02.eqRec
        (Data.Eq.eqRowCons
          (Data.Eq.eqRowCons
            (Snapshot.HalogenVDomST02.eqRowCons
              Snapshot.HalogenVDomST02.ixIsSymbol
              Data.Eq.eqInt
            )
            <PrimUndefined>
            Snapshot.HalogenVDomST02.bIsSymbol
            Data.Eq.eqInt
          )
          <PrimUndefined>
          Snapshot.HalogenVDomST02.aIsSymbol
          Data.Eq.eqString
        )
      )
    )
    (Data.Show.showArray
      (Snapshot.HalogenVDomST02.showRecord
        (Snapshot.HalogenVDomST02.showRecordFieldsCons
          (Data.Show.showRecordFieldsCons
            Snapshot.HalogenVDomST02.bIsSymbol
            (Data.Show.showRecordFieldsConsNil
              Snapshot.HalogenVDomST02.ixIsSymbol
              Data.Show.showInt
            )
            Data.Show.showInt
          )
          Data.Show.showString
        )
      )
    )
  )
---------------
Snapshot.HalogenVDomST02.assertEqual3 (Step 1)
  (Assert.assertEqual
    -- Inline v0
    let v0 =
      -- Inline v0
      let v0 = <PrimUndefined>;
      -- LetAssoc
      let v1 =
        let v1 =
          let v1 =
            let v1 =
              let v1 =
                -- Inline v1
                let v1 = <PrimUndefined>;
                -- Inline v2
                let v2 =
                  -- Inline v2
                  let v2 =
                    { eqRecord:
                        (\v@v2 -> \ra@v3 -> \rb@v4 ->
                          let get@v5 =
                            (Record.Unsafe.unsafeGet
                              -- Inline v5
                              let v5 = Type.Proxy.Proxy;
                              -- Inline v6
                              let v6 = "ix";
                              v6
                            );
                          (booleanAnd
                            (let v6 = (get@v5 ra@v3);
                            -- Inline v7
                            let v7 = (\v7 -> ((eq v6) v7));
                            (v7 (get@v5 rb@v4)))
                            (-- Inline v6
                            let v6 = Type.Proxy.Proxy;
                            -- Inline v7
                            let v7 = (\v1@v7 -> \v2@v8 -> true);
                            ((v7 ra@v3) rb@v4))
                          )
                        )
                    };
                  v2;
                v2;
              -- Inline v2
              let v2 =
                -- Inline v2
                let v2 = <PrimUndefined>;
                { eqRecord:
                    (\v@v3 -> \ra@v4 -> \rb@v5 ->
                      let get@v6 =
                        (Record.Unsafe.unsafeGet
                          -- Inline v6
                          let v6 = Type.Proxy.Proxy;
                          -- Inline v7
                          let v7 = "b";
                          v7
                        );
                      (booleanAnd
                        (let v7 = (get@v6 ra@v4);
                        -- Inline v8
                        let v8 = (\v8 -> ((eq v7) v8));
                        (v8 (get@v6 rb@v5)))
                        (((v1.eqRecord Type.Proxy.Proxy) ra@v4) rb@v5)
                      )
                    )
                };
              v2;
            -- Inline v2
            let v2 =
              -- Inline v2
              let v2 = <PrimUndefined>;
              { eqRecord:
                  (\v@v3 -> \ra@v4 -> \rb@v5 ->
                    let get@v6 =
                      (Record.Unsafe.unsafeGet
                        -- Inline v6
                        let v6 = Type.Proxy.Proxy;
                        -- Inline v7
                        let v7 = "a";
                        v7
                      );
                    (booleanAnd
                      (let v7 = (get@v6 ra@v4);
                      -- Inline v8
                      let v8 = (\v8 -> ((eq v7) v8));
                      (v8 (get@v6 rb@v5)))
                      (((v1.eqRecord Type.Proxy.Proxy) ra@v4) rb@v5)
                    )
                  )
              };
            v2;
          { eq: (v1.eqRecord Type.Proxy.Proxy) };
        v1;
      v1;
    -- Inline v1
    let v1 = { eq: (Data.Eq.eqArrayImpl v0.eq) };
    v1
    -- Inline v0
    let v0 =
      -- Inline v0
      let v0 = <PrimUndefined>;
      -- Inline v1
      let v1 =
        -- Inline v1
        let v1 =
          -- Inline v1
          let v1 = <PrimUndefined>;
          -- LetAssoc
          let v2 =
            let v2 =
              -- UnpackOp v2 Record ["showRecordFields"]
              let v2 =
                { showRecordFields:
                    (\v@v2 -> \record@v3 ->
                      -- Inline key@v4
                      let key@v4 =
                        -- Inline v4
                        let v4 = Type.Proxy.Proxy;
                        -- Inline v5
                        let v5 = "ix";
                        v5;
                      (stringAppend
                        " "
                        (stringAppend
                          key@v4
                          (stringAppend
                            ": "
                            (stringAppend
                              (Data.Show.showIntImpl
                                ((Record.Unsafe.unsafeGet key@v4) record@v3)
                              )
                              " "
                            )
                          )
                        )
                      )
                    )
                };
              -- Inline v3
              let v3 =
                { showRecordFields:
                    (\v@v3 -> \record@v4 ->
                      -- Inline key@v5
                      let key@v5 =
                        -- Inline v5
                        let v5 = Type.Proxy.Proxy;
                        -- Inline v6
                        let v6 = "b";
                        v6;
                      (stringAppend
                        " "
                        (stringAppend
                          key@v5
                          (stringAppend
                            ": "
                            (stringAppend
                              (Data.Show.showIntImpl
                                ((Record.Unsafe.unsafeGet key@v5) record@v4)
                              )
                              (stringAppend
                                ","
                                (v2.showRecordFields
                                  Type.Proxy.Proxy
                                  record@v4
                                )
                              )
                            )
                          )
                        )
                      )
                    )
                };
              v3;
            -- Inline v3
            let v3 =
              -- Inline v3
              let v3 =
                { showRecordFields:
                    (\v@v3 -> \record@v4 ->
                      -- Inline key@v5
                      let key@v5 =
                        -- Inline v5
                        let v5 = Type.Proxy.Proxy;
                        -- Inline v6
                        let v6 = "a";
                        v6;
                      (stringAppend
                        " "
                        (stringAppend
                          key@v5
                          (stringAppend
                            ": "
                            (stringAppend
                              (Data.Show.showStringImpl
                                ((Record.Unsafe.unsafeGet key@v5) record@v4)
                              )
                              (stringAppend
                                ","
                                (v2.showRecordFields
                                  Type.Proxy.Proxy
                                  record@v4
                                )
                              )
                            )
                          )
                        )
                      )
                    )
                };
              v3;
            v3;
          { show:
              (\record@v3 ->
                (stringAppend
                  "{"
                  (stringAppend
                    ((v2.showRecordFields Type.Proxy.Proxy) record@v3)
                    "}"
                  )
                )
              )
          };
        v1;
      v1;
    -- Inline v1
    let v1 = { show: (Data.Show.showArrayImpl v0.show) };
    v1
  )
---------------
Snapshot.HalogenVDomST02.assertEqual3 (Step 2)
  (Assert.assertEqual
    { eq:
        (Data.Eq.eqArrayImpl
          -- UnpackOp v0 Record ["eqRecord"]
          let v0 =
            { eqRecord:
                (\v@v0 -> \ra@v1 -> \rb@v2 ->
                  -- Inline get@v3
                  let get@v3 = (\v3 -> v3.ix);
                  -- Inline v4
                  let v4 = (get@v3 ra@v1);
                  -- Inline v5
                  let v5 = (get@v3 rb@v2);
                  ((eq v4) v5)
                )
            };
          -- Inline v1
          let v1 =
            -- UnpackOp v1 Record ["eqRecord"]
            let v1 =
              { eqRecord:
                  (\v@v1 -> \ra@v2 -> \rb@v3 ->
                    -- Inline get@v4
                    let get@v4 = (\v4 -> v4.b);
                    (booleanAnd
                      (-- Inline v5
                      let v5 = (get@v4 ra@v2);
                      -- Inline v6
                      let v6 = (get@v4 rb@v3);
                      ((eq v5) v6))
                      (((v0.eqRecord Type.Proxy.Proxy) ra@v2) rb@v3)
                    )
                  )
              };
            -- Inline v2
            let v2 =
              { eqRecord:
                  (\v@v2 -> \ra@v3 -> \rb@v4 ->
                    -- Inline get@v5
                    let get@v5 = (\v5 -> v5.a);
                    (booleanAnd
                      (-- Inline v6
                      let v6 = (get@v5 ra@v3);
                      -- Inline v7
                      let v7 = (get@v5 rb@v4);
                      ((eq v6) v7))
                      (((v1.eqRecord Type.Proxy.Proxy) ra@v3) rb@v4)
                    )
                  )
              };
            -- Inline v3
            let v3 = { eq: (v2.eqRecord Type.Proxy.Proxy) };
            v3;
          v1.eq
        )
    }
    { show:
        (Data.Show.showArrayImpl
          let v0 =
            -- Inline v0
            let v0 =
              (\v@v0 -> \record@v1 ->
                (stringAppend
                  " ix: "
                  ((stringAppend (Data.Show.showIntImpl record@v1.ix)) " ")
                )
              );
            { showRecordFields:
                (\v@v1 -> \record@v2 ->
                  (stringAppend
                    " b: "
                    (stringAppend
                      (Data.Show.showIntImpl record@v2.b)
                      ((stringAppend ",") ((v0 Type.Proxy.Proxy) record@v2))
                    )
                  )
                )
            };
          -- Inline v1
          let v1 =
            -- UnpackOp v1 Record ["showRecordFields"]
            let v1 =
              { showRecordFields:
                  (\v@v1 -> \record@v2 ->
                    (stringAppend
                      " a: "
                      (stringAppend
                        (Data.Show.showStringImpl record@v2.a)
                        (stringAppend
                          ","
                          ((v0.showRecordFields Type.Proxy.Proxy) record@v2)
                        )
                      )
                    )
                  )
              };
            { show:
                (\record@v2 ->
                  (stringAppend
                    "{"
                    (stringAppend
                      ((v1.showRecordFields Type.Proxy.Proxy) record@v2)
                      "}"
                    )
                  )
                )
            };
          v1.show
        )
    }
  )
---------------
Snapshot.HalogenVDomST02.assertEqual3 (Step 3)
  (Assert.assertEqual
    { eq:
        (Data.Eq.eqArrayImpl
          -- Inline v0
          let v0 = (\v@v0 -> \ra@v1 -> \rb@v2 -> ((eq ra@v1.ix) rb@v2.ix));
          -- Inline v1
          let v1 =
            (\v@v1 -> \ra@v2 -> \rb@v3 ->
              (booleanAnd
                ((eq ra@v2.b) rb@v3.b)
                (((v0 Type.Proxy.Proxy) ra@v2) rb@v3)
              )
            );
          -- Inline v2
          let v2 =
            { eq:
                -- Inline v2
                let v2 = Type.Proxy.Proxy;
                (\ra@v3 -> \rb@v4 ->
                  (booleanAnd
                    ((eq ra@v3.a) rb@v4.a)
                    (((v1 Type.Proxy.Proxy) ra@v3) rb@v4)
                  )
                )
            };
          v2.eq
        )
    }
    { show:
        (Data.Show.showArrayImpl
          -- UnpackOp v0 Record ["showRecordFields"]
          let v0 =
            { showRecordFields:
                (\v@v0 -> \record@v1 ->
                  -- Inline v2
                  let v2 = Type.Proxy.Proxy;
                  -- Inline v3
                  let v3 =
                    -- Inline v3
                    let v3 =
                      -- Inline v3
                      let v3 =
                        (stringAppend
                          " ix: "
                          (stringAppend
                            (Data.Show.showIntImpl record@v1.ix)
                            " "
                          )
                        );
                      ((stringAppend ",") v3);
                    ((stringAppend (Data.Show.showIntImpl record@v1.b)) v3);
                  ((stringAppend " b: ") v3)
                )
            };
          -- Inline v1
          let v1 =
            (\v@v1 -> \record@v2 ->
              (stringAppend
                " a: "
                (stringAppend
                  (Data.Show.showStringImpl record@v2.a)
                  (stringAppend
                    ","
                    ((v0.showRecordFields Type.Proxy.Proxy) record@v2)
                  )
                )
              )
            );
          -- Inline v2
          let v2 =
            { show:
                (\record@v2 ->
                  (stringAppend
                    "{"
                    ((stringAppend ((v1 Type.Proxy.Proxy) record@v2)) "}")
                  )
                )
            };
          v2.show
        )
    }
  )
---------------
Snapshot.HalogenVDomST02.assertEqual3 (Step 4)
  (Assert.assertEqual
    { eq:
        (Data.Eq.eqArrayImpl
          (\ra@v0 -> \rb@v1 ->
            (booleanAnd
              ((eq ra@v0.a) rb@v1.a)
              (-- Inline v2
              let v2 = Type.Proxy.Proxy;
              (booleanAnd
                ((eq ra@v0.b) rb@v1.b)
                (-- Inline v3
                let v3 = Type.Proxy.Proxy;
                ((eq ra@v0.ix) rb@v1.ix))
              ))
            )
          )
        )
    }
    { show:
        (Data.Show.showArrayImpl
          -- Inline v0
          let v0 =
            (\v@v0 -> \record@v1 ->
              (stringAppend
                " b: "
                (stringAppend
                  (Data.Show.showIntImpl record@v1.b)
                  (stringAppend
                    ", ix: "
                    ((stringAppend (Data.Show.showIntImpl record@v1.ix)) " ")
                  )
                )
              )
            );
          (\record@v1 ->
            -- Inline v2
            let v2 = Type.Proxy.Proxy;
            -- Inline v3
            let v3 =
              -- Inline v3
              let v3 =
                (stringAppend
                  " a: "
                  (stringAppend
                    (Data.Show.showStringImpl record@v1.a)
                    ((stringAppend ",") ((v0 Type.Proxy.Proxy) record@v1))
                  )
                );
              ((stringAppend v3) "}");
            ((stringAppend "{") v3)
          )
        )
    }
  )
---------------
Snapshot.HalogenVDomST02.assertEqual3 (Step 5)
  (Assert.assertEqual
    { eq:
        (Data.Eq.eqArrayImpl
          (\ra@v0 -> \rb@v1 ->
            (booleanAnd
              ((eq ra@v0.a) rb@v1.a)
              ((booleanAnd ((eq ra@v0.b) rb@v1.b)) ((eq ra@v0.ix) rb@v1.ix))
            )
          )
        )
    }
    { show:
        (Data.Show.showArrayImpl
          (\record@v0 ->
            -- Inline v1
            let v1 = Type.Proxy.Proxy;
            -- Inline v2
            let v2 =
              -- Inline v2
              let v2 =
                -- Inline v2
                let v2 =
                  -- Inline v2
                  let v2 =
                    -- Inline v2
                    let v2 =
                      (stringAppend
                        " b: "
                        (stringAppend
                          (Data.Show.showIntImpl record@v0.b)
                          (stringAppend
                            ", ix: "
                            (stringAppend
                              (Data.Show.showIntImpl record@v0.ix)
                              " "
                            )
                          )
                        )
                      );
                    ((stringAppend ",") v2);
                  ((stringAppend (Data.Show.showStringImpl record@v0.a)) v2);
                ((stringAppend " a: ") v2);
              ((stringAppend v2) "}");
            ((stringAppend "{") v2)
          )
        )
    }
  )
---------------
Snapshot.HalogenVDomST02.assertEqual3 (Step 6; Final)
  (Assert.assertEqual
    { eq:
        (Data.Eq.eqArrayImpl
          (\ra@v0 -> \rb@v1 ->
            (booleanAnd
              ((eq ra@v0.a) rb@v1.a)
              ((booleanAnd ((eq ra@v0.b) rb@v1.b)) ((eq ra@v0.ix) rb@v1.ix))
            )
          )
        )
    }
    { show:
        (Data.Show.showArrayImpl
          (\record@v0 ->
            (stringAppend
              (stringAppend
                "{ a: "
                (stringAppend
                  (Data.Show.showStringImpl record@v0.a)
                  (stringAppend
                    ", b: "
                    (stringAppend
                      (Data.Show.showIntImpl record@v0.b)
                      (stringAppend
                        ", ix: "
                        (stringAppend
                          (Data.Show.showIntImpl record@v0.ix)
                          " "
                        )
                      )
                    )
                  )
                )
              )
              "}"
            )
          )
        )
    }
  )

===============

Snapshot.HalogenVDomST02.bIsSymbol (Step 0; Original)
  { reflectSymbol: (\$__unused@v0 -> "b") }
---------------
Snapshot.HalogenVDomST02.bIsSymbol (Step 1; Final)
  { reflectSymbol: (\$__unused@v0 -> "b") }

===============

Snapshot.HalogenVDomST02.bind (Step 0; Original)
  (Control.Bind.bind Effect.bindEffect)
---------------
Snapshot.HalogenVDomST02.bind (Step 1; Final)
  Effect.bindE

===============

Snapshot.HalogenVDomST02.discard (Step 0; Original)
  ((Control.Bind.discard Control.Bind.discardUnit) Effect.bindEffect)
---------------
Snapshot.HalogenVDomST02.discard (Step 1; Final)
  Effect.bindE

===============

Snapshot.HalogenVDomST02.eqRec (Step 0; Original)
  (Data.Eq.eqRec <PrimUndefined>)
---------------
Snapshot.HalogenVDomST02.eqRec (Step 1; Final)
  (Data.Eq.eqRec <PrimUndefined>)

===============

Snapshot.HalogenVDomST02.eqRowCons (Step 0; Original)
  ((Data.Eq.eqRowCons Data.Eq.eqRowNil) <PrimUndefined>)
---------------
Snapshot.HalogenVDomST02.eqRowCons (Step 1; Final)
  ((Data.Eq.eqRowCons Data.Eq.eqRowNil) <PrimUndefined>)

===============

Snapshot.HalogenVDomST02.ixIsSymbol (Step 0; Original)
  { reflectSymbol: (\$__unused@v0 -> "ix") }
---------------
Snapshot.HalogenVDomST02.ixIsSymbol (Step 1; Final)
  { reflectSymbol: (\$__unused@v0 -> "ix") }

===============

Snapshot.HalogenVDomST02.liftST (Step 0; Original)
  (Control.Monad.ST.Class.liftST Control.Monad.ST.Class.monadSTEffect)
---------------
Snapshot.HalogenVDomST02.liftST (Step 1; Final)
  Unsafe.Coerce.unsafeCoerce

===============

Snapshot.HalogenVDomST02.main (Step 0; Original)
  (Snapshot.HalogenVDomST02.bind
    (Snapshot.HalogenVDomST02.liftST Data.Array.ST.new)
    (\merged1@v0 ->
      (Snapshot.HalogenVDomST02.bind
        (Snapshot.HalogenVDomST02.liftST Data.Array.ST.new)
        (\added1@v1 ->
          (Snapshot.HalogenVDomST02.bind
            (Snapshot.HalogenVDomST02.liftST Data.Array.ST.new)
            (\deleted1@v2 ->
              (Snapshot.HalogenVDomST02.bind
                (Effect.Uncurried.runEffectFn5
                  Snapshot.HalogenVDomST01.diffWithIxE
                  [ "1", "2", "3" ]
                  [ 1, 2 ]
                  (Effect.Uncurried.mkEffectFn3
                    (\ix@v3 -> \a@v4 -> \b@v5 ->
                      (Snapshot.HalogenVDomST02.discard
                        (Snapshot.HalogenVDomST02.void
                          (Snapshot.HalogenVDomST02.liftST
                            (Data.Array.ST.push
                              { a: a@v4, b: b@v5 }
                              merged1@v0
                            )
                          )
                        )
                        (\$__unused@v6 ->
                          (Snapshot.HalogenVDomST02.pure
                            { ix: ix@v3, a: a@v4, b: b@v5 }
                          )
                        )
                      )
                    )
                  )
                  (Effect.Uncurried.mkEffectFn2
                    (\v@v3 -> \a@v4 ->
                      (Snapshot.HalogenVDomST02.void
                        (Snapshot.HalogenVDomST02.liftST
                          ((Data.Array.ST.push a@v4) deleted1@v2)
                        )
                      )
                    )
                  )
                  (Effect.Uncurried.mkEffectFn2
                    (\ix@v3 -> \b@v4 ->
                      (Snapshot.HalogenVDomST02.discard
                        (Snapshot.HalogenVDomST02.void
                          (Snapshot.HalogenVDomST02.liftST
                            ((Data.Array.ST.push b@v4) added1@v1)
                          )
                        )
                        (\$__unused@v5 ->
                          (Snapshot.HalogenVDomST02.pure
                            { ix: ix@v3, a: "", b: b@v4 }
                          )
                        )
                      )
                    )
                  )
                )
                (\result@v3 ->
                  (Snapshot.HalogenVDomST02.bind
                    (Snapshot.HalogenVDomST02.liftST
                      (Data.Array.ST.freeze merged1@v0)
                    )
                    (\m1@v4 ->
                      (Snapshot.HalogenVDomST02.bind
                        (Snapshot.HalogenVDomST02.liftST
                          (Data.Array.ST.freeze added1@v1)
                        )
                        (\a1@v5 ->
                          (Snapshot.HalogenVDomST02.bind
                            (Snapshot.HalogenVDomST02.liftST
                              (Data.Array.ST.freeze deleted1@v2)
                            )
                            (\d1@v6 ->
                              (Snapshot.HalogenVDomST02.discard
                                (Snapshot.HalogenVDomST02.assertEqual
                                  "diffWithIxE/merged"
                                  { expected:
                                      [ { a: "1", b: 1 }, { a: "2", b: 2 } ]
                                  , actual:
                                      m1@v4
                                  }
                                )
                                (\$__unused@v7 ->
                                  (Snapshot.HalogenVDomST02.discard
                                    (Snapshot.HalogenVDomST02.assertEqual1
                                      "diffWithIxE/added"
                                      { expected: [], actual: a1@v5 }
                                    )
                                    (\$__unused@v8 ->
                                      (Snapshot.HalogenVDomST02.discard
                                        (Snapshot.HalogenVDomST02.assertEqual2
                                          "diffWithIxE/deleted"
                                          { expected: [ "3" ], actual: d1@v6 }
                                        )
                                        (\$__unused@v9 ->
                                          (Snapshot.HalogenVDomST02.assertEqual3
                                            "diffWithIxE/result"
                                            { expected:
                                                [ { ix: 0, a: "1", b: 1 }
                                                , { ix: 1, a: "2", b: 2 }
                                                ]
                                            , actual:
                                                result@v3
                                            }
                                          )
                                        )
                                      )
                                    )
                                  )
                                )
                              )
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
---------------
Snapshot.HalogenVDomST02.main (Step 1)
  letEffect merged1@v0 = Data.Array.ST.new;
  letEffect added1@v1 = Data.Array.ST.new;
  letEffect deleted1@v2 = Data.Array.ST.new;
  let v3 =
    -- Inline v3
    let v3 = [ "1", "2", "3" ];
    -- Inline v4
    let v4 =
      -- Inline v4
      let v4 = [ 1, 2 ];
      -- Inline v5
      let v5 =
        (# \ix@v5 a@v6 b@v7 ->
          -- LetAssoc
          let v8 =
            let v8 =
              -- Inline v8
              let v8 = { a: a@v6, b: b@v7 };
              -- Inline v9
              let v9 =
                -- Inline v9
                let v9 =
                  (\v9 ->
                    (# effectDefer
                      (-- Stop
                      Data.Array.ST.pushAll
                        [ v8 ]
                        v9
                      )
                    #)
                  );
                (v9 merged1@v0);
              v9;
            (# effectDefer
              letEffect a'@v9 = v8;
              (# effectPure <PrimUndefined> #)
            #);
          -- Inline v9
          let v9 =
            letEffect $__unused@v9 = v8;
            -- Inline v10
            let v10 = { ix: ix@v5, a: a@v6, b: b@v7 };
            -- Inline v11
            let v11 = (# effectPure v10 #);
            v11;
          v9
        #);
      -- Inline v6
      let v6 =
        (# \v@v6 a@v7 ->
          -- Inline v8
          let v8 =
            (# effectDefer
              (-- Stop
              Data.Array.ST.pushAll
                [ a@v7 ]
                deleted1@v2
              )
            #);
          (# effectDefer
            letEffect a'@v9 = v8;
            (# effectPure <PrimUndefined> #)
          #)
        #);
      -- Inline v7
      let v7 =
        (# \ix@v7 b@v8 ->
          let v9 =
            -- Inline v9
            let v9 =
              (# effectDefer
                (-- Stop
                Data.Array.ST.pushAll
                  [ b@v8 ]
                  added1@v1
                )
              #);
            (# effectDefer
              letEffect a'@v10 = v9;
              (# effectPure <PrimUndefined> #)
            #);
          -- Inline v10
          let v10 =
            letEffect $__unused@v10 = v9;
            -- Inline v11
            let v11 = { ix: ix@v7, a: "", b: b@v8 };
            -- Inline v12
            let v12 = (# effectPure v11 #);
            v12;
          v10
        #);
      (# Snapshot.HalogenVDomST01.diffWithIxE v3 v4 v5 v6 v7 #);
    v4;
  -- Inline v4
  let v4 =
    letEffect result@v4 = v3;
    let v5 = (Data.Array.ST.freeze merged1@v0);
    -- Inline v6
    let v6 =
      letEffect m1@v6 = v5;
      let v7 = (Data.Array.ST.freeze added1@v1);
      -- Inline v8
      let v8 =
        letEffect a1@v8 = v7;
        let v9 = (Data.Array.ST.freeze deleted1@v2);
        -- Inline v10
        let v10 =
          letEffect d1@v10 = v9;
          let v11 =
            (Snapshot.HalogenVDomST02.assertEqual
              "diffWithIxE/merged"
              { expected:
                  [ { a: "1", b: 1 }, { a: "2", b: 2 } ]
              , actual:
                  m1@v6
              }
            );
          -- Inline v12
          let v12 =
            letEffect $__unused@v12 = v11;
            let v13 =
              (Assert.assertEqual
                { eq: (Data.Eq.eqArrayImpl Data.Eq.eqIntImpl) }
                { show: (Data.Show.showArrayImpl Data.Show.showIntImpl) }
                "diffWithIxE/added"
                { expected: [], actual: a1@v8 }
              );
            -- Inline v14
            let v14 =
              letEffect $__unused@v14 = v13;
              let v15 =
                (Assert.assertEqual
                  { eq: (Data.Eq.eqArrayImpl Data.Eq.eqStringImpl) }
                  { show: (Data.Show.showArrayImpl Data.Show.showStringImpl) }
                  "diffWithIxE/deleted"
                  { expected: [ "3" ], actual: d1@v10 }
                );
              -- Inline v16
              let v16 =
                letEffect $__unused@v16 = v15;
                (Snapshot.HalogenVDomST02.assertEqual3
                  "diffWithIxE/result"
                  { expected:
                      [ { ix: 0, a: "1", b: 1 }, { ix: 1, a: "2", b: 2 } ]
                  , actual:
                      result@v4
                  }
                );
              v16;
            v14;
          v12;
        v10;
      v8;
    v6;
  v4
---------------
Snapshot.HalogenVDomST02.main (Step 2)
  letEffect merged1@v0 = Data.Array.ST.new;
  letEffect added1@v1 = Data.Array.ST.new;
  letEffect deleted1@v2 = Data.Array.ST.new;
  -- Inline v3
  let v3 =
    (# Snapshot.HalogenVDomST01.diffWithIxE
      [ "1", "2", "3" ]
      [ 1, 2 ]
      (# \ix@v3 a@v4 b@v5 ->
        -- Inline v6
        let v6 =
          (# effectDefer
            (-- Stop
            Data.Array.ST.pushAll
              [ { a: a@v4, b: b@v5 } ]
              merged1@v0
            )
          #);
        -- Inline v7
        let v7 =
          (# effectDefer
            letEffect a'@v7 = v6;
            (# effectPure <PrimUndefined> #)
          #);
        letEffect $__unused@v8 = v7;
        (# effectPure { ix: ix@v3, a: a@v4, b: b@v5 } #)
      #)
      (# \v@v3 a@v4 ->
        (# effectDefer
          letEffect a'@v5 =
            (-- Stop
            Data.Array.ST.pushAll
              [ a@v4 ]
              deleted1@v2
            );
          (# effectPure <PrimUndefined> #)
        #)
      #)
      (# \ix@v3 b@v4 ->
        -- Inline v5
        let v5 =
          (# effectDefer
            letEffect a'@v5 =
              (-- Stop
              Data.Array.ST.pushAll
                [ b@v4 ]
                added1@v1
              );
            (# effectPure <PrimUndefined> #)
          #);
        letEffect $__unused@v6 = v5;
        (# effectPure { ix: ix@v3, a: "", b: b@v4 } #)
      #)
    #);
  letEffect result@v4 = v3;
  -- Inline v5
  let v5 = (Data.Array.ST.freeze merged1@v0);
  letEffect m1@v6 = v5;
  -- Inline v7
  let v7 = (Data.Array.ST.freeze added1@v1);
  letEffect a1@v8 = v7;
  -- Inline v9
  let v9 = (Data.Array.ST.freeze deleted1@v2);
  letEffect d1@v10 = v9;
  -- Inline v11
  let v11 =
    (Snapshot.HalogenVDomST02.assertEqual
      "diffWithIxE/merged"
      { expected: [ { a: "1", b: 1 }, { a: "2", b: 2 } ], actual: m1@v6 }
    );
  letEffect $__unused@v12 = v11;
  -- Inline v13
  let v13 =
    (Assert.assertEqual
      { eq: (Data.Eq.eqArrayImpl Data.Eq.eqIntImpl) }
      { show: (Data.Show.showArrayImpl Data.Show.showIntImpl) }
      "diffWithIxE/added"
      { expected: [], actual: a1@v8 }
    );
  letEffect $__unused@v14 = v13;
  -- Inline v15
  let v15 =
    (Assert.assertEqual
      { eq: (Data.Eq.eqArrayImpl Data.Eq.eqStringImpl) }
      { show: (Data.Show.showArrayImpl Data.Show.showStringImpl) }
      "diffWithIxE/deleted"
      { expected: [ "3" ], actual: d1@v10 }
    );
  letEffect $__unused@v16 = v15;
  (Snapshot.HalogenVDomST02.assertEqual3
    "diffWithIxE/result"
    { expected:
        [ { ix: 0, a: "1", b: 1 }, { ix: 1, a: "2", b: 2 } ]
    , actual:
        result@v4
    }
  )
---------------
Snapshot.HalogenVDomST02.main (Step 3)
  letEffect merged1@v0 = Data.Array.ST.new;
  letEffect added1@v1 = Data.Array.ST.new;
  letEffect deleted1@v2 = Data.Array.ST.new;
  letEffect result@v3 =
    (# Snapshot.HalogenVDomST01.diffWithIxE
      [ "1", "2", "3" ]
      [ 1, 2 ]
      (# \ix@v3 a@v4 b@v5 ->
        -- EffectBindAssoc
        let $__unused@v6 =
          letEffect a'@v6 =
            (-- Stop
            Data.Array.ST.pushAll
              [ { a: a@v4, b: b@v5 } ]
              merged1@v0
            );
          (# effectPure <PrimUndefined> #);
        (# effectPure { ix: ix@v3, a: a@v4, b: b@v5 } #)
      #)
      (# \v@v3 a@v4 ->
        (# effectDefer
          letEffect a'@v5 =
            (-- Stop
            Data.Array.ST.pushAll
              [ a@v4 ]
              deleted1@v2
            );
          (# effectPure <PrimUndefined> #)
        #)
      #)
      (# \ix@v3 b@v4 ->
        -- EffectBindAssoc
        let $__unused@v5 =
          letEffect a'@v5 =
            (-- Stop
            Data.Array.ST.pushAll
              [ b@v4 ]
              added1@v1
            );
          (# effectPure <PrimUndefined> #);
        (# effectPure { ix: ix@v3, a: "", b: b@v4 } #)
      #)
    #);
  letEffect m1@v4 = (Data.Array.ST.freeze merged1@v0);
  letEffect a1@v5 = (Data.Array.ST.freeze added1@v1);
  letEffect d1@v6 = (Data.Array.ST.freeze deleted1@v2);
  letEffect $__unused@v7 =
    (Snapshot.HalogenVDomST02.assertEqual
      "diffWithIxE/merged"
      { expected: [ { a: "1", b: 1 }, { a: "2", b: 2 } ], actual: m1@v4 }
    );
  letEffect $__unused@v8 =
    (Assert.assertEqual
      { eq: (Data.Eq.eqArrayImpl Data.Eq.eqIntImpl) }
      { show: (Data.Show.showArrayImpl Data.Show.showIntImpl) }
      "diffWithIxE/added"
      { expected: [], actual: a1@v5 }
    );
  letEffect $__unused@v9 =
    (Assert.assertEqual
      { eq: (Data.Eq.eqArrayImpl Data.Eq.eqStringImpl) }
      { show: (Data.Show.showArrayImpl Data.Show.showStringImpl) }
      "diffWithIxE/deleted"
      { expected: [ "3" ], actual: d1@v6 }
    );
  (Snapshot.HalogenVDomST02.assertEqual3
    "diffWithIxE/result"
    { expected:
        [ { ix: 0, a: "1", b: 1 }, { ix: 1, a: "2", b: 2 } ]
    , actual:
        result@v3
    }
  )
---------------
Snapshot.HalogenVDomST02.main (Step 4)
  letEffect merged1@v0 = Data.Array.ST.new;
  letEffect added1@v1 = Data.Array.ST.new;
  letEffect deleted1@v2 = Data.Array.ST.new;
  letEffect result@v3 =
    (# Snapshot.HalogenVDomST01.diffWithIxE
      [ "1", "2", "3" ]
      [ 1, 2 ]
      (# \ix@v3 a@v4 b@v5 ->
        letEffect a'@v6 =
          (-- Stop
          Data.Array.ST.pushAll
            [ { a: a@v4, b: b@v5 } ]
            merged1@v0
          );
        -- Inline $__unused@v7
        let $__unused@v7 = <PrimUndefined>;
        (# effectPure { ix: ix@v3, a: a@v4, b: b@v5 } #)
      #)
      (# \v@v3 a@v4 ->
        (# effectDefer
          letEffect a'@v5 =
            (-- Stop
            Data.Array.ST.pushAll
              [ a@v4 ]
              deleted1@v2
            );
          (# effectPure <PrimUndefined> #)
        #)
      #)
      (# \ix@v3 b@v4 ->
        letEffect a'@v5 =
          (-- Stop
          Data.Array.ST.pushAll
            [ b@v4 ]
            added1@v1
          );
        -- Inline $__unused@v6
        let $__unused@v6 = <PrimUndefined>;
        (# effectPure { ix: ix@v3, a: "", b: b@v4 } #)
      #)
    #);
  letEffect m1@v4 = (Data.Array.ST.freeze merged1@v0);
  letEffect a1@v5 = (Data.Array.ST.freeze added1@v1);
  letEffect d1@v6 = (Data.Array.ST.freeze deleted1@v2);
  letEffect $__unused@v7 =
    (Snapshot.HalogenVDomST02.assertEqual
      "diffWithIxE/merged"
      { expected: [ { a: "1", b: 1 }, { a: "2", b: 2 } ], actual: m1@v4 }
    );
  letEffect $__unused@v8 =
    (Assert.assertEqual
      { eq: (Data.Eq.eqArrayImpl Data.Eq.eqIntImpl) }
      { show: (Data.Show.showArrayImpl Data.Show.showIntImpl) }
      "diffWithIxE/added"
      { expected: [], actual: a1@v5 }
    );
  letEffect $__unused@v9 =
    (Assert.assertEqual
      { eq: (Data.Eq.eqArrayImpl Data.Eq.eqStringImpl) }
      { show: (Data.Show.showArrayImpl Data.Show.showStringImpl) }
      "diffWithIxE/deleted"
      { expected: [ "3" ], actual: d1@v6 }
    );
  (Snapshot.HalogenVDomST02.assertEqual3
    "diffWithIxE/result"
    { expected:
        [ { ix: 0, a: "1", b: 1 }, { ix: 1, a: "2", b: 2 } ]
    , actual:
        result@v3
    }
  )
---------------
Snapshot.HalogenVDomST02.main (Step 5; Final)
  letEffect merged1@v0 = Data.Array.ST.new;
  letEffect added1@v1 = Data.Array.ST.new;
  letEffect deleted1@v2 = Data.Array.ST.new;
  letEffect result@v3 =
    (# Snapshot.HalogenVDomST01.diffWithIxE
      [ "1", "2", "3" ]
      [ 1, 2 ]
      (# \ix@v3 a@v4 b@v5 ->
        letEffect a'@v6 =
          (-- Stop
          Data.Array.ST.pushAll
            [ { a: a@v4, b: b@v5 } ]
            merged1@v0
          );
        (# effectPure { ix: ix@v3, a: a@v4, b: b@v5 } #)
      #)
      (# \v@v3 a@v4 ->
        (# effectDefer
          letEffect a'@v5 =
            (-- Stop
            Data.Array.ST.pushAll
              [ a@v4 ]
              deleted1@v2
            );
          (# effectPure <PrimUndefined> #)
        #)
      #)
      (# \ix@v3 b@v4 ->
        letEffect a'@v5 =
          (-- Stop
          Data.Array.ST.pushAll
            [ b@v4 ]
            added1@v1
          );
        (# effectPure { ix: ix@v3, a: "", b: b@v4 } #)
      #)
    #);
  letEffect m1@v4 = (Data.Array.ST.freeze merged1@v0);
  letEffect a1@v5 = (Data.Array.ST.freeze added1@v1);
  letEffect d1@v6 = (Data.Array.ST.freeze deleted1@v2);
  letEffect $__unused@v7 =
    (Snapshot.HalogenVDomST02.assertEqual
      "diffWithIxE/merged"
      { expected: [ { a: "1", b: 1 }, { a: "2", b: 2 } ], actual: m1@v4 }
    );
  letEffect $__unused@v8 =
    (Assert.assertEqual
      { eq: (Data.Eq.eqArrayImpl Data.Eq.eqIntImpl) }
      { show: (Data.Show.showArrayImpl Data.Show.showIntImpl) }
      "diffWithIxE/added"
      { expected: [], actual: a1@v5 }
    );
  letEffect $__unused@v9 =
    (Assert.assertEqual
      { eq: (Data.Eq.eqArrayImpl Data.Eq.eqStringImpl) }
      { show: (Data.Show.showArrayImpl Data.Show.showStringImpl) }
      "diffWithIxE/deleted"
      { expected: [ "3" ], actual: d1@v6 }
    );
  (Snapshot.HalogenVDomST02.assertEqual3
    "diffWithIxE/result"
    { expected:
        [ { ix: 0, a: "1", b: 1 }, { ix: 1, a: "2", b: 2 } ]
    , actual:
        result@v3
    }
  )

===============

Snapshot.HalogenVDomST02.pure (Step 0; Original)
  (Control.Applicative.pure Effect.applicativeEffect)
---------------
Snapshot.HalogenVDomST02.pure (Step 1; Final)
  Effect.pureE

===============

Snapshot.HalogenVDomST02.showRecord (Step 0; Original)
  ((Data.Show.showRecord <PrimUndefined>) <PrimUndefined>)
---------------
Snapshot.HalogenVDomST02.showRecord (Step 1; Final)
  ((Data.Show.showRecord <PrimUndefined>) <PrimUndefined>)

===============

Snapshot.HalogenVDomST02.showRecordFieldsCons (Step 0; Original)
  (Data.Show.showRecordFieldsCons Snapshot.HalogenVDomST02.aIsSymbol)
---------------
Snapshot.HalogenVDomST02.showRecordFieldsCons (Step 1; Final)
  (Data.Show.showRecordFieldsCons Snapshot.HalogenVDomST02.aIsSymbol)

===============

Snapshot.HalogenVDomST02.void (Step 0; Original)
  (Data.Functor.void Effect.functorEffect)
---------------
Snapshot.HalogenVDomST02.void (Step 1)
  -- Inline v0
  let v0 = (\v@v0 -> <PrimUndefined>);
  -- Inline v1
  let v1 =
    -- Inline v1
    let v1 =
      -- Inline v1
      let v1 =
        (\a@v1 ->
          (# effectDefer
            letEffect a'@v2 = a@v1;
            (# effectPure (v0 a'@v2) #)
          #)
        );
      v1;
    v1;
  v1
---------------
Snapshot.HalogenVDomST02.void (Step 2; Final)
  (\a@v0 ->
    (# effectDefer
      letEffect a'@v1 = a@v0;
      (# effectPure <PrimUndefined> #)
    #)
  )